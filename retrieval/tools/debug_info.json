{
    "name": "build123d",
    "classes": [
        {
            "name": "build123d.Align",
            "signature": "build123d.Align()",
            "methods": [],
            "variables": [
                "CENTER",
                "MAX",
                "MIN",
                "name",
                "value"
            ],
            "docstring": "Align object about Axis"
        },
        {
            "name": "build123d.AngularDirection",
            "signature": "build123d.AngularDirection()",
            "methods": [],
            "variables": [
                "CLOCKWISE",
                "COUNTER_CLOCKWISE",
                "name",
                "value"
            ],
            "docstring": "Angular rotation direction"
        },
        {
            "name": "build123d.ApproxOption",
            "signature": "build123d.ApproxOption()",
            "methods": [],
            "variables": [
                "ARC",
                "NONE",
                "SPLINE",
                "name",
                "value"
            ],
            "docstring": "DXF export spline approximation strategy"
        },
        {
            "name": "build123d.Arrow",
            "signature": "build123d.Arrow(arrow_size: float, shaft_path: Union[build123d.topology.Edge, build123d.topology.Wire], shaft_width: float, head_at_start: bool = True, head_type: build123d.build_enums.HeadType = <HeadType.CURVED>, mode: build123d.build_enums.Mode = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Arrow.bounding_box",
                    "signature": "build123d.Arrow.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Arrow.cast",
                    "signature": "build123d.Arrow.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Arrow.center",
                    "signature": "build123d.Arrow.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Arrow.chamfer",
                    "signature": "build123d.Arrow.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Arrow.clean",
                    "signature": "build123d.Arrow.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Arrow.closest_points",
                    "signature": "build123d.Arrow.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Arrow.combined_center",
                    "signature": "build123d.Arrow.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Arrow.compound",
                    "signature": "build123d.Arrow.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Arrow.compounds",
                    "signature": "build123d.Arrow.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Arrow.compute_mass",
                    "signature": "build123d.Arrow.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.copy",
                    "signature": "build123d.Arrow.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Arrow.copy_attributes_to",
                    "signature": "build123d.Arrow.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Arrow.cut",
                    "signature": "build123d.Arrow.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.distance",
                    "signature": "build123d.Arrow.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.distance_to",
                    "signature": "build123d.Arrow.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Arrow.distance_to_with_closest_points",
                    "signature": "build123d.Arrow.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Arrow.distances",
                    "signature": "build123d.Arrow.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.do_children_intersect",
                    "signature": "build123d.Arrow.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Arrow.dprism",
                    "signature": "build123d.Arrow.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Arrow.edge",
                    "signature": "build123d.Arrow.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Arrow.edges",
                    "signature": "build123d.Arrow.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Arrow.export_brep",
                    "signature": "build123d.Arrow.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.export_step",
                    "signature": "build123d.Arrow.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Arrow.export_stl",
                    "signature": "build123d.Arrow.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Arrow.extrude",
                    "signature": "build123d.Arrow.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Arrow.face",
                    "signature": "build123d.Arrow.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Arrow.faces",
                    "signature": "build123d.Arrow.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Arrow.faces_intersected_by_axis",
                    "signature": "build123d.Arrow.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Arrow.fillet",
                    "signature": "build123d.Arrow.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Arrow.find_intersection",
                    "signature": "build123d.Arrow.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Arrow.find_intersection_points",
                    "signature": "build123d.Arrow.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Arrow.first_level_shapes",
                    "signature": "build123d.Arrow.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Arrow.fix",
                    "signature": "build123d.Arrow.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Arrow.fuse",
                    "signature": "build123d.Arrow.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.get_type",
                    "signature": "build123d.Arrow.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Arrow.hash_code",
                    "signature": "build123d.Arrow.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.hollow",
                    "signature": "build123d.Arrow.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Arrow.intersect",
                    "signature": "build123d.Arrow.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.is_equal",
                    "signature": "build123d.Arrow.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.is_inside",
                    "signature": "build123d.Arrow.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Arrow.is_null",
                    "signature": "build123d.Arrow.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.is_same",
                    "signature": "build123d.Arrow.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.is_valid",
                    "signature": "build123d.Arrow.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.iter_path_reverse",
                    "signature": "build123d.Arrow.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Arrow.locate",
                    "signature": "build123d.Arrow.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.located",
                    "signature": "build123d.Arrow.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Arrow.make_compound",
                    "signature": "build123d.Arrow.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Arrow.make_text",
                    "signature": "build123d.Arrow.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Arrow.make_triad",
                    "signature": "build123d.Arrow.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Arrow.max_fillet",
                    "signature": "build123d.Arrow.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Arrow.mesh",
                    "signature": "build123d.Arrow.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.mirror",
                    "signature": "build123d.Arrow.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Arrow.move",
                    "signature": "build123d.Arrow.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.moved",
                    "signature": "build123d.Arrow.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Arrow.offset_3d",
                    "signature": "build123d.Arrow.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Arrow.project_faces",
                    "signature": "build123d.Arrow.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Arrow.project_to_viewport",
                    "signature": "build123d.Arrow.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Arrow.relocate",
                    "signature": "build123d.Arrow.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Arrow.rotate",
                    "signature": "build123d.Arrow.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Arrow.scale",
                    "signature": "build123d.Arrow.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.shape_type",
                    "signature": "build123d.Arrow.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Arrow.shell",
                    "signature": "build123d.Arrow.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Arrow.shells",
                    "signature": "build123d.Arrow.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Arrow.show_topology",
                    "signature": "build123d.Arrow.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Arrow.solid",
                    "signature": "build123d.Arrow.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Arrow.solids",
                    "signature": "build123d.Arrow.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Arrow.split",
                    "signature": "build123d.Arrow.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Arrow.split_by_perimeter",
                    "signature": "build123d.Arrow.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Arrow.tessellate",
                    "signature": "build123d.Arrow.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Arrow.to_arcs",
                    "signature": "build123d.Arrow.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Arrow.to_splines",
                    "signature": "build123d.Arrow.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Arrow.to_vtk_poly_data",
                    "signature": "build123d.Arrow.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Arrow.transform_geometry",
                    "signature": "build123d.Arrow.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Arrow.transform_shape",
                    "signature": "build123d.Arrow.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Arrow.transformed",
                    "signature": "build123d.Arrow.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Arrow.translate",
                    "signature": "build123d.Arrow.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Arrow.unwrap",
                    "signature": "build123d.Arrow.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Arrow.vertex",
                    "signature": "build123d.Arrow.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Arrow.vertices",
                    "signature": "build123d.Arrow.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Arrow.wire",
                    "signature": "build123d.Arrow.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Arrow.wires",
                    "signature": "build123d.Arrow.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Arrow with shaft\n\nArgs:\n    arrow_size (float): arrow head tip to tail length\n    shaft_path (Union[Edge, Wire]): line describing the shaft shape\n    shaft_width (float): line width of shaft\n    head_at_start (bool, optional): Defaults to True.\n    head_type (HeadType, optional): arrow head shape. Defaults to HeadType.CURVED.\n    mode (Mode, optional): _description_. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.ArrowHead",
            "signature": "build123d.ArrowHead(size: float, head_type: build123d.build_enums.HeadType = <HeadType.CURVED>, rotation: float = 0, mode: build123d.build_enums.Mode = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.ArrowHead.bounding_box",
                    "signature": "build123d.ArrowHead.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.ArrowHead.cast",
                    "signature": "build123d.ArrowHead.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.ArrowHead.center",
                    "signature": "build123d.ArrowHead.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.ArrowHead.chamfer",
                    "signature": "build123d.ArrowHead.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.ArrowHead.clean",
                    "signature": "build123d.ArrowHead.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.ArrowHead.closest_points",
                    "signature": "build123d.ArrowHead.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.ArrowHead.combined_center",
                    "signature": "build123d.ArrowHead.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.ArrowHead.compound",
                    "signature": "build123d.ArrowHead.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.ArrowHead.compounds",
                    "signature": "build123d.ArrowHead.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.ArrowHead.compute_mass",
                    "signature": "build123d.ArrowHead.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.copy",
                    "signature": "build123d.ArrowHead.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.ArrowHead.copy_attributes_to",
                    "signature": "build123d.ArrowHead.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.ArrowHead.cut",
                    "signature": "build123d.ArrowHead.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.distance",
                    "signature": "build123d.ArrowHead.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.distance_to",
                    "signature": "build123d.ArrowHead.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.ArrowHead.distance_to_with_closest_points",
                    "signature": "build123d.ArrowHead.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.ArrowHead.distances",
                    "signature": "build123d.ArrowHead.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.do_children_intersect",
                    "signature": "build123d.ArrowHead.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.ArrowHead.dprism",
                    "signature": "build123d.ArrowHead.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.ArrowHead.edge",
                    "signature": "build123d.ArrowHead.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.ArrowHead.edges",
                    "signature": "build123d.ArrowHead.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.ArrowHead.export_brep",
                    "signature": "build123d.ArrowHead.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.export_step",
                    "signature": "build123d.ArrowHead.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.ArrowHead.export_stl",
                    "signature": "build123d.ArrowHead.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.ArrowHead.extrude",
                    "signature": "build123d.ArrowHead.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.ArrowHead.face",
                    "signature": "build123d.ArrowHead.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.ArrowHead.faces",
                    "signature": "build123d.ArrowHead.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.ArrowHead.faces_intersected_by_axis",
                    "signature": "build123d.ArrowHead.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.ArrowHead.fillet",
                    "signature": "build123d.ArrowHead.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.ArrowHead.find_intersection",
                    "signature": "build123d.ArrowHead.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.ArrowHead.find_intersection_points",
                    "signature": "build123d.ArrowHead.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.ArrowHead.first_level_shapes",
                    "signature": "build123d.ArrowHead.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.ArrowHead.fix",
                    "signature": "build123d.ArrowHead.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.ArrowHead.fuse",
                    "signature": "build123d.ArrowHead.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.get_type",
                    "signature": "build123d.ArrowHead.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.ArrowHead.hash_code",
                    "signature": "build123d.ArrowHead.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.hollow",
                    "signature": "build123d.ArrowHead.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.ArrowHead.intersect",
                    "signature": "build123d.ArrowHead.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.is_equal",
                    "signature": "build123d.ArrowHead.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.is_inside",
                    "signature": "build123d.ArrowHead.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.ArrowHead.is_null",
                    "signature": "build123d.ArrowHead.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.is_same",
                    "signature": "build123d.ArrowHead.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.is_valid",
                    "signature": "build123d.ArrowHead.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.iter_path_reverse",
                    "signature": "build123d.ArrowHead.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.ArrowHead.locate",
                    "signature": "build123d.ArrowHead.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.located",
                    "signature": "build123d.ArrowHead.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.ArrowHead.make_compound",
                    "signature": "build123d.ArrowHead.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.make_text",
                    "signature": "build123d.ArrowHead.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.ArrowHead.make_triad",
                    "signature": "build123d.ArrowHead.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.ArrowHead.max_fillet",
                    "signature": "build123d.ArrowHead.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.ArrowHead.mesh",
                    "signature": "build123d.ArrowHead.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.mirror",
                    "signature": "build123d.ArrowHead.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.ArrowHead.move",
                    "signature": "build123d.ArrowHead.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.moved",
                    "signature": "build123d.ArrowHead.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.ArrowHead.offset_3d",
                    "signature": "build123d.ArrowHead.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.ArrowHead.project_faces",
                    "signature": "build123d.ArrowHead.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.ArrowHead.project_to_viewport",
                    "signature": "build123d.ArrowHead.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.ArrowHead.relocate",
                    "signature": "build123d.ArrowHead.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.ArrowHead.rotate",
                    "signature": "build123d.ArrowHead.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.ArrowHead.scale",
                    "signature": "build123d.ArrowHead.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.shape_type",
                    "signature": "build123d.ArrowHead.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.ArrowHead.shell",
                    "signature": "build123d.ArrowHead.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.ArrowHead.shells",
                    "signature": "build123d.ArrowHead.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.ArrowHead.show_topology",
                    "signature": "build123d.ArrowHead.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.ArrowHead.solid",
                    "signature": "build123d.ArrowHead.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.ArrowHead.solids",
                    "signature": "build123d.ArrowHead.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.ArrowHead.split",
                    "signature": "build123d.ArrowHead.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.ArrowHead.split_by_perimeter",
                    "signature": "build123d.ArrowHead.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.ArrowHead.tessellate",
                    "signature": "build123d.ArrowHead.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.ArrowHead.to_arcs",
                    "signature": "build123d.ArrowHead.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.ArrowHead.to_splines",
                    "signature": "build123d.ArrowHead.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.ArrowHead.to_vtk_poly_data",
                    "signature": "build123d.ArrowHead.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.ArrowHead.transform_geometry",
                    "signature": "build123d.ArrowHead.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.ArrowHead.transform_shape",
                    "signature": "build123d.ArrowHead.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.ArrowHead.transformed",
                    "signature": "build123d.ArrowHead.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.ArrowHead.translate",
                    "signature": "build123d.ArrowHead.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.ArrowHead.unwrap",
                    "signature": "build123d.ArrowHead.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.ArrowHead.vertex",
                    "signature": "build123d.ArrowHead.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.ArrowHead.vertices",
                    "signature": "build123d.ArrowHead.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.ArrowHead.wire",
                    "signature": "build123d.ArrowHead.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.ArrowHead.wires",
                    "signature": "build123d.ArrowHead.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: ArrowHead\n\nArgs:\n    size (float): tip to tail length\n    head_type (HeadType, optional): arrow head shape. Defaults to HeadType.CURVED.\n    rotation (float, optional): rotation in degrees. Defaults to 0.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.AutoNameEnum",
            "signature": "build123d.AutoNameEnum()",
            "methods": [],
            "variables": [
                "name",
                "value"
            ],
            "docstring": "An enum class that automatically sets members' value to their name."
        },
        {
            "name": "build123d.Axis",
            "signature": "build123d.Axis(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Axis.angle_between",
                    "signature": "build123d.Axis.angle_between(self, other: 'Axis') -> 'float'",
                    "docstring": "calculate angle between axes\n\nComputes the angular value, in degrees, between the direction of self and other\nbetween 0\u00b0 and 360\u00b0.\n\nArgs:\n    other (Axis): axis to compare to\n\nReturns:\n    float: angle between axes"
                },
                {
                    "name": "build123d.Axis.intersect",
                    "signature": "build123d.Axis.intersect(self, *args, **kwargs)",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Axis.is_coaxial",
                    "signature": "build123d.Axis.is_coaxial(self, other: 'Axis', angular_tolerance: 'float' = 1e-05, linear_tolerance: 'float' = 1e-05) -> 'bool'",
                    "docstring": "are axes coaxial\n\nTrue if the angle between self and other is lower or equal to angular_tolerance and\nthe distance between self and other is lower or equal to linear_tolerance.\n\nArgs:\n    other (Axis): axis to compare to\n    angular_tolerance (float, optional): max angular deviation. Defaults to 1e-5.\n    linear_tolerance (float, optional): max linear deviation. Defaults to 1e-5.\n\nReturns:\n    bool: axes are coaxial"
                },
                {
                    "name": "build123d.Axis.is_normal",
                    "signature": "build123d.Axis.is_normal(self, other: 'Axis', angular_tolerance: 'float' = 1e-05) -> 'bool'",
                    "docstring": "are axes normal\n\nReturns True if the direction of this and another axis are normal to each other. That is,\nif the angle between the two axes is equal to 90\u00b0 within the angular_tolerance.\n\nArgs:\n    other (Axis): axis to compare to\n    angular_tolerance (float, optional): max angular deviation. Defaults to 1e-5.\n\nReturns:\n    bool: axes are normal"
                },
                {
                    "name": "build123d.Axis.is_opposite",
                    "signature": "build123d.Axis.is_opposite(self, other: 'Axis', angular_tolerance: 'float' = 1e-05) -> 'bool'",
                    "docstring": "are axes opposite\n\nReturns True if the direction of this and another axis are parallel with\nopposite orientation. That is, if the angle between the two axes is equal\nto 180\u00b0 within the angular_tolerance.\n\nArgs:\n    other (Axis): axis to compare to\n    angular_tolerance (float, optional): max angular deviation. Defaults to 1e-5.\n\nReturns:\n    bool: axes are opposite"
                },
                {
                    "name": "build123d.Axis.is_parallel",
                    "signature": "build123d.Axis.is_parallel(self, other: 'Axis', angular_tolerance: 'float' = 1e-05) -> 'bool'",
                    "docstring": "are axes parallel\n\nReturns True if the direction of this and another axis are parallel with same\norientation or opposite orientation. That is, if the angle between the two axes is\nequal to 0\u00b0 or 180\u00b0 within the angular_tolerance.\n\nArgs:\n    other (Axis): axis to compare to\n    angular_tolerance (float, optional): max angular deviation. Defaults to 1e-5.\n\nReturns:\n    bool: axes are parallel"
                },
                {
                    "name": "build123d.Axis.located",
                    "signature": "build123d.Axis.located(self, new_location: 'Location')",
                    "docstring": "relocates self to a new location possibly changing position and direction"
                },
                {
                    "name": "build123d.Axis.reverse",
                    "signature": "build123d.Axis.reverse(self) -> 'Axis'",
                    "docstring": "Return a copy of self with the direction reversed"
                },
                {
                    "name": "build123d.Axis.to_plane",
                    "signature": "build123d.Axis.to_plane(self) -> 'Plane'",
                    "docstring": "Return self as Plane"
                }
            ],
            "variables": [
                "location"
            ],
            "docstring": "Axis\n\nAxis defined by point and direction\n\nArgs:\n    origin (VectorLike): start point\n    direction (VectorLike): direction\n    edge (Edge): origin & direction defined by start of edge\n\nAttributes:\n    position (Vector): the global position of the axis origin\n    direction (Vector): the normalized direction vector\n    wrapped (gp_Ax1): the OCP axis object"
        },
        {
            "name": "build123d.AxisMeta",
            "signature": "build123d.AxisMeta()",
            "methods": [
                {
                    "name": "build123d.AxisMeta.mro",
                    "signature": "build123d.AxisMeta.mro(self, /)",
                    "docstring": "Return a type's method resolution order."
                }
            ],
            "variables": [
                "X",
                "Y",
                "Z"
            ],
            "docstring": "Axis meta class to enable class properties"
        },
        {
            "name": "build123d.BallJoint",
            "signature": "build123d.BallJoint(label: 'str', to_part: 'Optional[Union[Solid, Compound]]' = None, joint_location: 'Optional[Location]' = None, angular_range: 'tuple[tuple[float, float], tuple[float, float], tuple[float, float]]' = ((0, 360), (0, 360), (0, 360)), angle_reference: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)))",
            "methods": [
                {
                    "name": "build123d.BallJoint.connect_to",
                    "signature": "build123d.BallJoint.connect_to(self, other: 'RigidJoint', *, angles: 'RotationLike' = None)",
                    "docstring": "Connect BallJoint and RigidJoint\n\nArgs:\n    other (RigidJoint): joint to connect to\n    angles (RotationLike, optional): angles about axes in degrees. Defaults to\n        range minimums.\n\nRaises:\n    TypeError: invalid other joint type\n    ValueError: angles out of range"
                },
                {
                    "name": "build123d.BallJoint.relative_to",
                    "signature": "build123d.BallJoint.relative_to(self, other: 'RigidJoint', *, angles: 'RotationLike' = None)",
                    "docstring": "relative_to - BallJoint\n\nReturn the relative location from this joint to the RigidJoint of another object\n\nArgs:\n    other (RigidJoint): joint to connect to\n    angles (RotationLike, optional): angles about axes in degrees. Defaults to\n        range minimums.\n\nRaises:\n    TypeError: invalid other joint type\n    ValueError: angles out of range"
                }
            ],
            "variables": [
                "location",
                "symbol"
            ],
            "docstring": "BallJoint\n\nA component rotates around all 3 axes using a gimbal system (3 nested rotations).\n\nArgs:\n    label (str): joint label\n    to_part (Union[Solid, Compound], optional): object to attach joint to\n    joint_location (Location): global location of joint\n    angular_range\n        (tuple[ tuple[float, float], tuple[float, float], tuple[float, float] ], optional):\n        X, Y, Z angle (min, max) pairs. Defaults to ((0, 360), (0, 360), (0, 360)).\n    angle_reference (Plane, optional): plane relative to part defining zero degrees of\n        rotation. Defaults to Plane.XY.\n\nAttributes:\n    relative_location (Location): joint location relative to bound part\n    angular_range\n        (tuple[ tuple[float, float], tuple[float, float], tuple[float, float] ]):\n        X, Y, Z angle (min, max) pairs.\n    angle_reference (Plane): plane relative to part defining zero degrees of"
        },
        {
            "name": "build123d.BaseEdgeObject",
            "signature": "build123d.BaseEdgeObject(curve: 'Edge', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.BaseEdgeObject.bounding_box",
                    "signature": "build123d.BaseEdgeObject.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.cast",
                    "signature": "build123d.BaseEdgeObject.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.BaseEdgeObject.center",
                    "signature": "build123d.BaseEdgeObject.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.BaseEdgeObject.clean",
                    "signature": "build123d.BaseEdgeObject.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.BaseEdgeObject.close",
                    "signature": "build123d.BaseEdgeObject.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.BaseEdgeObject.closest_points",
                    "signature": "build123d.BaseEdgeObject.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.BaseEdgeObject.combined_center",
                    "signature": "build123d.BaseEdgeObject.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.BaseEdgeObject.common_plane",
                    "signature": "build123d.BaseEdgeObject.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.BaseEdgeObject.compound",
                    "signature": "build123d.BaseEdgeObject.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.BaseEdgeObject.compounds",
                    "signature": "build123d.BaseEdgeObject.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.compute_mass",
                    "signature": "build123d.BaseEdgeObject.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.copy",
                    "signature": "build123d.BaseEdgeObject.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.BaseEdgeObject.copy_attributes_to",
                    "signature": "build123d.BaseEdgeObject.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.BaseEdgeObject.cut",
                    "signature": "build123d.BaseEdgeObject.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.distance",
                    "signature": "build123d.BaseEdgeObject.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.distance_to",
                    "signature": "build123d.BaseEdgeObject.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.BaseEdgeObject.distance_to_with_closest_points",
                    "signature": "build123d.BaseEdgeObject.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.distances",
                    "signature": "build123d.BaseEdgeObject.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.distribute_locations",
                    "signature": "build123d.BaseEdgeObject.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.BaseEdgeObject.edge",
                    "signature": "build123d.BaseEdgeObject.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.BaseEdgeObject.edges",
                    "signature": "build123d.BaseEdgeObject.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.end_point",
                    "signature": "build123d.BaseEdgeObject.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.BaseEdgeObject.export_brep",
                    "signature": "build123d.BaseEdgeObject.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.export_step",
                    "signature": "build123d.BaseEdgeObject.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.BaseEdgeObject.export_stl",
                    "signature": "build123d.BaseEdgeObject.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.BaseEdgeObject.extrude",
                    "signature": "build123d.BaseEdgeObject.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.face",
                    "signature": "build123d.BaseEdgeObject.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.BaseEdgeObject.faces",
                    "signature": "build123d.BaseEdgeObject.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.faces_intersected_by_axis",
                    "signature": "build123d.BaseEdgeObject.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.BaseEdgeObject.find_intersection",
                    "signature": "build123d.BaseEdgeObject.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.BaseEdgeObject.find_intersection_points",
                    "signature": "build123d.BaseEdgeObject.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.BaseEdgeObject.find_tangent",
                    "signature": "build123d.BaseEdgeObject.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.BaseEdgeObject.fix",
                    "signature": "build123d.BaseEdgeObject.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.BaseEdgeObject.fuse",
                    "signature": "build123d.BaseEdgeObject.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.hash_code",
                    "signature": "build123d.BaseEdgeObject.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.intersect",
                    "signature": "build123d.BaseEdgeObject.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.BaseEdgeObject.is_equal",
                    "signature": "build123d.BaseEdgeObject.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.is_null",
                    "signature": "build123d.BaseEdgeObject.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.is_same",
                    "signature": "build123d.BaseEdgeObject.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.is_valid",
                    "signature": "build123d.BaseEdgeObject.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.iter_path_reverse",
                    "signature": "build123d.BaseEdgeObject.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.BaseEdgeObject.locate",
                    "signature": "build123d.BaseEdgeObject.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.located",
                    "signature": "build123d.BaseEdgeObject.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.BaseEdgeObject.location_at",
                    "signature": "build123d.BaseEdgeObject.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.BaseEdgeObject.locations",
                    "signature": "build123d.BaseEdgeObject.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.BaseEdgeObject.make_bezier",
                    "signature": "build123d.BaseEdgeObject.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.BaseEdgeObject.make_circle",
                    "signature": "build123d.BaseEdgeObject.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.BaseEdgeObject.make_ellipse",
                    "signature": "build123d.BaseEdgeObject.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.BaseEdgeObject.make_helix",
                    "signature": "build123d.BaseEdgeObject.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.BaseEdgeObject.make_line",
                    "signature": "build123d.BaseEdgeObject.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.BaseEdgeObject.make_mid_way",
                    "signature": "build123d.BaseEdgeObject.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.BaseEdgeObject.make_spline",
                    "signature": "build123d.BaseEdgeObject.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.BaseEdgeObject.make_spline_approx",
                    "signature": "build123d.BaseEdgeObject.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.BaseEdgeObject.make_tangent_arc",
                    "signature": "build123d.BaseEdgeObject.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.BaseEdgeObject.make_three_point_arc",
                    "signature": "build123d.BaseEdgeObject.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.BaseEdgeObject.mesh",
                    "signature": "build123d.BaseEdgeObject.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.mirror",
                    "signature": "build123d.BaseEdgeObject.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.move",
                    "signature": "build123d.BaseEdgeObject.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.moved",
                    "signature": "build123d.BaseEdgeObject.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.BaseEdgeObject.normal",
                    "signature": "build123d.BaseEdgeObject.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.offset_2d",
                    "signature": "build123d.BaseEdgeObject.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.BaseEdgeObject.param_at",
                    "signature": "build123d.BaseEdgeObject.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.BaseEdgeObject.param_at_point",
                    "signature": "build123d.BaseEdgeObject.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.BaseEdgeObject.perpendicular_line",
                    "signature": "build123d.BaseEdgeObject.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.BaseEdgeObject.position_at",
                    "signature": "build123d.BaseEdgeObject.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.BaseEdgeObject.positions",
                    "signature": "build123d.BaseEdgeObject.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.BaseEdgeObject.project",
                    "signature": "build123d.BaseEdgeObject.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.project_faces",
                    "signature": "build123d.BaseEdgeObject.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.BaseEdgeObject.project_to_shape",
                    "signature": "build123d.BaseEdgeObject.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.BaseEdgeObject.project_to_viewport",
                    "signature": "build123d.BaseEdgeObject.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.BaseEdgeObject.relocate",
                    "signature": "build123d.BaseEdgeObject.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.BaseEdgeObject.reversed",
                    "signature": "build123d.BaseEdgeObject.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.BaseEdgeObject.rotate",
                    "signature": "build123d.BaseEdgeObject.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.BaseEdgeObject.scale",
                    "signature": "build123d.BaseEdgeObject.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.shape_type",
                    "signature": "build123d.BaseEdgeObject.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.BaseEdgeObject.shell",
                    "signature": "build123d.BaseEdgeObject.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.BaseEdgeObject.shells",
                    "signature": "build123d.BaseEdgeObject.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.show_topology",
                    "signature": "build123d.BaseEdgeObject.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.BaseEdgeObject.solid",
                    "signature": "build123d.BaseEdgeObject.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.BaseEdgeObject.solids",
                    "signature": "build123d.BaseEdgeObject.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.split",
                    "signature": "build123d.BaseEdgeObject.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.BaseEdgeObject.split_by_perimeter",
                    "signature": "build123d.BaseEdgeObject.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.BaseEdgeObject.start_point",
                    "signature": "build123d.BaseEdgeObject.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.BaseEdgeObject.tangent_angle_at",
                    "signature": "build123d.BaseEdgeObject.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.BaseEdgeObject.tangent_at",
                    "signature": "build123d.BaseEdgeObject.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.BaseEdgeObject.tessellate",
                    "signature": "build123d.BaseEdgeObject.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.BaseEdgeObject.to_arcs",
                    "signature": "build123d.BaseEdgeObject.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.BaseEdgeObject.to_axis",
                    "signature": "build123d.BaseEdgeObject.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.BaseEdgeObject.to_splines",
                    "signature": "build123d.BaseEdgeObject.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.BaseEdgeObject.to_vtk_poly_data",
                    "signature": "build123d.BaseEdgeObject.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.BaseEdgeObject.to_wire",
                    "signature": "build123d.BaseEdgeObject.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.BaseEdgeObject.transform_geometry",
                    "signature": "build123d.BaseEdgeObject.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.BaseEdgeObject.transform_shape",
                    "signature": "build123d.BaseEdgeObject.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.BaseEdgeObject.transformed",
                    "signature": "build123d.BaseEdgeObject.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.BaseEdgeObject.translate",
                    "signature": "build123d.BaseEdgeObject.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseEdgeObject.trim",
                    "signature": "build123d.BaseEdgeObject.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.BaseEdgeObject.trim_to_length",
                    "signature": "build123d.BaseEdgeObject.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.BaseEdgeObject.vertex",
                    "signature": "build123d.BaseEdgeObject.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.BaseEdgeObject.vertices",
                    "signature": "build123d.BaseEdgeObject.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.BaseEdgeObject.wire",
                    "signature": "build123d.BaseEdgeObject.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.BaseEdgeObject.wires",
                    "signature": "build123d.BaseEdgeObject.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "BaseEdgeObject specialized for Edge.\n\nArgs:\n    curve (Edge): edge to create.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.BaseLineObject",
            "signature": "build123d.BaseLineObject(curve: 'Wire', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.BaseLineObject.bounding_box",
                    "signature": "build123d.BaseLineObject.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.BaseLineObject.cast",
                    "signature": "build123d.BaseLineObject.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.BaseLineObject.center",
                    "signature": "build123d.BaseLineObject.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.BaseLineObject.chamfer_2d",
                    "signature": "build123d.BaseLineObject.chamfer_2d(self, distance: 'float', distance2: 'float', vertices: 'Iterable[Vertex]', edge: 'Edge' = None) -> 'Wire'",
                    "docstring": "chamfer_2d\n\nApply 2D chamfer to a wire\n\nArgs:\n    distance (float): chamfer length\n    distance2 (float): chamfer length\n    vertices (Iterable[Vertex]): vertices to chamfer\n    edge (Edge): identifies the side where length is measured. The vertices must be\n        part of the edge\n\nReturns:\n    Wire: chamfered wire"
                },
                {
                    "name": "build123d.BaseLineObject.clean",
                    "signature": "build123d.BaseLineObject.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.BaseLineObject.close",
                    "signature": "build123d.BaseLineObject.close(self) -> 'Wire'",
                    "docstring": "Close a Wire"
                },
                {
                    "name": "build123d.BaseLineObject.closest_points",
                    "signature": "build123d.BaseLineObject.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.BaseLineObject.combine",
                    "signature": "build123d.BaseLineObject.combine(wires: 'Iterable[Union[Wire, Edge]]', tol: 'float' = 1e-09) -> 'ShapeList[Wire]'",
                    "docstring": "combine\n\nCombine a list of wires and edges into a list of Wires.\n\nArgs:\n    wires (Iterable[Union[Wire, Edge]]): unsorted\n    tol (float, optional): tolerance. Defaults to 1e-9.\n\nReturns:\n    ShapeList[Wire]: Wires"
                },
                {
                    "name": "build123d.BaseLineObject.combined_center",
                    "signature": "build123d.BaseLineObject.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.BaseLineObject.common_plane",
                    "signature": "build123d.BaseLineObject.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.BaseLineObject.compound",
                    "signature": "build123d.BaseLineObject.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.BaseLineObject.compounds",
                    "signature": "build123d.BaseLineObject.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.BaseLineObject.compute_mass",
                    "signature": "build123d.BaseLineObject.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.copy",
                    "signature": "build123d.BaseLineObject.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.BaseLineObject.copy_attributes_to",
                    "signature": "build123d.BaseLineObject.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.BaseLineObject.cut",
                    "signature": "build123d.BaseLineObject.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.distance",
                    "signature": "build123d.BaseLineObject.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.distance_to",
                    "signature": "build123d.BaseLineObject.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.BaseLineObject.distance_to_with_closest_points",
                    "signature": "build123d.BaseLineObject.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.BaseLineObject.distances",
                    "signature": "build123d.BaseLineObject.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.edge",
                    "signature": "build123d.BaseLineObject.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.BaseLineObject.edges",
                    "signature": "build123d.BaseLineObject.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.BaseLineObject.end_point",
                    "signature": "build123d.BaseLineObject.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.BaseLineObject.export_brep",
                    "signature": "build123d.BaseLineObject.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.export_step",
                    "signature": "build123d.BaseLineObject.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.BaseLineObject.export_stl",
                    "signature": "build123d.BaseLineObject.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.BaseLineObject.extrude",
                    "signature": "build123d.BaseLineObject.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.BaseLineObject.face",
                    "signature": "build123d.BaseLineObject.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.BaseLineObject.faces",
                    "signature": "build123d.BaseLineObject.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.BaseLineObject.faces_intersected_by_axis",
                    "signature": "build123d.BaseLineObject.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.BaseLineObject.fillet_2d",
                    "signature": "build123d.BaseLineObject.fillet_2d(self, radius: 'float', vertices: 'Iterable[Vertex]') -> 'Wire'",
                    "docstring": "fillet_2d\n\nApply 2D fillet to a wire\n\nArgs:\n    radius (float):\n    vertices (Iterable[Vertex]): vertices to fillet\n\nReturns:\n    Wire: filleted wire"
                },
                {
                    "name": "build123d.BaseLineObject.find_intersection",
                    "signature": "build123d.BaseLineObject.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.BaseLineObject.find_intersection_points",
                    "signature": "build123d.BaseLineObject.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.BaseLineObject.fix",
                    "signature": "build123d.BaseLineObject.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.BaseLineObject.fix_degenerate_edges",
                    "signature": "build123d.BaseLineObject.fix_degenerate_edges(self, precision: 'float') -> 'Wire'",
                    "docstring": "fix_degenerate_edges\n\nFix a Wire that contains degenerate (very small) edges\n\nArgs:\n    precision (float): minimum value edge length\n\nReturns:\n    Wire: fixed wire"
                },
                {
                    "name": "build123d.BaseLineObject.fuse",
                    "signature": "build123d.BaseLineObject.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.BaseLineObject.hash_code",
                    "signature": "build123d.BaseLineObject.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.intersect",
                    "signature": "build123d.BaseLineObject.intersect(self, *to_intersect: 'Union[Shape, Axis, Plane]') -> 'Shape'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.BaseLineObject.is_equal",
                    "signature": "build123d.BaseLineObject.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.is_null",
                    "signature": "build123d.BaseLineObject.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.is_same",
                    "signature": "build123d.BaseLineObject.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.is_valid",
                    "signature": "build123d.BaseLineObject.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.iter_path_reverse",
                    "signature": "build123d.BaseLineObject.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.BaseLineObject.locate",
                    "signature": "build123d.BaseLineObject.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.located",
                    "signature": "build123d.BaseLineObject.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.BaseLineObject.location_at",
                    "signature": "build123d.BaseLineObject.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.BaseLineObject.locations",
                    "signature": "build123d.BaseLineObject.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.BaseLineObject.make_circle",
                    "signature": "build123d.BaseLineObject.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Wire'",
                    "docstring": "make_circle\n\nMakes a circle centered at the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane): base plane. Defaults to Plane.XY\n\nReturns:\n    Wire: a circle"
                },
                {
                    "name": "build123d.BaseLineObject.make_convex_hull",
                    "signature": "build123d.BaseLineObject.make_convex_hull(edges: 'Iterable[Edge]', tolerance: 'float' = 0.001) -> 'Wire'",
                    "docstring": "make_convex_hull\n\nCreate a wire of minimum length enclosing all of the provided edges.\n\nNote that edges can't overlap each other.\n\nArgs:\n    edges (Iterable[Edge]): edges defining the convex hull\n    tolerance (float): allowable error as a fraction of each edge length.\n        Defaults to 1e-3.\n\nRaises:\n    ValueError: edges overlap\n\nReturns:\n    Wire: convex hull perimeter"
                },
                {
                    "name": "build123d.BaseLineObject.make_ellipse",
                    "signature": "build123d.BaseLineObject.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>, closed: 'bool' = True) -> 'Wire'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): _description_. Defaults to 360.0.\n    end_angle (float, optional): _description_. Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n    closed (bool, optional): close the arc. Defaults to True.\n\nReturns:\n    Wire: an ellipse"
                },
                {
                    "name": "build123d.BaseLineObject.make_polygon",
                    "signature": "build123d.BaseLineObject.make_polygon(vertices: 'Iterable[VectorLike]', close: 'bool' = True) -> 'Wire'",
                    "docstring": "make_polygon\n\nCreate an irregular polygon by defining vertices\n\nArgs:\n    vertices (Iterable[VectorLike]):\n    close (bool, optional): close the polygon. Defaults to True.\n\nReturns:\n    Wire: an irregular polygon"
                },
                {
                    "name": "build123d.BaseLineObject.make_rect",
                    "signature": "build123d.BaseLineObject.make_rect(width: 'float', height: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Wire'",
                    "docstring": "Make Rectangle\n\nMake a Rectangle centered on center with the given normal\n\nArgs:\n    width (float): width (local x)\n    height (float): height (local y)\n    plane (Plane, optional): plane containing rectangle. Defaults to Plane.XY.\n\nReturns:\n    Wire: The centered rectangle"
                },
                {
                    "name": "build123d.BaseLineObject.make_wire",
                    "signature": "build123d.BaseLineObject.make_wire(edges: 'Iterable[Edge]', sequenced: 'bool' = False) -> 'Wire'",
                    "docstring": "make_wire\n\nBuild a Wire from the provided unsorted Edges. If sequenced is True the\nEdges are placed in such that the end of the nth Edge is coincident with\nthe n+1th Edge forming an unbroken sequence. Note that sequencing a list\nis relatively slow.\n\nArgs:\n    edges (Iterable[Edge]): Edges to assemble\n    sequenced (bool, optional): arrange in order. Defaults to False.\n\nRaises:\n    ValueError: Edges are disconnected and can't be sequenced.\n    RuntimeError: Wire is empty\n\nReturns:\n    Wire: assembled edges"
                },
                {
                    "name": "build123d.BaseLineObject.mesh",
                    "signature": "build123d.BaseLineObject.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.mirror",
                    "signature": "build123d.BaseLineObject.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.BaseLineObject.move",
                    "signature": "build123d.BaseLineObject.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.moved",
                    "signature": "build123d.BaseLineObject.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.BaseLineObject.normal",
                    "signature": "build123d.BaseLineObject.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.offset_2d",
                    "signature": "build123d.BaseLineObject.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.BaseLineObject.order_edges",
                    "signature": "build123d.BaseLineObject.order_edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "Return the edges in self ordered by wire direction and orientation"
                },
                {
                    "name": "build123d.BaseLineObject.param_at",
                    "signature": "build123d.BaseLineObject.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.BaseLineObject.param_at_point",
                    "signature": "build123d.BaseLineObject.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Parameter at point on Wire"
                },
                {
                    "name": "build123d.BaseLineObject.perpendicular_line",
                    "signature": "build123d.BaseLineObject.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.BaseLineObject.position_at",
                    "signature": "build123d.BaseLineObject.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.BaseLineObject.positions",
                    "signature": "build123d.BaseLineObject.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.BaseLineObject.project",
                    "signature": "build123d.BaseLineObject.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.project_faces",
                    "signature": "build123d.BaseLineObject.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.BaseLineObject.project_to_shape",
                    "signature": "build123d.BaseLineObject.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Wire]'",
                    "docstring": "Project Wire\n\nProject a Wire onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected wire(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.BaseLineObject.project_to_viewport",
                    "signature": "build123d.BaseLineObject.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.BaseLineObject.relocate",
                    "signature": "build123d.BaseLineObject.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.BaseLineObject.rotate",
                    "signature": "build123d.BaseLineObject.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.BaseLineObject.scale",
                    "signature": "build123d.BaseLineObject.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.shape_type",
                    "signature": "build123d.BaseLineObject.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.BaseLineObject.shell",
                    "signature": "build123d.BaseLineObject.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.BaseLineObject.shells",
                    "signature": "build123d.BaseLineObject.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.BaseLineObject.show_topology",
                    "signature": "build123d.BaseLineObject.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.BaseLineObject.solid",
                    "signature": "build123d.BaseLineObject.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.BaseLineObject.solids",
                    "signature": "build123d.BaseLineObject.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.BaseLineObject.split",
                    "signature": "build123d.BaseLineObject.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.BaseLineObject.split_by_perimeter",
                    "signature": "build123d.BaseLineObject.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.BaseLineObject.start_point",
                    "signature": "build123d.BaseLineObject.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.BaseLineObject.stitch",
                    "signature": "build123d.BaseLineObject.stitch(self, other: 'Wire') -> 'Wire'",
                    "docstring": "Attempt to stich wires\n\nArgs:\n  other: Wire:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.tangent_angle_at",
                    "signature": "build123d.BaseLineObject.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.BaseLineObject.tangent_at",
                    "signature": "build123d.BaseLineObject.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.BaseLineObject.tessellate",
                    "signature": "build123d.BaseLineObject.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.BaseLineObject.to_arcs",
                    "signature": "build123d.BaseLineObject.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.BaseLineObject.to_splines",
                    "signature": "build123d.BaseLineObject.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.BaseLineObject.to_vtk_poly_data",
                    "signature": "build123d.BaseLineObject.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.BaseLineObject.to_wire",
                    "signature": "build123d.BaseLineObject.to_wire(self) -> 'Wire'",
                    "docstring": "Return Wire - used as a pair with Edge.to_wire when self is Wire | Edge"
                },
                {
                    "name": "build123d.BaseLineObject.transform_geometry",
                    "signature": "build123d.BaseLineObject.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.BaseLineObject.transform_shape",
                    "signature": "build123d.BaseLineObject.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.BaseLineObject.transformed",
                    "signature": "build123d.BaseLineObject.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.BaseLineObject.translate",
                    "signature": "build123d.BaseLineObject.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseLineObject.trim",
                    "signature": "build123d.BaseLineObject.trim(self: 'Wire', start: 'float', end: 'float') -> 'Wire'",
                    "docstring": "trim\n\nCreate a new wire by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Wire: trimmed wire"
                },
                {
                    "name": "build123d.BaseLineObject.vertex",
                    "signature": "build123d.BaseLineObject.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.BaseLineObject.vertices",
                    "signature": "build123d.BaseLineObject.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.BaseLineObject.wire",
                    "signature": "build123d.BaseLineObject.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.BaseLineObject.wires",
                    "signature": "build123d.BaseLineObject.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "BaseLineObject specialized for Wire.\n\nArgs:\n    curve (Wire): wire to create.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.BasePartObject",
            "signature": "build123d.BasePartObject(part: 'Union[Part, Solid]', rotation: 'RotationLike' = (0, 0, 0), align: 'Union[Align, tuple[Align, Align, Align]]' = None, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.BasePartObject.bounding_box",
                    "signature": "build123d.BasePartObject.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.BasePartObject.cast",
                    "signature": "build123d.BasePartObject.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.BasePartObject.center",
                    "signature": "build123d.BasePartObject.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.BasePartObject.chamfer",
                    "signature": "build123d.BasePartObject.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.BasePartObject.clean",
                    "signature": "build123d.BasePartObject.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.BasePartObject.closest_points",
                    "signature": "build123d.BasePartObject.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.BasePartObject.combined_center",
                    "signature": "build123d.BasePartObject.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.BasePartObject.compound",
                    "signature": "build123d.BasePartObject.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.BasePartObject.compounds",
                    "signature": "build123d.BasePartObject.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.BasePartObject.compute_mass",
                    "signature": "build123d.BasePartObject.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.copy",
                    "signature": "build123d.BasePartObject.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.BasePartObject.copy_attributes_to",
                    "signature": "build123d.BasePartObject.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.BasePartObject.cut",
                    "signature": "build123d.BasePartObject.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.distance",
                    "signature": "build123d.BasePartObject.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.distance_to",
                    "signature": "build123d.BasePartObject.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.BasePartObject.distance_to_with_closest_points",
                    "signature": "build123d.BasePartObject.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.BasePartObject.distances",
                    "signature": "build123d.BasePartObject.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.do_children_intersect",
                    "signature": "build123d.BasePartObject.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.BasePartObject.dprism",
                    "signature": "build123d.BasePartObject.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.BasePartObject.edge",
                    "signature": "build123d.BasePartObject.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.BasePartObject.edges",
                    "signature": "build123d.BasePartObject.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.BasePartObject.export_brep",
                    "signature": "build123d.BasePartObject.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.export_step",
                    "signature": "build123d.BasePartObject.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.BasePartObject.export_stl",
                    "signature": "build123d.BasePartObject.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.BasePartObject.extrude",
                    "signature": "build123d.BasePartObject.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.BasePartObject.face",
                    "signature": "build123d.BasePartObject.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.BasePartObject.faces",
                    "signature": "build123d.BasePartObject.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.BasePartObject.faces_intersected_by_axis",
                    "signature": "build123d.BasePartObject.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.BasePartObject.fillet",
                    "signature": "build123d.BasePartObject.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.BasePartObject.find_intersection",
                    "signature": "build123d.BasePartObject.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.BasePartObject.find_intersection_points",
                    "signature": "build123d.BasePartObject.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.BasePartObject.first_level_shapes",
                    "signature": "build123d.BasePartObject.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.BasePartObject.fix",
                    "signature": "build123d.BasePartObject.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.BasePartObject.fuse",
                    "signature": "build123d.BasePartObject.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.get_type",
                    "signature": "build123d.BasePartObject.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.BasePartObject.hash_code",
                    "signature": "build123d.BasePartObject.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.hollow",
                    "signature": "build123d.BasePartObject.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.BasePartObject.intersect",
                    "signature": "build123d.BasePartObject.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.is_equal",
                    "signature": "build123d.BasePartObject.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.is_inside",
                    "signature": "build123d.BasePartObject.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.BasePartObject.is_null",
                    "signature": "build123d.BasePartObject.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.is_same",
                    "signature": "build123d.BasePartObject.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.is_valid",
                    "signature": "build123d.BasePartObject.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.iter_path_reverse",
                    "signature": "build123d.BasePartObject.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.BasePartObject.locate",
                    "signature": "build123d.BasePartObject.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.located",
                    "signature": "build123d.BasePartObject.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.BasePartObject.make_compound",
                    "signature": "build123d.BasePartObject.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.make_text",
                    "signature": "build123d.BasePartObject.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.BasePartObject.make_triad",
                    "signature": "build123d.BasePartObject.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.BasePartObject.max_fillet",
                    "signature": "build123d.BasePartObject.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.BasePartObject.mesh",
                    "signature": "build123d.BasePartObject.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.mirror",
                    "signature": "build123d.BasePartObject.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.BasePartObject.move",
                    "signature": "build123d.BasePartObject.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.moved",
                    "signature": "build123d.BasePartObject.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.BasePartObject.offset_3d",
                    "signature": "build123d.BasePartObject.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.BasePartObject.project_faces",
                    "signature": "build123d.BasePartObject.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.BasePartObject.project_to_viewport",
                    "signature": "build123d.BasePartObject.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.BasePartObject.relocate",
                    "signature": "build123d.BasePartObject.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.BasePartObject.rotate",
                    "signature": "build123d.BasePartObject.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.BasePartObject.scale",
                    "signature": "build123d.BasePartObject.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.shape_type",
                    "signature": "build123d.BasePartObject.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.BasePartObject.shell",
                    "signature": "build123d.BasePartObject.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.BasePartObject.shells",
                    "signature": "build123d.BasePartObject.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.BasePartObject.show_topology",
                    "signature": "build123d.BasePartObject.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.BasePartObject.solid",
                    "signature": "build123d.BasePartObject.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.BasePartObject.solids",
                    "signature": "build123d.BasePartObject.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.BasePartObject.split",
                    "signature": "build123d.BasePartObject.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.BasePartObject.split_by_perimeter",
                    "signature": "build123d.BasePartObject.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.BasePartObject.tessellate",
                    "signature": "build123d.BasePartObject.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.BasePartObject.to_arcs",
                    "signature": "build123d.BasePartObject.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.BasePartObject.to_splines",
                    "signature": "build123d.BasePartObject.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.BasePartObject.to_vtk_poly_data",
                    "signature": "build123d.BasePartObject.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.BasePartObject.transform_geometry",
                    "signature": "build123d.BasePartObject.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.BasePartObject.transform_shape",
                    "signature": "build123d.BasePartObject.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.BasePartObject.transformed",
                    "signature": "build123d.BasePartObject.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.BasePartObject.translate",
                    "signature": "build123d.BasePartObject.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.BasePartObject.unwrap",
                    "signature": "build123d.BasePartObject.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.BasePartObject.vertex",
                    "signature": "build123d.BasePartObject.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.BasePartObject.vertices",
                    "signature": "build123d.BasePartObject.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.BasePartObject.wire",
                    "signature": "build123d.BasePartObject.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.BasePartObject.wires",
                    "signature": "build123d.BasePartObject.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "BasePartObject\n\nBase class for all BuildPart objects & operations\n\nArgs:\n    solid (Solid): object to create\n    rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).\n    align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,\n        or max of object. Defaults to None.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.BaseSketchObject",
            "signature": "build123d.BaseSketchObject(obj: 'Union[Compound, Face]', rotation: 'float' = 0, align: 'Union[Align, tuple[Align, Align]]' = None, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.BaseSketchObject.bounding_box",
                    "signature": "build123d.BaseSketchObject.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.BaseSketchObject.cast",
                    "signature": "build123d.BaseSketchObject.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.BaseSketchObject.center",
                    "signature": "build123d.BaseSketchObject.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.BaseSketchObject.chamfer",
                    "signature": "build123d.BaseSketchObject.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.BaseSketchObject.clean",
                    "signature": "build123d.BaseSketchObject.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.BaseSketchObject.closest_points",
                    "signature": "build123d.BaseSketchObject.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.BaseSketchObject.combined_center",
                    "signature": "build123d.BaseSketchObject.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.BaseSketchObject.compound",
                    "signature": "build123d.BaseSketchObject.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.BaseSketchObject.compounds",
                    "signature": "build123d.BaseSketchObject.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.BaseSketchObject.compute_mass",
                    "signature": "build123d.BaseSketchObject.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.copy",
                    "signature": "build123d.BaseSketchObject.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.BaseSketchObject.copy_attributes_to",
                    "signature": "build123d.BaseSketchObject.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.BaseSketchObject.cut",
                    "signature": "build123d.BaseSketchObject.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.distance",
                    "signature": "build123d.BaseSketchObject.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.distance_to",
                    "signature": "build123d.BaseSketchObject.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.BaseSketchObject.distance_to_with_closest_points",
                    "signature": "build123d.BaseSketchObject.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.BaseSketchObject.distances",
                    "signature": "build123d.BaseSketchObject.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.do_children_intersect",
                    "signature": "build123d.BaseSketchObject.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.BaseSketchObject.dprism",
                    "signature": "build123d.BaseSketchObject.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.BaseSketchObject.edge",
                    "signature": "build123d.BaseSketchObject.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.BaseSketchObject.edges",
                    "signature": "build123d.BaseSketchObject.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.BaseSketchObject.export_brep",
                    "signature": "build123d.BaseSketchObject.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.export_step",
                    "signature": "build123d.BaseSketchObject.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.BaseSketchObject.export_stl",
                    "signature": "build123d.BaseSketchObject.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.BaseSketchObject.extrude",
                    "signature": "build123d.BaseSketchObject.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.BaseSketchObject.face",
                    "signature": "build123d.BaseSketchObject.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.BaseSketchObject.faces",
                    "signature": "build123d.BaseSketchObject.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.BaseSketchObject.faces_intersected_by_axis",
                    "signature": "build123d.BaseSketchObject.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.BaseSketchObject.fillet",
                    "signature": "build123d.BaseSketchObject.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.BaseSketchObject.find_intersection",
                    "signature": "build123d.BaseSketchObject.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.BaseSketchObject.find_intersection_points",
                    "signature": "build123d.BaseSketchObject.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.BaseSketchObject.first_level_shapes",
                    "signature": "build123d.BaseSketchObject.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.BaseSketchObject.fix",
                    "signature": "build123d.BaseSketchObject.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.BaseSketchObject.fuse",
                    "signature": "build123d.BaseSketchObject.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.get_type",
                    "signature": "build123d.BaseSketchObject.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.BaseSketchObject.hash_code",
                    "signature": "build123d.BaseSketchObject.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.hollow",
                    "signature": "build123d.BaseSketchObject.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.BaseSketchObject.intersect",
                    "signature": "build123d.BaseSketchObject.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.is_equal",
                    "signature": "build123d.BaseSketchObject.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.is_inside",
                    "signature": "build123d.BaseSketchObject.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.BaseSketchObject.is_null",
                    "signature": "build123d.BaseSketchObject.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.is_same",
                    "signature": "build123d.BaseSketchObject.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.is_valid",
                    "signature": "build123d.BaseSketchObject.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.iter_path_reverse",
                    "signature": "build123d.BaseSketchObject.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.BaseSketchObject.locate",
                    "signature": "build123d.BaseSketchObject.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.located",
                    "signature": "build123d.BaseSketchObject.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.BaseSketchObject.make_compound",
                    "signature": "build123d.BaseSketchObject.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.make_text",
                    "signature": "build123d.BaseSketchObject.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.BaseSketchObject.make_triad",
                    "signature": "build123d.BaseSketchObject.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.BaseSketchObject.max_fillet",
                    "signature": "build123d.BaseSketchObject.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.BaseSketchObject.mesh",
                    "signature": "build123d.BaseSketchObject.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.mirror",
                    "signature": "build123d.BaseSketchObject.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.BaseSketchObject.move",
                    "signature": "build123d.BaseSketchObject.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.moved",
                    "signature": "build123d.BaseSketchObject.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.BaseSketchObject.offset_3d",
                    "signature": "build123d.BaseSketchObject.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.BaseSketchObject.project_faces",
                    "signature": "build123d.BaseSketchObject.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.BaseSketchObject.project_to_viewport",
                    "signature": "build123d.BaseSketchObject.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.BaseSketchObject.relocate",
                    "signature": "build123d.BaseSketchObject.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.BaseSketchObject.rotate",
                    "signature": "build123d.BaseSketchObject.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.BaseSketchObject.scale",
                    "signature": "build123d.BaseSketchObject.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.shape_type",
                    "signature": "build123d.BaseSketchObject.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.BaseSketchObject.shell",
                    "signature": "build123d.BaseSketchObject.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.BaseSketchObject.shells",
                    "signature": "build123d.BaseSketchObject.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.BaseSketchObject.show_topology",
                    "signature": "build123d.BaseSketchObject.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.BaseSketchObject.solid",
                    "signature": "build123d.BaseSketchObject.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.BaseSketchObject.solids",
                    "signature": "build123d.BaseSketchObject.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.BaseSketchObject.split",
                    "signature": "build123d.BaseSketchObject.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.BaseSketchObject.split_by_perimeter",
                    "signature": "build123d.BaseSketchObject.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.BaseSketchObject.tessellate",
                    "signature": "build123d.BaseSketchObject.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.BaseSketchObject.to_arcs",
                    "signature": "build123d.BaseSketchObject.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.BaseSketchObject.to_splines",
                    "signature": "build123d.BaseSketchObject.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.BaseSketchObject.to_vtk_poly_data",
                    "signature": "build123d.BaseSketchObject.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.BaseSketchObject.transform_geometry",
                    "signature": "build123d.BaseSketchObject.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.BaseSketchObject.transform_shape",
                    "signature": "build123d.BaseSketchObject.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.BaseSketchObject.transformed",
                    "signature": "build123d.BaseSketchObject.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.BaseSketchObject.translate",
                    "signature": "build123d.BaseSketchObject.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.BaseSketchObject.unwrap",
                    "signature": "build123d.BaseSketchObject.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.BaseSketchObject.vertex",
                    "signature": "build123d.BaseSketchObject.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.BaseSketchObject.vertices",
                    "signature": "build123d.BaseSketchObject.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.BaseSketchObject.wire",
                    "signature": "build123d.BaseSketchObject.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.BaseSketchObject.wires",
                    "signature": "build123d.BaseSketchObject.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "BaseSketchObject\n\nBase class for all BuildSketch objects\n\nArgs:\n    face (Face): face to create\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to None.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Bezier",
            "signature": "build123d.Bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Bezier.bounding_box",
                    "signature": "build123d.Bezier.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Bezier.cast",
                    "signature": "build123d.Bezier.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Bezier.center",
                    "signature": "build123d.Bezier.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Bezier.clean",
                    "signature": "build123d.Bezier.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Bezier.close",
                    "signature": "build123d.Bezier.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.Bezier.closest_points",
                    "signature": "build123d.Bezier.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Bezier.combined_center",
                    "signature": "build123d.Bezier.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Bezier.common_plane",
                    "signature": "build123d.Bezier.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.Bezier.compound",
                    "signature": "build123d.Bezier.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Bezier.compounds",
                    "signature": "build123d.Bezier.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Bezier.compute_mass",
                    "signature": "build123d.Bezier.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.copy",
                    "signature": "build123d.Bezier.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Bezier.copy_attributes_to",
                    "signature": "build123d.Bezier.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Bezier.cut",
                    "signature": "build123d.Bezier.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.distance",
                    "signature": "build123d.Bezier.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.distance_to",
                    "signature": "build123d.Bezier.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Bezier.distance_to_with_closest_points",
                    "signature": "build123d.Bezier.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Bezier.distances",
                    "signature": "build123d.Bezier.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.distribute_locations",
                    "signature": "build123d.Bezier.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.Bezier.edge",
                    "signature": "build123d.Bezier.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Bezier.edges",
                    "signature": "build123d.Bezier.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Bezier.end_point",
                    "signature": "build123d.Bezier.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Bezier.export_brep",
                    "signature": "build123d.Bezier.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.export_step",
                    "signature": "build123d.Bezier.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Bezier.export_stl",
                    "signature": "build123d.Bezier.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Bezier.extrude",
                    "signature": "build123d.Bezier.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Bezier.face",
                    "signature": "build123d.Bezier.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Bezier.faces",
                    "signature": "build123d.Bezier.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Bezier.faces_intersected_by_axis",
                    "signature": "build123d.Bezier.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Bezier.find_intersection",
                    "signature": "build123d.Bezier.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Bezier.find_intersection_points",
                    "signature": "build123d.Bezier.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.Bezier.find_tangent",
                    "signature": "build123d.Bezier.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.Bezier.fix",
                    "signature": "build123d.Bezier.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Bezier.fuse",
                    "signature": "build123d.Bezier.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Bezier.hash_code",
                    "signature": "build123d.Bezier.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.intersect",
                    "signature": "build123d.Bezier.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Bezier.is_equal",
                    "signature": "build123d.Bezier.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.is_null",
                    "signature": "build123d.Bezier.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.is_same",
                    "signature": "build123d.Bezier.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.is_valid",
                    "signature": "build123d.Bezier.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.iter_path_reverse",
                    "signature": "build123d.Bezier.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Bezier.locate",
                    "signature": "build123d.Bezier.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.located",
                    "signature": "build123d.Bezier.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Bezier.location_at",
                    "signature": "build123d.Bezier.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.Bezier.locations",
                    "signature": "build123d.Bezier.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.Bezier.make_bezier",
                    "signature": "build123d.Bezier.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.Bezier.make_circle",
                    "signature": "build123d.Bezier.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.Bezier.make_ellipse",
                    "signature": "build123d.Bezier.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.Bezier.make_helix",
                    "signature": "build123d.Bezier.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.Bezier.make_line",
                    "signature": "build123d.Bezier.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.Bezier.make_mid_way",
                    "signature": "build123d.Bezier.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.Bezier.make_spline",
                    "signature": "build123d.Bezier.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.Bezier.make_spline_approx",
                    "signature": "build123d.Bezier.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.Bezier.make_tangent_arc",
                    "signature": "build123d.Bezier.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.Bezier.make_three_point_arc",
                    "signature": "build123d.Bezier.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.Bezier.mesh",
                    "signature": "build123d.Bezier.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.mirror",
                    "signature": "build123d.Bezier.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Bezier.move",
                    "signature": "build123d.Bezier.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.moved",
                    "signature": "build123d.Bezier.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Bezier.normal",
                    "signature": "build123d.Bezier.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.offset_2d",
                    "signature": "build123d.Bezier.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.Bezier.param_at",
                    "signature": "build123d.Bezier.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.Bezier.param_at_point",
                    "signature": "build123d.Bezier.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.Bezier.perpendicular_line",
                    "signature": "build123d.Bezier.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.Bezier.position_at",
                    "signature": "build123d.Bezier.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.Bezier.positions",
                    "signature": "build123d.Bezier.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.Bezier.project",
                    "signature": "build123d.Bezier.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.project_faces",
                    "signature": "build123d.Bezier.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Bezier.project_to_shape",
                    "signature": "build123d.Bezier.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.Bezier.project_to_viewport",
                    "signature": "build123d.Bezier.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Bezier.relocate",
                    "signature": "build123d.Bezier.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Bezier.reversed",
                    "signature": "build123d.Bezier.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.Bezier.rotate",
                    "signature": "build123d.Bezier.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Bezier.scale",
                    "signature": "build123d.Bezier.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.shape_type",
                    "signature": "build123d.Bezier.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Bezier.shell",
                    "signature": "build123d.Bezier.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Bezier.shells",
                    "signature": "build123d.Bezier.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Bezier.show_topology",
                    "signature": "build123d.Bezier.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Bezier.solid",
                    "signature": "build123d.Bezier.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Bezier.solids",
                    "signature": "build123d.Bezier.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Bezier.split",
                    "signature": "build123d.Bezier.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Bezier.split_by_perimeter",
                    "signature": "build123d.Bezier.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Bezier.start_point",
                    "signature": "build123d.Bezier.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Bezier.tangent_angle_at",
                    "signature": "build123d.Bezier.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.Bezier.tangent_at",
                    "signature": "build123d.Bezier.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.Bezier.tessellate",
                    "signature": "build123d.Bezier.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Bezier.to_arcs",
                    "signature": "build123d.Bezier.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Bezier.to_axis",
                    "signature": "build123d.Bezier.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.Bezier.to_splines",
                    "signature": "build123d.Bezier.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Bezier.to_vtk_poly_data",
                    "signature": "build123d.Bezier.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Bezier.to_wire",
                    "signature": "build123d.Bezier.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.Bezier.transform_geometry",
                    "signature": "build123d.Bezier.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Bezier.transform_shape",
                    "signature": "build123d.Bezier.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Bezier.transformed",
                    "signature": "build123d.Bezier.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Bezier.translate",
                    "signature": "build123d.Bezier.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Bezier.trim",
                    "signature": "build123d.Bezier.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.Bezier.trim_to_length",
                    "signature": "build123d.Bezier.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.Bezier.vertex",
                    "signature": "build123d.Bezier.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Bezier.vertices",
                    "signature": "build123d.Bezier.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Bezier.wire",
                    "signature": "build123d.Bezier.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Bezier.wires",
                    "signature": "build123d.Bezier.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Bezier Curve\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.BoundBox",
            "signature": "build123d.BoundBox(bounding_box: 'Bnd_Box') -> 'None'",
            "methods": [
                {
                    "name": "build123d.BoundBox.add",
                    "signature": "build123d.BoundBox.add(self, obj: 'Union[tuple[float, float, float], Vector, BoundBox]', tol: 'float' = None) -> 'BoundBox'",
                    "docstring": "Returns a modified (expanded) bounding box\n\nobj can be one of several things:\n    1. a 3-tuple corresponding to x,y, and z amounts to add\n    2. a vector, containing the x,y,z values to add\n    3. another bounding box, where a new box will be created that\n       encloses both.\n\nThis bounding box is not changed.\n\nArgs:\n  obj: Union[tuple[float:\n  float:\n  float]:\n  Vector:\n  BoundBox]:\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.BoundBox.center",
                    "signature": "build123d.BoundBox.center(self) -> 'Vector'",
                    "docstring": "Return center of the bounding box"
                },
                {
                    "name": "build123d.BoundBox.find_outside_box_2d",
                    "signature": "build123d.BoundBox.find_outside_box_2d(bb1: 'BoundBox', bb2: 'BoundBox') -> 'Optional[BoundBox]'",
                    "docstring": "Compares bounding boxes\n\nCompares bounding boxes. Returns none if neither is inside the other.\nReturns the outer one if either is outside the other.\n\nBoundBox.is_inside works in 3d, but this is a 2d bounding box, so it\ndoesn't work correctly plus, there was all kinds of rounding error in\nthe built-in implementation i do not understand.\n\nArgs:\n  bb1: BoundBox:\n  bb2: BoundBox:\n\nReturns:"
                },
                {
                    "name": "build123d.BoundBox.is_inside",
                    "signature": "build123d.BoundBox.is_inside(self, second_box: 'BoundBox') -> 'bool'",
                    "docstring": "Is the provided bounding box inside this one?\n\nArgs:\n  b2: BoundBox:\n\nReturns:"
                },
                {
                    "name": "build123d.BoundBox.to_align_offset",
                    "signature": "build123d.BoundBox.to_align_offset(self, align: 'Tuple[float, float]') -> 'Tuple[float, float]'",
                    "docstring": "Amount to move object to achieve the desired alignment"
                }
            ],
            "variables": [
                "diagonal"
            ],
            "docstring": "A BoundingBox for a Shape"
        },
        {
            "name": "build123d.Box",
            "signature": "build123d.Box(length: 'float', width: 'float', height: 'float', rotation: 'RotationLike' = (0, 0, 0), align: 'Union[Align, tuple[Align, Align, Align]]' = (<Align.CENTER>, <Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Box.bounding_box",
                    "signature": "build123d.Box.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Box.cast",
                    "signature": "build123d.Box.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Box.center",
                    "signature": "build123d.Box.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Box.chamfer",
                    "signature": "build123d.Box.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Box.clean",
                    "signature": "build123d.Box.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Box.closest_points",
                    "signature": "build123d.Box.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Box.combined_center",
                    "signature": "build123d.Box.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Box.compound",
                    "signature": "build123d.Box.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Box.compounds",
                    "signature": "build123d.Box.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Box.compute_mass",
                    "signature": "build123d.Box.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.copy",
                    "signature": "build123d.Box.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Box.copy_attributes_to",
                    "signature": "build123d.Box.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Box.cut",
                    "signature": "build123d.Box.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.distance",
                    "signature": "build123d.Box.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.distance_to",
                    "signature": "build123d.Box.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Box.distance_to_with_closest_points",
                    "signature": "build123d.Box.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Box.distances",
                    "signature": "build123d.Box.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.do_children_intersect",
                    "signature": "build123d.Box.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Box.dprism",
                    "signature": "build123d.Box.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Box.edge",
                    "signature": "build123d.Box.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Box.edges",
                    "signature": "build123d.Box.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Box.export_brep",
                    "signature": "build123d.Box.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.export_step",
                    "signature": "build123d.Box.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Box.export_stl",
                    "signature": "build123d.Box.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Box.extrude",
                    "signature": "build123d.Box.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Box.face",
                    "signature": "build123d.Box.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Box.faces",
                    "signature": "build123d.Box.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Box.faces_intersected_by_axis",
                    "signature": "build123d.Box.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Box.fillet",
                    "signature": "build123d.Box.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Box.find_intersection",
                    "signature": "build123d.Box.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Box.find_intersection_points",
                    "signature": "build123d.Box.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Box.first_level_shapes",
                    "signature": "build123d.Box.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Box.fix",
                    "signature": "build123d.Box.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Box.fuse",
                    "signature": "build123d.Box.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Box.get_type",
                    "signature": "build123d.Box.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Box.hash_code",
                    "signature": "build123d.Box.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.hollow",
                    "signature": "build123d.Box.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Box.intersect",
                    "signature": "build123d.Box.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.is_equal",
                    "signature": "build123d.Box.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.is_inside",
                    "signature": "build123d.Box.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Box.is_null",
                    "signature": "build123d.Box.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.is_same",
                    "signature": "build123d.Box.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.is_valid",
                    "signature": "build123d.Box.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.iter_path_reverse",
                    "signature": "build123d.Box.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Box.locate",
                    "signature": "build123d.Box.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.located",
                    "signature": "build123d.Box.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Box.make_compound",
                    "signature": "build123d.Box.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Box.make_text",
                    "signature": "build123d.Box.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Box.make_triad",
                    "signature": "build123d.Box.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Box.max_fillet",
                    "signature": "build123d.Box.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Box.mesh",
                    "signature": "build123d.Box.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Box.mirror",
                    "signature": "build123d.Box.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Box.move",
                    "signature": "build123d.Box.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.moved",
                    "signature": "build123d.Box.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Box.offset_3d",
                    "signature": "build123d.Box.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Box.project_faces",
                    "signature": "build123d.Box.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Box.project_to_viewport",
                    "signature": "build123d.Box.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Box.relocate",
                    "signature": "build123d.Box.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Box.rotate",
                    "signature": "build123d.Box.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Box.scale",
                    "signature": "build123d.Box.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.shape_type",
                    "signature": "build123d.Box.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Box.shell",
                    "signature": "build123d.Box.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Box.shells",
                    "signature": "build123d.Box.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Box.show_topology",
                    "signature": "build123d.Box.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Box.solid",
                    "signature": "build123d.Box.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Box.solids",
                    "signature": "build123d.Box.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Box.split",
                    "signature": "build123d.Box.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Box.split_by_perimeter",
                    "signature": "build123d.Box.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Box.tessellate",
                    "signature": "build123d.Box.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Box.to_arcs",
                    "signature": "build123d.Box.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Box.to_splines",
                    "signature": "build123d.Box.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Box.to_vtk_poly_data",
                    "signature": "build123d.Box.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Box.transform_geometry",
                    "signature": "build123d.Box.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Box.transform_shape",
                    "signature": "build123d.Box.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Box.transformed",
                    "signature": "build123d.Box.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Box.translate",
                    "signature": "build123d.Box.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Box.unwrap",
                    "signature": "build123d.Box.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Box.vertex",
                    "signature": "build123d.Box.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Box.vertices",
                    "signature": "build123d.Box.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Box.wire",
                    "signature": "build123d.Box.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Box.wires",
                    "signature": "build123d.Box.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Part Object: Box\n\nCreate a box(es) and combine with part.\n\nArgs:\n    length (float): box size\n    width (float): box size\n    height (float): box size\n    rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).\n    align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,\n        or max of object. Defaults to (Align.CENTER, Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combine mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.BuildLine",
            "signature": "build123d.BuildLine(workplane: 'Union[Face, Plane, Location]' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.BuildLine.edge",
                    "signature": "build123d.BuildLine.edge(self, select: 'Select' = <Select.ALL>) -> 'Edge'",
                    "docstring": "Return Edge\n\nReturn an edge.\n\nArgs:\n    select (Select, optional): Edge selector. Defaults to Select.ALL.\n\nReturns:\n    Edge: Edge extracted"
                },
                {
                    "name": "build123d.BuildLine.edges",
                    "signature": "build123d.BuildLine.edges(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Edge]'",
                    "docstring": "Return Edges\n\nReturn either all or the edges created during the last operation.\n\nArgs:\n    select (Select, optional): Edge selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Edge]: Edges extracted"
                },
                {
                    "name": "build123d.BuildLine.face",
                    "signature": "build123d.BuildLine.face(self, *args)",
                    "docstring": "face() not implemented"
                },
                {
                    "name": "build123d.BuildLine.faces",
                    "signature": "build123d.BuildLine.faces(self, *args)",
                    "docstring": "faces() not implemented"
                },
                {
                    "name": "build123d.BuildLine.solid",
                    "signature": "build123d.BuildLine.solid(self, *args)",
                    "docstring": "solid() not implemented"
                },
                {
                    "name": "build123d.BuildLine.solids",
                    "signature": "build123d.BuildLine.solids(self, *args)",
                    "docstring": "solids() not implemented"
                },
                {
                    "name": "build123d.BuildLine.validate_inputs",
                    "signature": "build123d.BuildLine.validate_inputs(self, validating_class, objects: 'Union[Shape, Iterable[Shape]]' = None)",
                    "docstring": "Validate that objects/operations and parameters apply"
                },
                {
                    "name": "build123d.BuildLine.vertex",
                    "signature": "build123d.BuildLine.vertex(self, select: 'Select' = <Select.ALL>) -> 'Vertex'",
                    "docstring": "Return Vertex\n\nReturn a vertex.\n\nArgs:\n    select (Select, optional): Vertex selector. Defaults to Select.ALL.\n\nReturns:\n    Vertex: Vertex extracted"
                },
                {
                    "name": "build123d.BuildLine.vertices",
                    "signature": "build123d.BuildLine.vertices(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Vertex]'",
                    "docstring": "Return Vertices\n\nReturn either all or the vertices created during the last operation.\n\nArgs:\n    select (Select, optional): Vertex selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Vertex]: Vertices extracted"
                },
                {
                    "name": "build123d.BuildLine.wire",
                    "signature": "build123d.BuildLine.wire(self, select: 'Select' = <Select.ALL>) -> 'Wire'",
                    "docstring": "Return Wire\n\nReturn a wire.\n\nArgs:\n    select (Select, optional): Wire selector. Defaults to Select.ALL.\n\nReturns:\n    Wire: Wire extracted"
                },
                {
                    "name": "build123d.BuildLine.wires",
                    "signature": "build123d.BuildLine.wires(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Wire]'",
                    "docstring": "Return Wires\n\nReturn either all or the wires created during the last operation.\n\nArgs:\n    select (Select, optional): Wire selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Wire]: Wires extracted"
                }
            ],
            "variables": [
                "max_dimension",
                "new_edges"
            ],
            "docstring": "BuildLine\n\nThe BuildLine class is a subclass of Builder for building lines (objects\nwith length but not area or volume). It has an _obj property that returns\nthe current line being built. The class overrides the faces and solids methods\nof Builder since they don't apply to lines.\n\nBuildLine only works with a single workplane which is used to convert tuples\nas inputs to global coordinates. For example:\n\n.. code::\n\n    with BuildLine(Plane.YZ) as radius_arc:\n        RadiusArc((1, 2), (2, 1), 1)\n\ncreates an arc from global points (0, 1, 2) to (0, 2, 1). Note that points\nentered as Vector(x, y, z) are considered global and are not localized.\n\nThe workplane is also used to define planes parallel to the workplane that\narcs are created on.\n\nArgs:\n    workplane (Union[Face, Plane, Location], optional): plane used when local\n        coordinates are used and when creating arcs. Defaults to Plane.XY.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.BuildPart",
            "signature": "build123d.BuildPart(*workplanes: 'Union[Face, Plane, Location]', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.BuildPart.edge",
                    "signature": "build123d.BuildPart.edge(self, select: 'Select' = <Select.ALL>) -> 'Edge'",
                    "docstring": "Return Edge\n\nReturn an edge.\n\nArgs:\n    select (Select, optional): Edge selector. Defaults to Select.ALL.\n\nReturns:\n    Edge: Edge extracted"
                },
                {
                    "name": "build123d.BuildPart.edges",
                    "signature": "build123d.BuildPart.edges(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Edge]'",
                    "docstring": "Return Edges\n\nReturn either all or the edges created during the last operation.\n\nArgs:\n    select (Select, optional): Edge selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Edge]: Edges extracted"
                },
                {
                    "name": "build123d.BuildPart.face",
                    "signature": "build123d.BuildPart.face(self, select: 'Select' = <Select.ALL>) -> 'Face'",
                    "docstring": "Return Face\n\nReturn a face.\n\nArgs:\n    select (Select, optional): Face selector. Defaults to Select.ALL.\n\nReturns:\n    Face: Face extracted"
                },
                {
                    "name": "build123d.BuildPart.faces",
                    "signature": "build123d.BuildPart.faces(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Face]'",
                    "docstring": "Return Faces\n\nReturn either all or the faces created during the last operation.\n\nArgs:\n    select (Select, optional): Face selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Face]: Faces extracted"
                },
                {
                    "name": "build123d.BuildPart.solid",
                    "signature": "build123d.BuildPart.solid(self, select: 'Select' = <Select.ALL>) -> 'Solid'",
                    "docstring": "Return Solid\n\nReturn a solid.\n\nArgs:\n    select (Select, optional): Solid selector. Defaults to Select.ALL.\n\nReturns:\n    Solid: Solid extracted"
                },
                {
                    "name": "build123d.BuildPart.solids",
                    "signature": "build123d.BuildPart.solids(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Solid]'",
                    "docstring": "Return Solids\n\nReturn either all or the solids created during the last operation.\n\nArgs:\n    select (Select, optional): Solid selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Solid]: Solids extracted"
                },
                {
                    "name": "build123d.BuildPart.validate_inputs",
                    "signature": "build123d.BuildPart.validate_inputs(self, validating_class, objects: 'Union[Shape, Iterable[Shape]]' = None)",
                    "docstring": "Validate that objects/operations and parameters apply"
                },
                {
                    "name": "build123d.BuildPart.vertex",
                    "signature": "build123d.BuildPart.vertex(self, select: 'Select' = <Select.ALL>) -> 'Vertex'",
                    "docstring": "Return Vertex\n\nReturn a vertex.\n\nArgs:\n    select (Select, optional): Vertex selector. Defaults to Select.ALL.\n\nReturns:\n    Vertex: Vertex extracted"
                },
                {
                    "name": "build123d.BuildPart.vertices",
                    "signature": "build123d.BuildPart.vertices(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Vertex]'",
                    "docstring": "Return Vertices\n\nReturn either all or the vertices created during the last operation.\n\nArgs:\n    select (Select, optional): Vertex selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Vertex]: Vertices extracted"
                },
                {
                    "name": "build123d.BuildPart.wire",
                    "signature": "build123d.BuildPart.wire(self, select: 'Select' = <Select.ALL>) -> 'Wire'",
                    "docstring": "Return Wire\n\nReturn a wire.\n\nArgs:\n    select (Select, optional): Wire selector. Defaults to Select.ALL.\n\nReturns:\n    Wire: Wire extracted"
                },
                {
                    "name": "build123d.BuildPart.wires",
                    "signature": "build123d.BuildPart.wires(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Wire]'",
                    "docstring": "Return Wires\n\nReturn either all or the wires created during the last operation.\n\nArgs:\n    select (Select, optional): Wire selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Wire]: Wires extracted"
                }
            ],
            "variables": [
                "location",
                "max_dimension",
                "new_edges",
                "pending_edges_as_wire"
            ],
            "docstring": "BuildPart\n\nThe BuildPart class is another subclass of Builder for building parts\n(objects with the property of volume) from sketches or 3D objects.\nIt has an _obj property that returns the current part being built, and\nseveral pending lists for storing faces, edges, and planes that will be\nintegrated into the final part later. The class overrides the _add_to_pending\nmethod of Builder.\n\nArgs:\n    workplanes (Plane, optional): initial plane to work on. Defaults to Plane.XY.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.BuildSketch",
            "signature": "build123d.BuildSketch(*workplanes: 'Union[Face, Plane, Location]', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.BuildSketch.consolidate_edges",
                    "signature": "build123d.BuildSketch.consolidate_edges(self) -> 'Union[Wire, list[Wire]]'",
                    "docstring": "Unify pending edges into one or more Wires"
                },
                {
                    "name": "build123d.BuildSketch.edge",
                    "signature": "build123d.BuildSketch.edge(self, select: 'Select' = <Select.ALL>) -> 'Edge'",
                    "docstring": "Return Edge\n\nReturn an edge.\n\nArgs:\n    select (Select, optional): Edge selector. Defaults to Select.ALL.\n\nReturns:\n    Edge: Edge extracted"
                },
                {
                    "name": "build123d.BuildSketch.edges",
                    "signature": "build123d.BuildSketch.edges(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Edge]'",
                    "docstring": "Return Edges\n\nReturn either all or the edges created during the last operation.\n\nArgs:\n    select (Select, optional): Edge selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Edge]: Edges extracted"
                },
                {
                    "name": "build123d.BuildSketch.face",
                    "signature": "build123d.BuildSketch.face(self, select: 'Select' = <Select.ALL>) -> 'Face'",
                    "docstring": "Return Face\n\nReturn a face.\n\nArgs:\n    select (Select, optional): Face selector. Defaults to Select.ALL.\n\nReturns:\n    Face: Face extracted"
                },
                {
                    "name": "build123d.BuildSketch.faces",
                    "signature": "build123d.BuildSketch.faces(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Face]'",
                    "docstring": "Return Faces\n\nReturn either all or the faces created during the last operation.\n\nArgs:\n    select (Select, optional): Face selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Face]: Faces extracted"
                },
                {
                    "name": "build123d.BuildSketch.solid",
                    "signature": "build123d.BuildSketch.solid(self, *args)",
                    "docstring": "solid() not implemented"
                },
                {
                    "name": "build123d.BuildSketch.solids",
                    "signature": "build123d.BuildSketch.solids(self, *args)",
                    "docstring": "solids() not implemented"
                },
                {
                    "name": "build123d.BuildSketch.validate_inputs",
                    "signature": "build123d.BuildSketch.validate_inputs(self, validating_class, objects: 'Union[Shape, Iterable[Shape]]' = None)",
                    "docstring": "Validate that objects/operations and parameters apply"
                },
                {
                    "name": "build123d.BuildSketch.vertex",
                    "signature": "build123d.BuildSketch.vertex(self, select: 'Select' = <Select.ALL>) -> 'Vertex'",
                    "docstring": "Return Vertex\n\nReturn a vertex.\n\nArgs:\n    select (Select, optional): Vertex selector. Defaults to Select.ALL.\n\nReturns:\n    Vertex: Vertex extracted"
                },
                {
                    "name": "build123d.BuildSketch.vertices",
                    "signature": "build123d.BuildSketch.vertices(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Vertex]'",
                    "docstring": "Return Vertices\n\nReturn either all or the vertices created during the last operation.\n\nArgs:\n    select (Select, optional): Vertex selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Vertex]: Vertices extracted"
                },
                {
                    "name": "build123d.BuildSketch.wire",
                    "signature": "build123d.BuildSketch.wire(self, select: 'Select' = <Select.ALL>) -> 'Wire'",
                    "docstring": "Return Wire\n\nReturn a wire.\n\nArgs:\n    select (Select, optional): Wire selector. Defaults to Select.ALL.\n\nReturns:\n    Wire: Wire extracted"
                },
                {
                    "name": "build123d.BuildSketch.wires",
                    "signature": "build123d.BuildSketch.wires(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Wire]'",
                    "docstring": "Return Wires\n\nReturn either all or the wires created during the last operation.\n\nArgs:\n    select (Select, optional): Wire selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Wire]: Wires extracted"
                }
            ],
            "variables": [
                "max_dimension",
                "new_edges",
                "sketch"
            ],
            "docstring": "BuildSketch\n\nThe BuildSketch class is a subclass of Builder for building planar 2D\nsketches (objects with area but not volume) from faces or lines.\nIt has an _obj property that returns the current sketch being built.\nThe sketch property consists of the sketch(es) applied to the input\nworkplanes while the sketch_local attribute is the sketch constructed\non Plane.XY. The class overrides the solids method of Builder since\nthey don't apply to lines.\n\nNote that all sketch construction is done within sketch_local on Plane.XY.\nWhen objects are added to the sketch they must be coplanar to Plane.XY,\nusually handled automatically but may need user input for Edges and Wires\nsince their construction plane isn't alway able to be determined.\n\nArgs:\n    workplanes (Union[Face, Plane, Location], optional): objects converted to\n        plane(s) to place the sketch on. Defaults to Plane.XY.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Builder",
            "signature": "build123d.Builder(*workplanes: 'Union[Face, Plane, Location]', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Builder.edge",
                    "signature": "build123d.Builder.edge(self, select: 'Select' = <Select.ALL>) -> 'Edge'",
                    "docstring": "Return Edge\n\nReturn an edge.\n\nArgs:\n    select (Select, optional): Edge selector. Defaults to Select.ALL.\n\nReturns:\n    Edge: Edge extracted"
                },
                {
                    "name": "build123d.Builder.edges",
                    "signature": "build123d.Builder.edges(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Edge]'",
                    "docstring": "Return Edges\n\nReturn either all or the edges created during the last operation.\n\nArgs:\n    select (Select, optional): Edge selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Edge]: Edges extracted"
                },
                {
                    "name": "build123d.Builder.face",
                    "signature": "build123d.Builder.face(self, select: 'Select' = <Select.ALL>) -> 'Face'",
                    "docstring": "Return Face\n\nReturn a face.\n\nArgs:\n    select (Select, optional): Face selector. Defaults to Select.ALL.\n\nReturns:\n    Face: Face extracted"
                },
                {
                    "name": "build123d.Builder.faces",
                    "signature": "build123d.Builder.faces(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Face]'",
                    "docstring": "Return Faces\n\nReturn either all or the faces created during the last operation.\n\nArgs:\n    select (Select, optional): Face selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Face]: Faces extracted"
                },
                {
                    "name": "build123d.Builder.solid",
                    "signature": "build123d.Builder.solid(self, select: 'Select' = <Select.ALL>) -> 'Solid'",
                    "docstring": "Return Solid\n\nReturn a solid.\n\nArgs:\n    select (Select, optional): Solid selector. Defaults to Select.ALL.\n\nReturns:\n    Solid: Solid extracted"
                },
                {
                    "name": "build123d.Builder.solids",
                    "signature": "build123d.Builder.solids(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Solid]'",
                    "docstring": "Return Solids\n\nReturn either all or the solids created during the last operation.\n\nArgs:\n    select (Select, optional): Solid selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Solid]: Solids extracted"
                },
                {
                    "name": "build123d.Builder.validate_inputs",
                    "signature": "build123d.Builder.validate_inputs(self, validating_class, objects: 'Union[Shape, Iterable[Shape]]' = None)",
                    "docstring": "Validate that objects/operations and parameters apply"
                },
                {
                    "name": "build123d.Builder.vertex",
                    "signature": "build123d.Builder.vertex(self, select: 'Select' = <Select.ALL>) -> 'Vertex'",
                    "docstring": "Return Vertex\n\nReturn a vertex.\n\nArgs:\n    select (Select, optional): Vertex selector. Defaults to Select.ALL.\n\nReturns:\n    Vertex: Vertex extracted"
                },
                {
                    "name": "build123d.Builder.vertices",
                    "signature": "build123d.Builder.vertices(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Vertex]'",
                    "docstring": "Return Vertices\n\nReturn either all or the vertices created during the last operation.\n\nArgs:\n    select (Select, optional): Vertex selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Vertex]: Vertices extracted"
                },
                {
                    "name": "build123d.Builder.wire",
                    "signature": "build123d.Builder.wire(self, select: 'Select' = <Select.ALL>) -> 'Wire'",
                    "docstring": "Return Wire\n\nReturn a wire.\n\nArgs:\n    select (Select, optional): Wire selector. Defaults to Select.ALL.\n\nReturns:\n    Wire: Wire extracted"
                },
                {
                    "name": "build123d.Builder.wires",
                    "signature": "build123d.Builder.wires(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Wire]'",
                    "docstring": "Return Wires\n\nReturn either all or the wires created during the last operation.\n\nArgs:\n    select (Select, optional): Wire selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Wire]: Wires extracted"
                }
            ],
            "variables": [
                "max_dimension",
                "new_edges"
            ],
            "docstring": "Builder\n\nBase class for the build123d Builders.\n\nArgs:\n    workplanes: sequence of Union[Face, Plane, Location]: set plane(s) to work on\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nAttributes:\n    mode (Mode): builder's combination mode\n    workplanes (list[Plane]): active workplanes\n    builder_parent (Builder): build to pass objects to on exit"
        },
        {
            "name": "build123d.CenterArc",
            "signature": "build123d.CenterArc(center: 'VectorLike', radius: 'float', start_angle: 'float', arc_size: 'float', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.CenterArc.bounding_box",
                    "signature": "build123d.CenterArc.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.CenterArc.cast",
                    "signature": "build123d.CenterArc.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.CenterArc.center",
                    "signature": "build123d.CenterArc.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.CenterArc.clean",
                    "signature": "build123d.CenterArc.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.CenterArc.close",
                    "signature": "build123d.CenterArc.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.CenterArc.closest_points",
                    "signature": "build123d.CenterArc.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.CenterArc.combined_center",
                    "signature": "build123d.CenterArc.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.CenterArc.common_plane",
                    "signature": "build123d.CenterArc.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.CenterArc.compound",
                    "signature": "build123d.CenterArc.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.CenterArc.compounds",
                    "signature": "build123d.CenterArc.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.CenterArc.compute_mass",
                    "signature": "build123d.CenterArc.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.copy",
                    "signature": "build123d.CenterArc.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.CenterArc.copy_attributes_to",
                    "signature": "build123d.CenterArc.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.CenterArc.cut",
                    "signature": "build123d.CenterArc.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.distance",
                    "signature": "build123d.CenterArc.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.distance_to",
                    "signature": "build123d.CenterArc.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.CenterArc.distance_to_with_closest_points",
                    "signature": "build123d.CenterArc.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.CenterArc.distances",
                    "signature": "build123d.CenterArc.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.distribute_locations",
                    "signature": "build123d.CenterArc.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.CenterArc.edge",
                    "signature": "build123d.CenterArc.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.CenterArc.edges",
                    "signature": "build123d.CenterArc.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.CenterArc.end_point",
                    "signature": "build123d.CenterArc.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.CenterArc.export_brep",
                    "signature": "build123d.CenterArc.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.export_step",
                    "signature": "build123d.CenterArc.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.CenterArc.export_stl",
                    "signature": "build123d.CenterArc.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.CenterArc.extrude",
                    "signature": "build123d.CenterArc.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.CenterArc.face",
                    "signature": "build123d.CenterArc.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.CenterArc.faces",
                    "signature": "build123d.CenterArc.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.CenterArc.faces_intersected_by_axis",
                    "signature": "build123d.CenterArc.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.CenterArc.find_intersection",
                    "signature": "build123d.CenterArc.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.CenterArc.find_intersection_points",
                    "signature": "build123d.CenterArc.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.CenterArc.find_tangent",
                    "signature": "build123d.CenterArc.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.CenterArc.fix",
                    "signature": "build123d.CenterArc.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.CenterArc.fuse",
                    "signature": "build123d.CenterArc.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.CenterArc.hash_code",
                    "signature": "build123d.CenterArc.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.intersect",
                    "signature": "build123d.CenterArc.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.CenterArc.is_equal",
                    "signature": "build123d.CenterArc.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.is_null",
                    "signature": "build123d.CenterArc.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.is_same",
                    "signature": "build123d.CenterArc.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.is_valid",
                    "signature": "build123d.CenterArc.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.iter_path_reverse",
                    "signature": "build123d.CenterArc.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.CenterArc.locate",
                    "signature": "build123d.CenterArc.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.located",
                    "signature": "build123d.CenterArc.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.CenterArc.location_at",
                    "signature": "build123d.CenterArc.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.CenterArc.locations",
                    "signature": "build123d.CenterArc.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.CenterArc.make_bezier",
                    "signature": "build123d.CenterArc.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.CenterArc.make_circle",
                    "signature": "build123d.CenterArc.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.CenterArc.make_ellipse",
                    "signature": "build123d.CenterArc.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.CenterArc.make_helix",
                    "signature": "build123d.CenterArc.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.CenterArc.make_line",
                    "signature": "build123d.CenterArc.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.CenterArc.make_mid_way",
                    "signature": "build123d.CenterArc.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.CenterArc.make_spline",
                    "signature": "build123d.CenterArc.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.CenterArc.make_spline_approx",
                    "signature": "build123d.CenterArc.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.CenterArc.make_tangent_arc",
                    "signature": "build123d.CenterArc.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.CenterArc.make_three_point_arc",
                    "signature": "build123d.CenterArc.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.CenterArc.mesh",
                    "signature": "build123d.CenterArc.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.mirror",
                    "signature": "build123d.CenterArc.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.CenterArc.move",
                    "signature": "build123d.CenterArc.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.moved",
                    "signature": "build123d.CenterArc.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.CenterArc.normal",
                    "signature": "build123d.CenterArc.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.offset_2d",
                    "signature": "build123d.CenterArc.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.CenterArc.param_at",
                    "signature": "build123d.CenterArc.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.CenterArc.param_at_point",
                    "signature": "build123d.CenterArc.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.CenterArc.perpendicular_line",
                    "signature": "build123d.CenterArc.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.CenterArc.position_at",
                    "signature": "build123d.CenterArc.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.CenterArc.positions",
                    "signature": "build123d.CenterArc.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.CenterArc.project",
                    "signature": "build123d.CenterArc.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.project_faces",
                    "signature": "build123d.CenterArc.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.CenterArc.project_to_shape",
                    "signature": "build123d.CenterArc.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.CenterArc.project_to_viewport",
                    "signature": "build123d.CenterArc.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.CenterArc.relocate",
                    "signature": "build123d.CenterArc.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.CenterArc.reversed",
                    "signature": "build123d.CenterArc.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.CenterArc.rotate",
                    "signature": "build123d.CenterArc.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.CenterArc.scale",
                    "signature": "build123d.CenterArc.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.shape_type",
                    "signature": "build123d.CenterArc.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.CenterArc.shell",
                    "signature": "build123d.CenterArc.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.CenterArc.shells",
                    "signature": "build123d.CenterArc.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.CenterArc.show_topology",
                    "signature": "build123d.CenterArc.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.CenterArc.solid",
                    "signature": "build123d.CenterArc.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.CenterArc.solids",
                    "signature": "build123d.CenterArc.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.CenterArc.split",
                    "signature": "build123d.CenterArc.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.CenterArc.split_by_perimeter",
                    "signature": "build123d.CenterArc.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.CenterArc.start_point",
                    "signature": "build123d.CenterArc.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.CenterArc.tangent_angle_at",
                    "signature": "build123d.CenterArc.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.CenterArc.tangent_at",
                    "signature": "build123d.CenterArc.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.CenterArc.tessellate",
                    "signature": "build123d.CenterArc.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.CenterArc.to_arcs",
                    "signature": "build123d.CenterArc.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.CenterArc.to_axis",
                    "signature": "build123d.CenterArc.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.CenterArc.to_splines",
                    "signature": "build123d.CenterArc.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.CenterArc.to_vtk_poly_data",
                    "signature": "build123d.CenterArc.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.CenterArc.to_wire",
                    "signature": "build123d.CenterArc.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.CenterArc.transform_geometry",
                    "signature": "build123d.CenterArc.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.CenterArc.transform_shape",
                    "signature": "build123d.CenterArc.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.CenterArc.transformed",
                    "signature": "build123d.CenterArc.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.CenterArc.translate",
                    "signature": "build123d.CenterArc.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.CenterArc.trim",
                    "signature": "build123d.CenterArc.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.CenterArc.trim_to_length",
                    "signature": "build123d.CenterArc.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.CenterArc.vertex",
                    "signature": "build123d.CenterArc.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.CenterArc.vertices",
                    "signature": "build123d.CenterArc.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.CenterArc.wire",
                    "signature": "build123d.CenterArc.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.CenterArc.wires",
                    "signature": "build123d.CenterArc.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Center Arc\n\nAdd center arc to the line.\n\nArgs:\n    center (VectorLike): center point of arc\n    radius (float): arc radius\n    start_angle (float): arc staring angle\n    arc_size (float): arc size\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.CenterOf",
            "signature": "build123d.CenterOf()",
            "methods": [],
            "variables": [
                "BOUNDING_BOX",
                "GEOMETRY",
                "MASS",
                "name",
                "value"
            ],
            "docstring": "Center Options"
        },
        {
            "name": "build123d.Circle",
            "signature": "build123d.Circle(radius: 'float', align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Circle.bounding_box",
                    "signature": "build123d.Circle.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Circle.cast",
                    "signature": "build123d.Circle.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Circle.center",
                    "signature": "build123d.Circle.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Circle.chamfer",
                    "signature": "build123d.Circle.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Circle.clean",
                    "signature": "build123d.Circle.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Circle.closest_points",
                    "signature": "build123d.Circle.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Circle.combined_center",
                    "signature": "build123d.Circle.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Circle.compound",
                    "signature": "build123d.Circle.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Circle.compounds",
                    "signature": "build123d.Circle.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Circle.compute_mass",
                    "signature": "build123d.Circle.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.copy",
                    "signature": "build123d.Circle.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Circle.copy_attributes_to",
                    "signature": "build123d.Circle.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Circle.cut",
                    "signature": "build123d.Circle.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.distance",
                    "signature": "build123d.Circle.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.distance_to",
                    "signature": "build123d.Circle.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Circle.distance_to_with_closest_points",
                    "signature": "build123d.Circle.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Circle.distances",
                    "signature": "build123d.Circle.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.do_children_intersect",
                    "signature": "build123d.Circle.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Circle.dprism",
                    "signature": "build123d.Circle.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Circle.edge",
                    "signature": "build123d.Circle.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Circle.edges",
                    "signature": "build123d.Circle.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Circle.export_brep",
                    "signature": "build123d.Circle.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.export_step",
                    "signature": "build123d.Circle.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Circle.export_stl",
                    "signature": "build123d.Circle.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Circle.extrude",
                    "signature": "build123d.Circle.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Circle.face",
                    "signature": "build123d.Circle.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Circle.faces",
                    "signature": "build123d.Circle.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Circle.faces_intersected_by_axis",
                    "signature": "build123d.Circle.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Circle.fillet",
                    "signature": "build123d.Circle.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Circle.find_intersection",
                    "signature": "build123d.Circle.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Circle.find_intersection_points",
                    "signature": "build123d.Circle.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Circle.first_level_shapes",
                    "signature": "build123d.Circle.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Circle.fix",
                    "signature": "build123d.Circle.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Circle.fuse",
                    "signature": "build123d.Circle.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.get_type",
                    "signature": "build123d.Circle.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Circle.hash_code",
                    "signature": "build123d.Circle.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.hollow",
                    "signature": "build123d.Circle.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Circle.intersect",
                    "signature": "build123d.Circle.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.is_equal",
                    "signature": "build123d.Circle.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.is_inside",
                    "signature": "build123d.Circle.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Circle.is_null",
                    "signature": "build123d.Circle.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.is_same",
                    "signature": "build123d.Circle.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.is_valid",
                    "signature": "build123d.Circle.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.iter_path_reverse",
                    "signature": "build123d.Circle.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Circle.locate",
                    "signature": "build123d.Circle.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.located",
                    "signature": "build123d.Circle.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Circle.make_compound",
                    "signature": "build123d.Circle.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Circle.make_text",
                    "signature": "build123d.Circle.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Circle.make_triad",
                    "signature": "build123d.Circle.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Circle.max_fillet",
                    "signature": "build123d.Circle.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Circle.mesh",
                    "signature": "build123d.Circle.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.mirror",
                    "signature": "build123d.Circle.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Circle.move",
                    "signature": "build123d.Circle.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.moved",
                    "signature": "build123d.Circle.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Circle.offset_3d",
                    "signature": "build123d.Circle.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Circle.project_faces",
                    "signature": "build123d.Circle.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Circle.project_to_viewport",
                    "signature": "build123d.Circle.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Circle.relocate",
                    "signature": "build123d.Circle.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Circle.rotate",
                    "signature": "build123d.Circle.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Circle.scale",
                    "signature": "build123d.Circle.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.shape_type",
                    "signature": "build123d.Circle.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Circle.shell",
                    "signature": "build123d.Circle.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Circle.shells",
                    "signature": "build123d.Circle.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Circle.show_topology",
                    "signature": "build123d.Circle.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Circle.solid",
                    "signature": "build123d.Circle.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Circle.solids",
                    "signature": "build123d.Circle.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Circle.split",
                    "signature": "build123d.Circle.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Circle.split_by_perimeter",
                    "signature": "build123d.Circle.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Circle.tessellate",
                    "signature": "build123d.Circle.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Circle.to_arcs",
                    "signature": "build123d.Circle.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Circle.to_splines",
                    "signature": "build123d.Circle.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Circle.to_vtk_poly_data",
                    "signature": "build123d.Circle.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Circle.transform_geometry",
                    "signature": "build123d.Circle.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Circle.transform_shape",
                    "signature": "build123d.Circle.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Circle.transformed",
                    "signature": "build123d.Circle.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Circle.translate",
                    "signature": "build123d.Circle.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Circle.unwrap",
                    "signature": "build123d.Circle.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Circle.vertex",
                    "signature": "build123d.Circle.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Circle.vertices",
                    "signature": "build123d.Circle.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Circle.wire",
                    "signature": "build123d.Circle.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Circle.wires",
                    "signature": "build123d.Circle.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Circle\n\nAdd circle(s) to the sketch.\n\nArgs:\n    radius (float): circle size\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Color",
            "signature": "build123d.Color(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Color.to_tuple",
                    "signature": "build123d.Color.to_tuple(self)",
                    "docstring": "Value as tuple"
                }
            ],
            "variables": [],
            "docstring": "Color object based on OCCT Quantity_ColorRGBA.\n\nAttributes:\n    wrapped (Quantity_ColorRGBA): the OCP color object"
        },
        {
            "name": "build123d.ColorIndex",
            "signature": "build123d.ColorIndex()",
            "methods": [],
            "variables": [
                "BLACK",
                "BLUE",
                "CYAN",
                "GRAY",
                "GREEN",
                "LIGHT_GRAY",
                "MAGENTA",
                "RED",
                "YELLOW",
                "name",
                "value"
            ],
            "docstring": "Colors"
        },
        {
            "name": "build123d.Comparable",
            "signature": "build123d.Comparable()",
            "methods": [],
            "variables": [],
            "docstring": "Abstract base class that requires comparison methods"
        },
        {
            "name": "build123d.Compound",
            "signature": "build123d.Compound(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Compound.bounding_box",
                    "signature": "build123d.Compound.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Compound.cast",
                    "signature": "build123d.Compound.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Compound.center",
                    "signature": "build123d.Compound.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Compound.chamfer",
                    "signature": "build123d.Compound.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Compound.clean",
                    "signature": "build123d.Compound.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Compound.closest_points",
                    "signature": "build123d.Compound.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Compound.combined_center",
                    "signature": "build123d.Compound.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Compound.compound",
                    "signature": "build123d.Compound.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Compound.compounds",
                    "signature": "build123d.Compound.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Compound.compute_mass",
                    "signature": "build123d.Compound.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.copy",
                    "signature": "build123d.Compound.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Compound.copy_attributes_to",
                    "signature": "build123d.Compound.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Compound.cut",
                    "signature": "build123d.Compound.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.distance",
                    "signature": "build123d.Compound.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.distance_to",
                    "signature": "build123d.Compound.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Compound.distance_to_with_closest_points",
                    "signature": "build123d.Compound.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Compound.distances",
                    "signature": "build123d.Compound.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.do_children_intersect",
                    "signature": "build123d.Compound.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Compound.dprism",
                    "signature": "build123d.Compound.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Compound.edge",
                    "signature": "build123d.Compound.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Compound.edges",
                    "signature": "build123d.Compound.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Compound.export_brep",
                    "signature": "build123d.Compound.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.export_step",
                    "signature": "build123d.Compound.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Compound.export_stl",
                    "signature": "build123d.Compound.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Compound.extrude",
                    "signature": "build123d.Compound.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Compound.face",
                    "signature": "build123d.Compound.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Compound.faces",
                    "signature": "build123d.Compound.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Compound.faces_intersected_by_axis",
                    "signature": "build123d.Compound.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Compound.fillet",
                    "signature": "build123d.Compound.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Compound.find_intersection",
                    "signature": "build123d.Compound.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Compound.find_intersection_points",
                    "signature": "build123d.Compound.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Compound.first_level_shapes",
                    "signature": "build123d.Compound.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Compound.fix",
                    "signature": "build123d.Compound.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Compound.fuse",
                    "signature": "build123d.Compound.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.get_type",
                    "signature": "build123d.Compound.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Compound.hash_code",
                    "signature": "build123d.Compound.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.hollow",
                    "signature": "build123d.Compound.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Compound.intersect",
                    "signature": "build123d.Compound.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.is_equal",
                    "signature": "build123d.Compound.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.is_inside",
                    "signature": "build123d.Compound.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Compound.is_null",
                    "signature": "build123d.Compound.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.is_same",
                    "signature": "build123d.Compound.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.is_valid",
                    "signature": "build123d.Compound.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.iter_path_reverse",
                    "signature": "build123d.Compound.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Compound.locate",
                    "signature": "build123d.Compound.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.located",
                    "signature": "build123d.Compound.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Compound.make_compound",
                    "signature": "build123d.Compound.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Compound.make_text",
                    "signature": "build123d.Compound.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Compound.make_triad",
                    "signature": "build123d.Compound.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Compound.max_fillet",
                    "signature": "build123d.Compound.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Compound.mesh",
                    "signature": "build123d.Compound.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.mirror",
                    "signature": "build123d.Compound.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Compound.move",
                    "signature": "build123d.Compound.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.moved",
                    "signature": "build123d.Compound.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Compound.offset_3d",
                    "signature": "build123d.Compound.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Compound.project_faces",
                    "signature": "build123d.Compound.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Compound.project_to_viewport",
                    "signature": "build123d.Compound.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Compound.relocate",
                    "signature": "build123d.Compound.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Compound.rotate",
                    "signature": "build123d.Compound.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Compound.scale",
                    "signature": "build123d.Compound.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.shape_type",
                    "signature": "build123d.Compound.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Compound.shell",
                    "signature": "build123d.Compound.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Compound.shells",
                    "signature": "build123d.Compound.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Compound.show_topology",
                    "signature": "build123d.Compound.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Compound.solid",
                    "signature": "build123d.Compound.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Compound.solids",
                    "signature": "build123d.Compound.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Compound.split",
                    "signature": "build123d.Compound.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Compound.split_by_perimeter",
                    "signature": "build123d.Compound.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Compound.tessellate",
                    "signature": "build123d.Compound.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Compound.to_arcs",
                    "signature": "build123d.Compound.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Compound.to_splines",
                    "signature": "build123d.Compound.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Compound.to_vtk_poly_data",
                    "signature": "build123d.Compound.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Compound.transform_geometry",
                    "signature": "build123d.Compound.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Compound.transform_shape",
                    "signature": "build123d.Compound.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Compound.transformed",
                    "signature": "build123d.Compound.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Compound.translate",
                    "signature": "build123d.Compound.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Compound.unwrap",
                    "signature": "build123d.Compound.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Compound.vertex",
                    "signature": "build123d.Compound.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Compound.vertices",
                    "signature": "build123d.Compound.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Compound.wire",
                    "signature": "build123d.Compound.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Compound.wires",
                    "signature": "build123d.Compound.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "A Compound in build123d is a topological entity representing a collection of\ngeometric shapes grouped together within a single structure. It serves as a\ncontainer for organizing diverse shapes like edges, faces, or solids. This\nhierarchical arrangement facilitates the construction of complex models by\ncombining simpler shapes. Compound plays a pivotal role in managing the\ncomposition and structure of intricate 3D models in computer-aided design\n(CAD) applications, allowing engineers and designers to work with assemblies\nof shapes as unified entities for efficient modeling and analysis."
        },
        {
            "name": "build123d.Cone",
            "signature": "build123d.Cone(bottom_radius: 'float', top_radius: 'float', height: 'float', arc_size: 'float' = 360, rotation: 'RotationLike' = (0, 0, 0), align: 'Union[Align, tuple[Align, Align, Align]]' = (<Align.CENTER>, <Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Cone.bounding_box",
                    "signature": "build123d.Cone.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Cone.cast",
                    "signature": "build123d.Cone.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Cone.center",
                    "signature": "build123d.Cone.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Cone.chamfer",
                    "signature": "build123d.Cone.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Cone.clean",
                    "signature": "build123d.Cone.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Cone.closest_points",
                    "signature": "build123d.Cone.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Cone.combined_center",
                    "signature": "build123d.Cone.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Cone.compound",
                    "signature": "build123d.Cone.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Cone.compounds",
                    "signature": "build123d.Cone.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Cone.compute_mass",
                    "signature": "build123d.Cone.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.copy",
                    "signature": "build123d.Cone.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Cone.copy_attributes_to",
                    "signature": "build123d.Cone.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Cone.cut",
                    "signature": "build123d.Cone.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.distance",
                    "signature": "build123d.Cone.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.distance_to",
                    "signature": "build123d.Cone.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Cone.distance_to_with_closest_points",
                    "signature": "build123d.Cone.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Cone.distances",
                    "signature": "build123d.Cone.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.do_children_intersect",
                    "signature": "build123d.Cone.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Cone.dprism",
                    "signature": "build123d.Cone.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Cone.edge",
                    "signature": "build123d.Cone.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Cone.edges",
                    "signature": "build123d.Cone.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Cone.export_brep",
                    "signature": "build123d.Cone.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.export_step",
                    "signature": "build123d.Cone.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Cone.export_stl",
                    "signature": "build123d.Cone.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Cone.extrude",
                    "signature": "build123d.Cone.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Cone.face",
                    "signature": "build123d.Cone.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Cone.faces",
                    "signature": "build123d.Cone.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Cone.faces_intersected_by_axis",
                    "signature": "build123d.Cone.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Cone.fillet",
                    "signature": "build123d.Cone.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Cone.find_intersection",
                    "signature": "build123d.Cone.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Cone.find_intersection_points",
                    "signature": "build123d.Cone.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Cone.first_level_shapes",
                    "signature": "build123d.Cone.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Cone.fix",
                    "signature": "build123d.Cone.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Cone.fuse",
                    "signature": "build123d.Cone.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.get_type",
                    "signature": "build123d.Cone.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Cone.hash_code",
                    "signature": "build123d.Cone.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.hollow",
                    "signature": "build123d.Cone.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Cone.intersect",
                    "signature": "build123d.Cone.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.is_equal",
                    "signature": "build123d.Cone.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.is_inside",
                    "signature": "build123d.Cone.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Cone.is_null",
                    "signature": "build123d.Cone.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.is_same",
                    "signature": "build123d.Cone.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.is_valid",
                    "signature": "build123d.Cone.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.iter_path_reverse",
                    "signature": "build123d.Cone.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Cone.locate",
                    "signature": "build123d.Cone.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.located",
                    "signature": "build123d.Cone.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Cone.make_compound",
                    "signature": "build123d.Cone.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Cone.make_text",
                    "signature": "build123d.Cone.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Cone.make_triad",
                    "signature": "build123d.Cone.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Cone.max_fillet",
                    "signature": "build123d.Cone.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Cone.mesh",
                    "signature": "build123d.Cone.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.mirror",
                    "signature": "build123d.Cone.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Cone.move",
                    "signature": "build123d.Cone.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.moved",
                    "signature": "build123d.Cone.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Cone.offset_3d",
                    "signature": "build123d.Cone.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Cone.project_faces",
                    "signature": "build123d.Cone.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Cone.project_to_viewport",
                    "signature": "build123d.Cone.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Cone.relocate",
                    "signature": "build123d.Cone.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Cone.rotate",
                    "signature": "build123d.Cone.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Cone.scale",
                    "signature": "build123d.Cone.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.shape_type",
                    "signature": "build123d.Cone.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Cone.shell",
                    "signature": "build123d.Cone.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Cone.shells",
                    "signature": "build123d.Cone.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Cone.show_topology",
                    "signature": "build123d.Cone.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Cone.solid",
                    "signature": "build123d.Cone.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Cone.solids",
                    "signature": "build123d.Cone.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Cone.split",
                    "signature": "build123d.Cone.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Cone.split_by_perimeter",
                    "signature": "build123d.Cone.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Cone.tessellate",
                    "signature": "build123d.Cone.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Cone.to_arcs",
                    "signature": "build123d.Cone.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Cone.to_splines",
                    "signature": "build123d.Cone.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Cone.to_vtk_poly_data",
                    "signature": "build123d.Cone.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Cone.transform_geometry",
                    "signature": "build123d.Cone.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Cone.transform_shape",
                    "signature": "build123d.Cone.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Cone.transformed",
                    "signature": "build123d.Cone.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Cone.translate",
                    "signature": "build123d.Cone.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Cone.unwrap",
                    "signature": "build123d.Cone.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Cone.vertex",
                    "signature": "build123d.Cone.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Cone.vertices",
                    "signature": "build123d.Cone.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Cone.wire",
                    "signature": "build123d.Cone.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Cone.wires",
                    "signature": "build123d.Cone.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Part Object: Cone\n\nCreate a cone(s) and combine with part.\n\nArgs:\n    bottom_radius (float): cone size\n    top_radius (float): top size, could be zero\n    height (float): cone size\n    arc_size (float, optional): angular size of cone. Defaults to 360.\n    rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).\n    align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,\n        or max of object. Defaults to (Align.CENTER, Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combine mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.CounterBoreHole",
            "signature": "build123d.CounterBoreHole(radius: 'float', counter_bore_radius: 'float', counter_bore_depth: 'float', depth: 'float' = None, mode: 'Mode' = <Mode.SUBTRACT>)",
            "methods": [
                {
                    "name": "build123d.CounterBoreHole.bounding_box",
                    "signature": "build123d.CounterBoreHole.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.CounterBoreHole.cast",
                    "signature": "build123d.CounterBoreHole.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.CounterBoreHole.center",
                    "signature": "build123d.CounterBoreHole.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.CounterBoreHole.chamfer",
                    "signature": "build123d.CounterBoreHole.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.CounterBoreHole.clean",
                    "signature": "build123d.CounterBoreHole.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.CounterBoreHole.closest_points",
                    "signature": "build123d.CounterBoreHole.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.CounterBoreHole.combined_center",
                    "signature": "build123d.CounterBoreHole.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.CounterBoreHole.compound",
                    "signature": "build123d.CounterBoreHole.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.CounterBoreHole.compounds",
                    "signature": "build123d.CounterBoreHole.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.CounterBoreHole.compute_mass",
                    "signature": "build123d.CounterBoreHole.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.copy",
                    "signature": "build123d.CounterBoreHole.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.CounterBoreHole.copy_attributes_to",
                    "signature": "build123d.CounterBoreHole.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.CounterBoreHole.cut",
                    "signature": "build123d.CounterBoreHole.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.distance",
                    "signature": "build123d.CounterBoreHole.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.distance_to",
                    "signature": "build123d.CounterBoreHole.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.CounterBoreHole.distance_to_with_closest_points",
                    "signature": "build123d.CounterBoreHole.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.CounterBoreHole.distances",
                    "signature": "build123d.CounterBoreHole.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.do_children_intersect",
                    "signature": "build123d.CounterBoreHole.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.CounterBoreHole.dprism",
                    "signature": "build123d.CounterBoreHole.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.CounterBoreHole.edge",
                    "signature": "build123d.CounterBoreHole.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.CounterBoreHole.edges",
                    "signature": "build123d.CounterBoreHole.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.CounterBoreHole.export_brep",
                    "signature": "build123d.CounterBoreHole.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.export_step",
                    "signature": "build123d.CounterBoreHole.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.CounterBoreHole.export_stl",
                    "signature": "build123d.CounterBoreHole.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.CounterBoreHole.extrude",
                    "signature": "build123d.CounterBoreHole.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.CounterBoreHole.face",
                    "signature": "build123d.CounterBoreHole.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.CounterBoreHole.faces",
                    "signature": "build123d.CounterBoreHole.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.CounterBoreHole.faces_intersected_by_axis",
                    "signature": "build123d.CounterBoreHole.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.CounterBoreHole.fillet",
                    "signature": "build123d.CounterBoreHole.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.CounterBoreHole.find_intersection",
                    "signature": "build123d.CounterBoreHole.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.CounterBoreHole.find_intersection_points",
                    "signature": "build123d.CounterBoreHole.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.CounterBoreHole.first_level_shapes",
                    "signature": "build123d.CounterBoreHole.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.CounterBoreHole.fix",
                    "signature": "build123d.CounterBoreHole.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.CounterBoreHole.fuse",
                    "signature": "build123d.CounterBoreHole.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.get_type",
                    "signature": "build123d.CounterBoreHole.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.CounterBoreHole.hash_code",
                    "signature": "build123d.CounterBoreHole.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.hollow",
                    "signature": "build123d.CounterBoreHole.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.CounterBoreHole.intersect",
                    "signature": "build123d.CounterBoreHole.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.is_equal",
                    "signature": "build123d.CounterBoreHole.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.is_inside",
                    "signature": "build123d.CounterBoreHole.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.CounterBoreHole.is_null",
                    "signature": "build123d.CounterBoreHole.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.is_same",
                    "signature": "build123d.CounterBoreHole.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.is_valid",
                    "signature": "build123d.CounterBoreHole.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.iter_path_reverse",
                    "signature": "build123d.CounterBoreHole.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.CounterBoreHole.locate",
                    "signature": "build123d.CounterBoreHole.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.located",
                    "signature": "build123d.CounterBoreHole.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.CounterBoreHole.make_compound",
                    "signature": "build123d.CounterBoreHole.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.make_text",
                    "signature": "build123d.CounterBoreHole.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.CounterBoreHole.make_triad",
                    "signature": "build123d.CounterBoreHole.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.CounterBoreHole.max_fillet",
                    "signature": "build123d.CounterBoreHole.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.CounterBoreHole.mesh",
                    "signature": "build123d.CounterBoreHole.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.mirror",
                    "signature": "build123d.CounterBoreHole.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.CounterBoreHole.move",
                    "signature": "build123d.CounterBoreHole.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.moved",
                    "signature": "build123d.CounterBoreHole.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.CounterBoreHole.offset_3d",
                    "signature": "build123d.CounterBoreHole.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.CounterBoreHole.project_faces",
                    "signature": "build123d.CounterBoreHole.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.CounterBoreHole.project_to_viewport",
                    "signature": "build123d.CounterBoreHole.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.CounterBoreHole.relocate",
                    "signature": "build123d.CounterBoreHole.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.CounterBoreHole.rotate",
                    "signature": "build123d.CounterBoreHole.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.CounterBoreHole.scale",
                    "signature": "build123d.CounterBoreHole.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.shape_type",
                    "signature": "build123d.CounterBoreHole.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.CounterBoreHole.shell",
                    "signature": "build123d.CounterBoreHole.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.CounterBoreHole.shells",
                    "signature": "build123d.CounterBoreHole.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.CounterBoreHole.show_topology",
                    "signature": "build123d.CounterBoreHole.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.CounterBoreHole.solid",
                    "signature": "build123d.CounterBoreHole.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.CounterBoreHole.solids",
                    "signature": "build123d.CounterBoreHole.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.CounterBoreHole.split",
                    "signature": "build123d.CounterBoreHole.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.CounterBoreHole.split_by_perimeter",
                    "signature": "build123d.CounterBoreHole.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.CounterBoreHole.tessellate",
                    "signature": "build123d.CounterBoreHole.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.CounterBoreHole.to_arcs",
                    "signature": "build123d.CounterBoreHole.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.CounterBoreHole.to_splines",
                    "signature": "build123d.CounterBoreHole.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.CounterBoreHole.to_vtk_poly_data",
                    "signature": "build123d.CounterBoreHole.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.CounterBoreHole.transform_geometry",
                    "signature": "build123d.CounterBoreHole.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.CounterBoreHole.transform_shape",
                    "signature": "build123d.CounterBoreHole.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.CounterBoreHole.transformed",
                    "signature": "build123d.CounterBoreHole.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.CounterBoreHole.translate",
                    "signature": "build123d.CounterBoreHole.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterBoreHole.unwrap",
                    "signature": "build123d.CounterBoreHole.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.CounterBoreHole.vertex",
                    "signature": "build123d.CounterBoreHole.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.CounterBoreHole.vertices",
                    "signature": "build123d.CounterBoreHole.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.CounterBoreHole.wire",
                    "signature": "build123d.CounterBoreHole.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.CounterBoreHole.wires",
                    "signature": "build123d.CounterBoreHole.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Part Operation: Counter Bore Hole\n\nCreate a counter bore hole in part.\n\nArgs:\n    radius (float): hole size\n    counter_bore_radius (float): counter bore size\n    counter_bore_depth (float): counter bore depth\n    depth (float, optional): hole depth - None implies through part. Defaults to None.\n    mode (Mode, optional): combination mode. Defaults to Mode.SUBTRACT."
        },
        {
            "name": "build123d.CounterSinkHole",
            "signature": "build123d.CounterSinkHole(radius: 'float', counter_sink_radius: 'float', depth: 'float' = None, counter_sink_angle: 'float' = 82, mode: 'Mode' = <Mode.SUBTRACT>)",
            "methods": [
                {
                    "name": "build123d.CounterSinkHole.bounding_box",
                    "signature": "build123d.CounterSinkHole.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.CounterSinkHole.cast",
                    "signature": "build123d.CounterSinkHole.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.CounterSinkHole.center",
                    "signature": "build123d.CounterSinkHole.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.CounterSinkHole.chamfer",
                    "signature": "build123d.CounterSinkHole.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.CounterSinkHole.clean",
                    "signature": "build123d.CounterSinkHole.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.CounterSinkHole.closest_points",
                    "signature": "build123d.CounterSinkHole.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.CounterSinkHole.combined_center",
                    "signature": "build123d.CounterSinkHole.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.CounterSinkHole.compound",
                    "signature": "build123d.CounterSinkHole.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.CounterSinkHole.compounds",
                    "signature": "build123d.CounterSinkHole.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.CounterSinkHole.compute_mass",
                    "signature": "build123d.CounterSinkHole.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.copy",
                    "signature": "build123d.CounterSinkHole.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.CounterSinkHole.copy_attributes_to",
                    "signature": "build123d.CounterSinkHole.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.CounterSinkHole.cut",
                    "signature": "build123d.CounterSinkHole.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.distance",
                    "signature": "build123d.CounterSinkHole.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.distance_to",
                    "signature": "build123d.CounterSinkHole.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.CounterSinkHole.distance_to_with_closest_points",
                    "signature": "build123d.CounterSinkHole.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.CounterSinkHole.distances",
                    "signature": "build123d.CounterSinkHole.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.do_children_intersect",
                    "signature": "build123d.CounterSinkHole.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.CounterSinkHole.dprism",
                    "signature": "build123d.CounterSinkHole.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.CounterSinkHole.edge",
                    "signature": "build123d.CounterSinkHole.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.CounterSinkHole.edges",
                    "signature": "build123d.CounterSinkHole.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.CounterSinkHole.export_brep",
                    "signature": "build123d.CounterSinkHole.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.export_step",
                    "signature": "build123d.CounterSinkHole.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.CounterSinkHole.export_stl",
                    "signature": "build123d.CounterSinkHole.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.CounterSinkHole.extrude",
                    "signature": "build123d.CounterSinkHole.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.CounterSinkHole.face",
                    "signature": "build123d.CounterSinkHole.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.CounterSinkHole.faces",
                    "signature": "build123d.CounterSinkHole.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.CounterSinkHole.faces_intersected_by_axis",
                    "signature": "build123d.CounterSinkHole.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.CounterSinkHole.fillet",
                    "signature": "build123d.CounterSinkHole.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.CounterSinkHole.find_intersection",
                    "signature": "build123d.CounterSinkHole.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.CounterSinkHole.find_intersection_points",
                    "signature": "build123d.CounterSinkHole.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.CounterSinkHole.first_level_shapes",
                    "signature": "build123d.CounterSinkHole.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.CounterSinkHole.fix",
                    "signature": "build123d.CounterSinkHole.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.CounterSinkHole.fuse",
                    "signature": "build123d.CounterSinkHole.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.get_type",
                    "signature": "build123d.CounterSinkHole.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.CounterSinkHole.hash_code",
                    "signature": "build123d.CounterSinkHole.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.hollow",
                    "signature": "build123d.CounterSinkHole.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.CounterSinkHole.intersect",
                    "signature": "build123d.CounterSinkHole.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.is_equal",
                    "signature": "build123d.CounterSinkHole.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.is_inside",
                    "signature": "build123d.CounterSinkHole.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.CounterSinkHole.is_null",
                    "signature": "build123d.CounterSinkHole.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.is_same",
                    "signature": "build123d.CounterSinkHole.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.is_valid",
                    "signature": "build123d.CounterSinkHole.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.iter_path_reverse",
                    "signature": "build123d.CounterSinkHole.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.CounterSinkHole.locate",
                    "signature": "build123d.CounterSinkHole.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.located",
                    "signature": "build123d.CounterSinkHole.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.CounterSinkHole.make_compound",
                    "signature": "build123d.CounterSinkHole.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.make_text",
                    "signature": "build123d.CounterSinkHole.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.CounterSinkHole.make_triad",
                    "signature": "build123d.CounterSinkHole.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.CounterSinkHole.max_fillet",
                    "signature": "build123d.CounterSinkHole.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.CounterSinkHole.mesh",
                    "signature": "build123d.CounterSinkHole.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.mirror",
                    "signature": "build123d.CounterSinkHole.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.CounterSinkHole.move",
                    "signature": "build123d.CounterSinkHole.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.moved",
                    "signature": "build123d.CounterSinkHole.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.CounterSinkHole.offset_3d",
                    "signature": "build123d.CounterSinkHole.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.CounterSinkHole.project_faces",
                    "signature": "build123d.CounterSinkHole.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.CounterSinkHole.project_to_viewport",
                    "signature": "build123d.CounterSinkHole.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.CounterSinkHole.relocate",
                    "signature": "build123d.CounterSinkHole.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.CounterSinkHole.rotate",
                    "signature": "build123d.CounterSinkHole.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.CounterSinkHole.scale",
                    "signature": "build123d.CounterSinkHole.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.shape_type",
                    "signature": "build123d.CounterSinkHole.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.CounterSinkHole.shell",
                    "signature": "build123d.CounterSinkHole.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.CounterSinkHole.shells",
                    "signature": "build123d.CounterSinkHole.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.CounterSinkHole.show_topology",
                    "signature": "build123d.CounterSinkHole.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.CounterSinkHole.solid",
                    "signature": "build123d.CounterSinkHole.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.CounterSinkHole.solids",
                    "signature": "build123d.CounterSinkHole.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.CounterSinkHole.split",
                    "signature": "build123d.CounterSinkHole.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.CounterSinkHole.split_by_perimeter",
                    "signature": "build123d.CounterSinkHole.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.CounterSinkHole.tessellate",
                    "signature": "build123d.CounterSinkHole.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.CounterSinkHole.to_arcs",
                    "signature": "build123d.CounterSinkHole.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.CounterSinkHole.to_splines",
                    "signature": "build123d.CounterSinkHole.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.CounterSinkHole.to_vtk_poly_data",
                    "signature": "build123d.CounterSinkHole.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.CounterSinkHole.transform_geometry",
                    "signature": "build123d.CounterSinkHole.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.CounterSinkHole.transform_shape",
                    "signature": "build123d.CounterSinkHole.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.CounterSinkHole.transformed",
                    "signature": "build123d.CounterSinkHole.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.CounterSinkHole.translate",
                    "signature": "build123d.CounterSinkHole.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.CounterSinkHole.unwrap",
                    "signature": "build123d.CounterSinkHole.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.CounterSinkHole.vertex",
                    "signature": "build123d.CounterSinkHole.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.CounterSinkHole.vertices",
                    "signature": "build123d.CounterSinkHole.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.CounterSinkHole.wire",
                    "signature": "build123d.CounterSinkHole.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.CounterSinkHole.wires",
                    "signature": "build123d.CounterSinkHole.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Part Operation: Counter Sink Hole\n\nCreate a counter sink hole in part.\n\nArgs:\n    radius (float): hole size\n    counter_sink_radius (float): counter sink size\n    depth (float, optional): hole depth - None implies through part. Defaults to None.\n    counter_sink_angle (float, optional): cone angle. Defaults to 82.\n    mode (Mode, optional): combination mode. Defaults to Mode.SUBTRACT."
        },
        {
            "name": "build123d.Curve",
            "signature": "build123d.Curve()",
            "methods": [
                {
                    "name": "build123d.Curve.bounding_box",
                    "signature": "build123d.Curve.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Curve.cast",
                    "signature": "build123d.Curve.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Curve.center",
                    "signature": "build123d.Curve.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Curve.chamfer",
                    "signature": "build123d.Curve.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Curve.clean",
                    "signature": "build123d.Curve.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Curve.closest_points",
                    "signature": "build123d.Curve.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Curve.combined_center",
                    "signature": "build123d.Curve.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Curve.compound",
                    "signature": "build123d.Curve.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Curve.compounds",
                    "signature": "build123d.Curve.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Curve.compute_mass",
                    "signature": "build123d.Curve.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.copy",
                    "signature": "build123d.Curve.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Curve.copy_attributes_to",
                    "signature": "build123d.Curve.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Curve.cut",
                    "signature": "build123d.Curve.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.distance",
                    "signature": "build123d.Curve.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.distance_to",
                    "signature": "build123d.Curve.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Curve.distance_to_with_closest_points",
                    "signature": "build123d.Curve.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Curve.distances",
                    "signature": "build123d.Curve.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.do_children_intersect",
                    "signature": "build123d.Curve.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Curve.dprism",
                    "signature": "build123d.Curve.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Curve.edge",
                    "signature": "build123d.Curve.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Curve.edges",
                    "signature": "build123d.Curve.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Curve.export_brep",
                    "signature": "build123d.Curve.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.export_step",
                    "signature": "build123d.Curve.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Curve.export_stl",
                    "signature": "build123d.Curve.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Curve.extrude",
                    "signature": "build123d.Curve.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Curve.face",
                    "signature": "build123d.Curve.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Curve.faces",
                    "signature": "build123d.Curve.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Curve.faces_intersected_by_axis",
                    "signature": "build123d.Curve.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Curve.fillet",
                    "signature": "build123d.Curve.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Curve.find_intersection",
                    "signature": "build123d.Curve.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Curve.find_intersection_points",
                    "signature": "build123d.Curve.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Curve.first_level_shapes",
                    "signature": "build123d.Curve.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Curve.fix",
                    "signature": "build123d.Curve.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Curve.fuse",
                    "signature": "build123d.Curve.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.get_type",
                    "signature": "build123d.Curve.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Curve.hash_code",
                    "signature": "build123d.Curve.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.hollow",
                    "signature": "build123d.Curve.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Curve.intersect",
                    "signature": "build123d.Curve.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.is_equal",
                    "signature": "build123d.Curve.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.is_inside",
                    "signature": "build123d.Curve.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Curve.is_null",
                    "signature": "build123d.Curve.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.is_same",
                    "signature": "build123d.Curve.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.is_valid",
                    "signature": "build123d.Curve.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.iter_path_reverse",
                    "signature": "build123d.Curve.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Curve.locate",
                    "signature": "build123d.Curve.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.located",
                    "signature": "build123d.Curve.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Curve.make_compound",
                    "signature": "build123d.Curve.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Curve.make_text",
                    "signature": "build123d.Curve.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Curve.make_triad",
                    "signature": "build123d.Curve.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Curve.max_fillet",
                    "signature": "build123d.Curve.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Curve.mesh",
                    "signature": "build123d.Curve.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.mirror",
                    "signature": "build123d.Curve.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Curve.move",
                    "signature": "build123d.Curve.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.moved",
                    "signature": "build123d.Curve.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Curve.offset_3d",
                    "signature": "build123d.Curve.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Curve.project_faces",
                    "signature": "build123d.Curve.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Curve.project_to_viewport",
                    "signature": "build123d.Curve.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Curve.relocate",
                    "signature": "build123d.Curve.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Curve.rotate",
                    "signature": "build123d.Curve.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Curve.scale",
                    "signature": "build123d.Curve.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.shape_type",
                    "signature": "build123d.Curve.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Curve.shell",
                    "signature": "build123d.Curve.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Curve.shells",
                    "signature": "build123d.Curve.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Curve.show_topology",
                    "signature": "build123d.Curve.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Curve.solid",
                    "signature": "build123d.Curve.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Curve.solids",
                    "signature": "build123d.Curve.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Curve.split",
                    "signature": "build123d.Curve.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Curve.split_by_perimeter",
                    "signature": "build123d.Curve.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Curve.tessellate",
                    "signature": "build123d.Curve.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Curve.to_arcs",
                    "signature": "build123d.Curve.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Curve.to_splines",
                    "signature": "build123d.Curve.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Curve.to_vtk_poly_data",
                    "signature": "build123d.Curve.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Curve.transform_geometry",
                    "signature": "build123d.Curve.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Curve.transform_shape",
                    "signature": "build123d.Curve.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Curve.transformed",
                    "signature": "build123d.Curve.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Curve.translate",
                    "signature": "build123d.Curve.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Curve.unwrap",
                    "signature": "build123d.Curve.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Curve.vertex",
                    "signature": "build123d.Curve.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Curve.vertices",
                    "signature": "build123d.Curve.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Curve.wire",
                    "signature": "build123d.Curve.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Curve.wires",
                    "signature": "build123d.Curve.wires(self) -> 'list[Wire]'",
                    "docstring": "A list of wires created from the edges"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "A Compound containing 1D objects - aka Edges"
        },
        {
            "name": "build123d.Cylinder",
            "signature": "build123d.Cylinder(radius: 'float', height: 'float', arc_size: 'float' = 360, rotation: 'RotationLike' = (0, 0, 0), align: 'Union[Align, tuple[Align, Align, Align]]' = (<Align.CENTER>, <Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Cylinder.bounding_box",
                    "signature": "build123d.Cylinder.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Cylinder.cast",
                    "signature": "build123d.Cylinder.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Cylinder.center",
                    "signature": "build123d.Cylinder.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Cylinder.chamfer",
                    "signature": "build123d.Cylinder.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Cylinder.clean",
                    "signature": "build123d.Cylinder.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Cylinder.closest_points",
                    "signature": "build123d.Cylinder.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Cylinder.combined_center",
                    "signature": "build123d.Cylinder.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Cylinder.compound",
                    "signature": "build123d.Cylinder.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Cylinder.compounds",
                    "signature": "build123d.Cylinder.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Cylinder.compute_mass",
                    "signature": "build123d.Cylinder.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.copy",
                    "signature": "build123d.Cylinder.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Cylinder.copy_attributes_to",
                    "signature": "build123d.Cylinder.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Cylinder.cut",
                    "signature": "build123d.Cylinder.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.distance",
                    "signature": "build123d.Cylinder.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.distance_to",
                    "signature": "build123d.Cylinder.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Cylinder.distance_to_with_closest_points",
                    "signature": "build123d.Cylinder.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Cylinder.distances",
                    "signature": "build123d.Cylinder.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.do_children_intersect",
                    "signature": "build123d.Cylinder.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Cylinder.dprism",
                    "signature": "build123d.Cylinder.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Cylinder.edge",
                    "signature": "build123d.Cylinder.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Cylinder.edges",
                    "signature": "build123d.Cylinder.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Cylinder.export_brep",
                    "signature": "build123d.Cylinder.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.export_step",
                    "signature": "build123d.Cylinder.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Cylinder.export_stl",
                    "signature": "build123d.Cylinder.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Cylinder.extrude",
                    "signature": "build123d.Cylinder.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Cylinder.face",
                    "signature": "build123d.Cylinder.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Cylinder.faces",
                    "signature": "build123d.Cylinder.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Cylinder.faces_intersected_by_axis",
                    "signature": "build123d.Cylinder.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Cylinder.fillet",
                    "signature": "build123d.Cylinder.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Cylinder.find_intersection",
                    "signature": "build123d.Cylinder.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Cylinder.find_intersection_points",
                    "signature": "build123d.Cylinder.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Cylinder.first_level_shapes",
                    "signature": "build123d.Cylinder.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Cylinder.fix",
                    "signature": "build123d.Cylinder.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Cylinder.fuse",
                    "signature": "build123d.Cylinder.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.get_type",
                    "signature": "build123d.Cylinder.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Cylinder.hash_code",
                    "signature": "build123d.Cylinder.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.hollow",
                    "signature": "build123d.Cylinder.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Cylinder.intersect",
                    "signature": "build123d.Cylinder.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.is_equal",
                    "signature": "build123d.Cylinder.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.is_inside",
                    "signature": "build123d.Cylinder.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Cylinder.is_null",
                    "signature": "build123d.Cylinder.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.is_same",
                    "signature": "build123d.Cylinder.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.is_valid",
                    "signature": "build123d.Cylinder.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.iter_path_reverse",
                    "signature": "build123d.Cylinder.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Cylinder.locate",
                    "signature": "build123d.Cylinder.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.located",
                    "signature": "build123d.Cylinder.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Cylinder.make_compound",
                    "signature": "build123d.Cylinder.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.make_text",
                    "signature": "build123d.Cylinder.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Cylinder.make_triad",
                    "signature": "build123d.Cylinder.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Cylinder.max_fillet",
                    "signature": "build123d.Cylinder.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Cylinder.mesh",
                    "signature": "build123d.Cylinder.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.mirror",
                    "signature": "build123d.Cylinder.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Cylinder.move",
                    "signature": "build123d.Cylinder.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.moved",
                    "signature": "build123d.Cylinder.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Cylinder.offset_3d",
                    "signature": "build123d.Cylinder.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Cylinder.project_faces",
                    "signature": "build123d.Cylinder.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Cylinder.project_to_viewport",
                    "signature": "build123d.Cylinder.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Cylinder.relocate",
                    "signature": "build123d.Cylinder.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Cylinder.rotate",
                    "signature": "build123d.Cylinder.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Cylinder.scale",
                    "signature": "build123d.Cylinder.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.shape_type",
                    "signature": "build123d.Cylinder.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Cylinder.shell",
                    "signature": "build123d.Cylinder.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Cylinder.shells",
                    "signature": "build123d.Cylinder.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Cylinder.show_topology",
                    "signature": "build123d.Cylinder.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Cylinder.solid",
                    "signature": "build123d.Cylinder.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Cylinder.solids",
                    "signature": "build123d.Cylinder.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Cylinder.split",
                    "signature": "build123d.Cylinder.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Cylinder.split_by_perimeter",
                    "signature": "build123d.Cylinder.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Cylinder.tessellate",
                    "signature": "build123d.Cylinder.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Cylinder.to_arcs",
                    "signature": "build123d.Cylinder.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Cylinder.to_splines",
                    "signature": "build123d.Cylinder.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Cylinder.to_vtk_poly_data",
                    "signature": "build123d.Cylinder.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Cylinder.transform_geometry",
                    "signature": "build123d.Cylinder.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Cylinder.transform_shape",
                    "signature": "build123d.Cylinder.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Cylinder.transformed",
                    "signature": "build123d.Cylinder.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Cylinder.translate",
                    "signature": "build123d.Cylinder.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Cylinder.unwrap",
                    "signature": "build123d.Cylinder.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Cylinder.vertex",
                    "signature": "build123d.Cylinder.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Cylinder.vertices",
                    "signature": "build123d.Cylinder.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Cylinder.wire",
                    "signature": "build123d.Cylinder.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Cylinder.wires",
                    "signature": "build123d.Cylinder.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Part Object: Cylinder\n\nCreate a cylinder(s) and combine with part.\n\nArgs:\n    radius (float): cylinder size\n    height (float): cylinder size\n    arc_size (float, optional): angular size of cone. Defaults to 360.\n    rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).\n    align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,\n        or max of object. Defaults to (Align.CENTER, Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combine mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.CylindricalJoint",
            "signature": "build123d.CylindricalJoint(label: 'str', to_part: 'Union[Solid, Compound]' = None, axis: 'Axis' = ((0.0, 0.0, 0.0),(0.0, 0.0, 1.0)), angle_reference: 'VectorLike' = None, linear_range: 'tuple[float, float]' = (0, inf), angular_range: 'tuple[float, float]' = (0, 360))",
            "methods": [
                {
                    "name": "build123d.CylindricalJoint.connect_to",
                    "signature": "build123d.CylindricalJoint.connect_to(self, other: 'RigidJoint', *, position: 'float' = None, angle: 'float' = None)",
                    "docstring": "Connect CylindricalJoint and RigidJoint\"\n\nArgs:\n    other (Joint): joint to connect to\n    position (float, optional): linear position. Defaults to linear range min.\n    angle (float, optional): angle in degrees. Defaults to range min.\n\nRaises:\n    TypeError: other must be of type RigidJoint\n    ValueError: position out of range\n    ValueError: angle out of range"
                },
                {
                    "name": "build123d.CylindricalJoint.relative_to",
                    "signature": "build123d.CylindricalJoint.relative_to(self, other: 'RigidJoint', *, position: 'float' = None, angle: 'float' = None)",
                    "docstring": "Relative location of CylindricalJoint to RigidJoint\n\nArgs:\n    other (Joint): joint to connect to\n    position (float, optional): linear position. Defaults to linear range min.\n    angle (float, optional): angle in degrees. Defaults to range min.\n\nRaises:\n    TypeError: other must be of type RigidJoint\n    ValueError: position out of range\n    ValueError: angle out of range"
                }
            ],
            "variables": [
                "location",
                "symbol"
            ],
            "docstring": "CylindricalJoint\n\nComponent rotates around and moves along a single axis like a screw.\n\nArgs:\n    label (str): joint label\n    to_part (Union[Solid, Compound], optional): object to attach joint to\n    axis (Axis): axis of rotation and linear motion\n    angle_reference (VectorLike, optional): direction normal to axis defining where\n        angles will be measured from. Defaults to None.\n    linear_range (tuple[float, float], optional): (min,max) position of joint.\n        Defaults to (0, inf).\n    angular_range (tuple[float, float], optional): (min,max) angle of joint.\n        Defaults to (0, 360).\n\nAttributes:\n    axis (Axis): joint axis\n    linear_position (float): linear joint position\n    rotational_position (float): revolute joint angle in degrees\n    angle_reference (Vector): reference for angular positions\n    angular_range (tuple[float,float]): min and max angular position of joint\n    linear_range (tuple[float,float]): min and max positional values\n    relative_axis (Axis): joint axis relative to bound part\n    position (float): joint position\n    angle (float): angle of joint\n\nRaises:\n    ValueError: angle_reference must be normal to axis"
        },
        {
            "name": "build123d.DimensionLine",
            "signature": "build123d.DimensionLine(path: Union[build123d.topology.Wire, build123d.topology.Edge, list[Union[build123d.geometry.Vector, build123d.topology.Vertex, tuple[float, float, float]]]], draft: build123d.drafting.Draft = None, sketch: build123d.topology.Sketch = None, label: str = None, arrows: tuple[bool, bool] = (True, True), tolerance: Union[float, tuple[float, float]] = None, label_angle: bool = False, mode: build123d.build_enums.Mode = <Mode.ADD>) -> build123d.topology.Sketch",
            "methods": [
                {
                    "name": "build123d.DimensionLine.bounding_box",
                    "signature": "build123d.DimensionLine.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.DimensionLine.cast",
                    "signature": "build123d.DimensionLine.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.DimensionLine.center",
                    "signature": "build123d.DimensionLine.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.DimensionLine.chamfer",
                    "signature": "build123d.DimensionLine.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.DimensionLine.clean",
                    "signature": "build123d.DimensionLine.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.DimensionLine.closest_points",
                    "signature": "build123d.DimensionLine.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.DimensionLine.combined_center",
                    "signature": "build123d.DimensionLine.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.DimensionLine.compound",
                    "signature": "build123d.DimensionLine.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.DimensionLine.compounds",
                    "signature": "build123d.DimensionLine.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.DimensionLine.compute_mass",
                    "signature": "build123d.DimensionLine.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.copy",
                    "signature": "build123d.DimensionLine.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.DimensionLine.copy_attributes_to",
                    "signature": "build123d.DimensionLine.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.DimensionLine.cut",
                    "signature": "build123d.DimensionLine.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.distance",
                    "signature": "build123d.DimensionLine.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.distance_to",
                    "signature": "build123d.DimensionLine.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.DimensionLine.distance_to_with_closest_points",
                    "signature": "build123d.DimensionLine.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.DimensionLine.distances",
                    "signature": "build123d.DimensionLine.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.do_children_intersect",
                    "signature": "build123d.DimensionLine.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.DimensionLine.dprism",
                    "signature": "build123d.DimensionLine.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.DimensionLine.edge",
                    "signature": "build123d.DimensionLine.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.DimensionLine.edges",
                    "signature": "build123d.DimensionLine.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.DimensionLine.export_brep",
                    "signature": "build123d.DimensionLine.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.export_step",
                    "signature": "build123d.DimensionLine.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.DimensionLine.export_stl",
                    "signature": "build123d.DimensionLine.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.DimensionLine.extrude",
                    "signature": "build123d.DimensionLine.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.DimensionLine.face",
                    "signature": "build123d.DimensionLine.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.DimensionLine.faces",
                    "signature": "build123d.DimensionLine.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.DimensionLine.faces_intersected_by_axis",
                    "signature": "build123d.DimensionLine.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.DimensionLine.fillet",
                    "signature": "build123d.DimensionLine.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.DimensionLine.find_intersection",
                    "signature": "build123d.DimensionLine.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.DimensionLine.find_intersection_points",
                    "signature": "build123d.DimensionLine.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.DimensionLine.first_level_shapes",
                    "signature": "build123d.DimensionLine.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.DimensionLine.fix",
                    "signature": "build123d.DimensionLine.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.DimensionLine.fuse",
                    "signature": "build123d.DimensionLine.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.get_type",
                    "signature": "build123d.DimensionLine.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.DimensionLine.hash_code",
                    "signature": "build123d.DimensionLine.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.hollow",
                    "signature": "build123d.DimensionLine.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.DimensionLine.intersect",
                    "signature": "build123d.DimensionLine.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.is_equal",
                    "signature": "build123d.DimensionLine.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.is_inside",
                    "signature": "build123d.DimensionLine.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.DimensionLine.is_null",
                    "signature": "build123d.DimensionLine.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.is_same",
                    "signature": "build123d.DimensionLine.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.is_valid",
                    "signature": "build123d.DimensionLine.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.iter_path_reverse",
                    "signature": "build123d.DimensionLine.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.DimensionLine.locate",
                    "signature": "build123d.DimensionLine.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.located",
                    "signature": "build123d.DimensionLine.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.DimensionLine.make_compound",
                    "signature": "build123d.DimensionLine.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.make_text",
                    "signature": "build123d.DimensionLine.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.DimensionLine.make_triad",
                    "signature": "build123d.DimensionLine.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.DimensionLine.max_fillet",
                    "signature": "build123d.DimensionLine.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.DimensionLine.mesh",
                    "signature": "build123d.DimensionLine.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.mirror",
                    "signature": "build123d.DimensionLine.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.DimensionLine.move",
                    "signature": "build123d.DimensionLine.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.moved",
                    "signature": "build123d.DimensionLine.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.DimensionLine.offset_3d",
                    "signature": "build123d.DimensionLine.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.DimensionLine.project_faces",
                    "signature": "build123d.DimensionLine.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.DimensionLine.project_to_viewport",
                    "signature": "build123d.DimensionLine.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.DimensionLine.relocate",
                    "signature": "build123d.DimensionLine.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.DimensionLine.rotate",
                    "signature": "build123d.DimensionLine.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.DimensionLine.scale",
                    "signature": "build123d.DimensionLine.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.shape_type",
                    "signature": "build123d.DimensionLine.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.DimensionLine.shell",
                    "signature": "build123d.DimensionLine.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.DimensionLine.shells",
                    "signature": "build123d.DimensionLine.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.DimensionLine.show_topology",
                    "signature": "build123d.DimensionLine.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.DimensionLine.solid",
                    "signature": "build123d.DimensionLine.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.DimensionLine.solids",
                    "signature": "build123d.DimensionLine.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.DimensionLine.split",
                    "signature": "build123d.DimensionLine.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.DimensionLine.split_by_perimeter",
                    "signature": "build123d.DimensionLine.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.DimensionLine.tessellate",
                    "signature": "build123d.DimensionLine.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.DimensionLine.to_arcs",
                    "signature": "build123d.DimensionLine.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.DimensionLine.to_splines",
                    "signature": "build123d.DimensionLine.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.DimensionLine.to_vtk_poly_data",
                    "signature": "build123d.DimensionLine.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.DimensionLine.transform_geometry",
                    "signature": "build123d.DimensionLine.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.DimensionLine.transform_shape",
                    "signature": "build123d.DimensionLine.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.DimensionLine.transformed",
                    "signature": "build123d.DimensionLine.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.DimensionLine.translate",
                    "signature": "build123d.DimensionLine.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.DimensionLine.unwrap",
                    "signature": "build123d.DimensionLine.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.DimensionLine.vertex",
                    "signature": "build123d.DimensionLine.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.DimensionLine.vertices",
                    "signature": "build123d.DimensionLine.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.DimensionLine.wire",
                    "signature": "build123d.DimensionLine.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.DimensionLine.wires",
                    "signature": "build123d.DimensionLine.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: DimensionLine\n\nCreate a dimension line typically for internal measurements.\nTypically used for (but not restricted to) inside dimensions, a dimension line often\nas arrows on either side of a dimension or label.\n\nThere are three options depending on the size of the text and length\nof the dimension line:\nType 1) The label and arrows fit within the length of the path\nType 2) The text fit within the path and the arrows go outside\nType 3) Neither the text nor the arrows fit within the path\n\nArgs:\n    path (PathDescriptor): a very general type of input used to describe the path the\n        dimension line will follow.\n    draft (Draft): instance of Draft dataclass\n    sketch (Sketch): the Sketch being created to check for possible overlaps. In builder\n        mode the active Sketch will be used if None is provided.\n    label (str, optional): a text string which will replace the length (or\n        arc length) that would otherwise be extracted from the provided path. Providing\n        a label is useful when illustrating a parameterized input where the name of an\n        argument is desired not an actual measurement. Defaults to None.\n    arrows (tuple[bool, bool], optional): a pair of boolean values controlling the placement\n        of the start and end arrows. Defaults to (True, True).\n    tolerance (Union[float, tuple[float, float]], optional): an optional tolerance\n        value to add to the extracted length value. If a single tolerance value is provided\n        it is shown as \u00b1 the provided value while a pair of values are shown as\n        separate + and - values. Defaults to None.\n    label_angle (bool, optional): a flag indicating that instead of an extracted length value,\n        the size of the circular arc extracted from the path should be displayed in degrees.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: Only 2 points allowed for dimension lines\n    ValueError: No output - no arrows selected"
        },
        {
            "name": "build123d.DotLength",
            "signature": "build123d.DotLength()",
            "methods": [],
            "variables": [
                "INKSCAPE_COMPAT",
                "QCAD_IMPERIAL",
                "TRUE_DOT",
                "name",
                "value"
            ],
            "docstring": "Line type dash pattern dot widths, expressed in tenths of an inch."
        },
        {
            "name": "build123d.DoubleTangentArc",
            "signature": "build123d.DoubleTangentArc(pnt: 'VectorLike', tangent: 'VectorLike', other: 'Union[Curve, Edge, Wire]', keep: 'Keep' = <Keep.TOP>, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.DoubleTangentArc.bounding_box",
                    "signature": "build123d.DoubleTangentArc.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.cast",
                    "signature": "build123d.DoubleTangentArc.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.DoubleTangentArc.center",
                    "signature": "build123d.DoubleTangentArc.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.DoubleTangentArc.clean",
                    "signature": "build123d.DoubleTangentArc.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.DoubleTangentArc.close",
                    "signature": "build123d.DoubleTangentArc.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.DoubleTangentArc.closest_points",
                    "signature": "build123d.DoubleTangentArc.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.DoubleTangentArc.combined_center",
                    "signature": "build123d.DoubleTangentArc.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.DoubleTangentArc.common_plane",
                    "signature": "build123d.DoubleTangentArc.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.DoubleTangentArc.compound",
                    "signature": "build123d.DoubleTangentArc.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.DoubleTangentArc.compounds",
                    "signature": "build123d.DoubleTangentArc.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.compute_mass",
                    "signature": "build123d.DoubleTangentArc.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.copy",
                    "signature": "build123d.DoubleTangentArc.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.DoubleTangentArc.copy_attributes_to",
                    "signature": "build123d.DoubleTangentArc.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.DoubleTangentArc.cut",
                    "signature": "build123d.DoubleTangentArc.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.distance",
                    "signature": "build123d.DoubleTangentArc.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.distance_to",
                    "signature": "build123d.DoubleTangentArc.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.DoubleTangentArc.distance_to_with_closest_points",
                    "signature": "build123d.DoubleTangentArc.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.distances",
                    "signature": "build123d.DoubleTangentArc.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.distribute_locations",
                    "signature": "build123d.DoubleTangentArc.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.DoubleTangentArc.edge",
                    "signature": "build123d.DoubleTangentArc.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.DoubleTangentArc.edges",
                    "signature": "build123d.DoubleTangentArc.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.end_point",
                    "signature": "build123d.DoubleTangentArc.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.DoubleTangentArc.export_brep",
                    "signature": "build123d.DoubleTangentArc.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.export_step",
                    "signature": "build123d.DoubleTangentArc.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.DoubleTangentArc.export_stl",
                    "signature": "build123d.DoubleTangentArc.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.DoubleTangentArc.extrude",
                    "signature": "build123d.DoubleTangentArc.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.face",
                    "signature": "build123d.DoubleTangentArc.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.DoubleTangentArc.faces",
                    "signature": "build123d.DoubleTangentArc.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.faces_intersected_by_axis",
                    "signature": "build123d.DoubleTangentArc.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.DoubleTangentArc.find_intersection",
                    "signature": "build123d.DoubleTangentArc.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.DoubleTangentArc.find_intersection_points",
                    "signature": "build123d.DoubleTangentArc.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.DoubleTangentArc.find_tangent",
                    "signature": "build123d.DoubleTangentArc.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.DoubleTangentArc.fix",
                    "signature": "build123d.DoubleTangentArc.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.DoubleTangentArc.fuse",
                    "signature": "build123d.DoubleTangentArc.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.hash_code",
                    "signature": "build123d.DoubleTangentArc.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.intersect",
                    "signature": "build123d.DoubleTangentArc.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.DoubleTangentArc.is_equal",
                    "signature": "build123d.DoubleTangentArc.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.is_null",
                    "signature": "build123d.DoubleTangentArc.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.is_same",
                    "signature": "build123d.DoubleTangentArc.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.is_valid",
                    "signature": "build123d.DoubleTangentArc.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.iter_path_reverse",
                    "signature": "build123d.DoubleTangentArc.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.DoubleTangentArc.locate",
                    "signature": "build123d.DoubleTangentArc.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.located",
                    "signature": "build123d.DoubleTangentArc.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.DoubleTangentArc.location_at",
                    "signature": "build123d.DoubleTangentArc.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.DoubleTangentArc.locations",
                    "signature": "build123d.DoubleTangentArc.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.DoubleTangentArc.make_bezier",
                    "signature": "build123d.DoubleTangentArc.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.DoubleTangentArc.make_circle",
                    "signature": "build123d.DoubleTangentArc.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.DoubleTangentArc.make_ellipse",
                    "signature": "build123d.DoubleTangentArc.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.DoubleTangentArc.make_helix",
                    "signature": "build123d.DoubleTangentArc.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.DoubleTangentArc.make_line",
                    "signature": "build123d.DoubleTangentArc.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.DoubleTangentArc.make_mid_way",
                    "signature": "build123d.DoubleTangentArc.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.DoubleTangentArc.make_spline",
                    "signature": "build123d.DoubleTangentArc.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.DoubleTangentArc.make_spline_approx",
                    "signature": "build123d.DoubleTangentArc.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.DoubleTangentArc.make_tangent_arc",
                    "signature": "build123d.DoubleTangentArc.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.DoubleTangentArc.make_three_point_arc",
                    "signature": "build123d.DoubleTangentArc.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.DoubleTangentArc.mesh",
                    "signature": "build123d.DoubleTangentArc.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.mirror",
                    "signature": "build123d.DoubleTangentArc.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.move",
                    "signature": "build123d.DoubleTangentArc.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.moved",
                    "signature": "build123d.DoubleTangentArc.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.DoubleTangentArc.normal",
                    "signature": "build123d.DoubleTangentArc.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.offset_2d",
                    "signature": "build123d.DoubleTangentArc.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.DoubleTangentArc.param_at",
                    "signature": "build123d.DoubleTangentArc.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.DoubleTangentArc.param_at_point",
                    "signature": "build123d.DoubleTangentArc.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.DoubleTangentArc.perpendicular_line",
                    "signature": "build123d.DoubleTangentArc.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.DoubleTangentArc.position_at",
                    "signature": "build123d.DoubleTangentArc.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.DoubleTangentArc.positions",
                    "signature": "build123d.DoubleTangentArc.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.DoubleTangentArc.project",
                    "signature": "build123d.DoubleTangentArc.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.project_faces",
                    "signature": "build123d.DoubleTangentArc.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.DoubleTangentArc.project_to_shape",
                    "signature": "build123d.DoubleTangentArc.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.DoubleTangentArc.project_to_viewport",
                    "signature": "build123d.DoubleTangentArc.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.DoubleTangentArc.relocate",
                    "signature": "build123d.DoubleTangentArc.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.DoubleTangentArc.reversed",
                    "signature": "build123d.DoubleTangentArc.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.DoubleTangentArc.rotate",
                    "signature": "build123d.DoubleTangentArc.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.DoubleTangentArc.scale",
                    "signature": "build123d.DoubleTangentArc.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.shape_type",
                    "signature": "build123d.DoubleTangentArc.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.DoubleTangentArc.shell",
                    "signature": "build123d.DoubleTangentArc.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.DoubleTangentArc.shells",
                    "signature": "build123d.DoubleTangentArc.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.show_topology",
                    "signature": "build123d.DoubleTangentArc.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.DoubleTangentArc.solid",
                    "signature": "build123d.DoubleTangentArc.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.DoubleTangentArc.solids",
                    "signature": "build123d.DoubleTangentArc.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.split",
                    "signature": "build123d.DoubleTangentArc.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.DoubleTangentArc.split_by_perimeter",
                    "signature": "build123d.DoubleTangentArc.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.DoubleTangentArc.start_point",
                    "signature": "build123d.DoubleTangentArc.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.DoubleTangentArc.tangent_angle_at",
                    "signature": "build123d.DoubleTangentArc.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.DoubleTangentArc.tangent_at",
                    "signature": "build123d.DoubleTangentArc.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.DoubleTangentArc.tessellate",
                    "signature": "build123d.DoubleTangentArc.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.DoubleTangentArc.to_arcs",
                    "signature": "build123d.DoubleTangentArc.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.DoubleTangentArc.to_axis",
                    "signature": "build123d.DoubleTangentArc.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.DoubleTangentArc.to_splines",
                    "signature": "build123d.DoubleTangentArc.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.DoubleTangentArc.to_vtk_poly_data",
                    "signature": "build123d.DoubleTangentArc.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.DoubleTangentArc.to_wire",
                    "signature": "build123d.DoubleTangentArc.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.DoubleTangentArc.transform_geometry",
                    "signature": "build123d.DoubleTangentArc.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.DoubleTangentArc.transform_shape",
                    "signature": "build123d.DoubleTangentArc.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.DoubleTangentArc.transformed",
                    "signature": "build123d.DoubleTangentArc.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.DoubleTangentArc.translate",
                    "signature": "build123d.DoubleTangentArc.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.DoubleTangentArc.trim",
                    "signature": "build123d.DoubleTangentArc.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.DoubleTangentArc.trim_to_length",
                    "signature": "build123d.DoubleTangentArc.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.DoubleTangentArc.vertex",
                    "signature": "build123d.DoubleTangentArc.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.DoubleTangentArc.vertices",
                    "signature": "build123d.DoubleTangentArc.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.DoubleTangentArc.wire",
                    "signature": "build123d.DoubleTangentArc.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.DoubleTangentArc.wires",
                    "signature": "build123d.DoubleTangentArc.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Double Tangent Arc\n\nCreate an arc defined by a point/tangent pair and another line which the other end\nis tangent to.\n\nContains a solver.\n\nArgs:\n    pnt (VectorLike): starting point of tangent arc\n    tangent (VectorLike): tangent at starting point of tangent arc\n    other (Union[Curve, Edge, Wire]): reference line\n    keep (Keep, optional): selector for which arc to keep when two arcs are\n        possible. The arc generated with TOP or BOTTOM depends on the geometry\n        and isn't necessarily easy to predict. Defaults to Keep.TOP.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    RunTimeError: no double tangent arcs found"
        },
        {
            "name": "build123d.Draft",
            "signature": "build123d.Draft(font_size: float = 5.0, font: str = 'Arial', font_style: build123d.build_enums.FontStyle = <FontStyle.REGULAR>, head_type: build123d.build_enums.HeadType = <HeadType.CURVED>, arrow_length: float = 3.0, line_width: float = 0.5, pad_around_text: float = 2.0, unit: build123d.build_enums.Unit = <Unit.MM>, number_display: build123d.build_enums.NumberDisplay = <NumberDisplay.DECIMAL>, display_units: bool = True, decimal_precision: int = 2, fractional_precision: int = 64, extension_gap: float = 2.0) -> None",
            "methods": [],
            "variables": [
                "arrow_length",
                "decimal_precision",
                "display_units",
                "extension_gap",
                "font",
                "font_size",
                "font_style",
                "fractional_precision",
                "head_type",
                "is_metric",
                "line_width",
                "number_display",
                "pad_around_text",
                "unit",
                "unit_LUT"
            ],
            "docstring": "Draft\n\nDocumenting build123d designs with dimension and extension lines as well as callouts.\n\n\nArgs:\n    font_size (float): size of the text in dimension lines and callouts. Defaults to 5.0.\n    font (str): font to use for text. Defaults to \"Arial\".\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    head_type (HeadType, optional): arrow head shape. Defaults to HeadType.CURVED.\n    arrow_length (float): arrow head length. Defaults to 3.0.\n    line_width (float): thickness of all lines. Defaults to 0.5.\n    pad_around_text (float): amount of padding around text. Defaults to 2.0.\n    unit (Unit): measurement unit. Defaults to Unit.MM.\n    number_display (NumberDisplay): numbers as decimal or fractions.\n        Default to NumberDisplay.DECIMAL.\n    display_units (bool): control the display of units with numbers. Defaults to True.\n    decimal_precision (int): number of decimal places when displaying numbers. Defaults to 2.\n    fractional_precision (int): maximum fraction denominator - must be a factor of 2.\n        Defaults to 64.\n    extension_gap (float): gap between the point and start of extension line in extension_line.\n        Defaults to 2.0."
        },
        {
            "name": "build123d.Drawing",
            "signature": "build123d.Drawing(shape: build123d.topology.Shape, *, look_at: Union[build123d.geometry.Vector, tuple[float, float], tuple[float, float, float], Iterable[float]] = None, look_from: Union[build123d.geometry.Vector, tuple[float, float], tuple[float, float, float], Iterable[float]] = (1, -1, 1), look_up: Union[build123d.geometry.Vector, tuple[float, float], tuple[float, float, float], Iterable[float]] = (0, 0, 1), with_hidden: bool = True, focus: Optional[float] = None)",
            "methods": [],
            "variables": [],
            "docstring": "A base drawing object"
        },
        {
            "name": "build123d.Edge",
            "signature": "build123d.Edge(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Edge.bounding_box",
                    "signature": "build123d.Edge.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Edge.cast",
                    "signature": "build123d.Edge.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Edge.center",
                    "signature": "build123d.Edge.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Edge.clean",
                    "signature": "build123d.Edge.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Edge.close",
                    "signature": "build123d.Edge.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.Edge.closest_points",
                    "signature": "build123d.Edge.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Edge.combined_center",
                    "signature": "build123d.Edge.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Edge.common_plane",
                    "signature": "build123d.Edge.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.Edge.compound",
                    "signature": "build123d.Edge.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Edge.compounds",
                    "signature": "build123d.Edge.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Edge.compute_mass",
                    "signature": "build123d.Edge.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.copy",
                    "signature": "build123d.Edge.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Edge.copy_attributes_to",
                    "signature": "build123d.Edge.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Edge.cut",
                    "signature": "build123d.Edge.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.distance",
                    "signature": "build123d.Edge.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.distance_to",
                    "signature": "build123d.Edge.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Edge.distance_to_with_closest_points",
                    "signature": "build123d.Edge.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Edge.distances",
                    "signature": "build123d.Edge.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.distribute_locations",
                    "signature": "build123d.Edge.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.Edge.edge",
                    "signature": "build123d.Edge.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Edge.edges",
                    "signature": "build123d.Edge.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Edge.end_point",
                    "signature": "build123d.Edge.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Edge.export_brep",
                    "signature": "build123d.Edge.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.export_step",
                    "signature": "build123d.Edge.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Edge.export_stl",
                    "signature": "build123d.Edge.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Edge.extrude",
                    "signature": "build123d.Edge.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Edge.face",
                    "signature": "build123d.Edge.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Edge.faces",
                    "signature": "build123d.Edge.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Edge.faces_intersected_by_axis",
                    "signature": "build123d.Edge.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Edge.find_intersection",
                    "signature": "build123d.Edge.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Edge.find_intersection_points",
                    "signature": "build123d.Edge.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.Edge.find_tangent",
                    "signature": "build123d.Edge.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.Edge.fix",
                    "signature": "build123d.Edge.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Edge.fuse",
                    "signature": "build123d.Edge.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Edge.hash_code",
                    "signature": "build123d.Edge.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.intersect",
                    "signature": "build123d.Edge.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Edge.is_equal",
                    "signature": "build123d.Edge.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.is_null",
                    "signature": "build123d.Edge.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.is_same",
                    "signature": "build123d.Edge.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.is_valid",
                    "signature": "build123d.Edge.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.iter_path_reverse",
                    "signature": "build123d.Edge.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Edge.locate",
                    "signature": "build123d.Edge.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.located",
                    "signature": "build123d.Edge.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Edge.location_at",
                    "signature": "build123d.Edge.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.Edge.locations",
                    "signature": "build123d.Edge.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.Edge.make_bezier",
                    "signature": "build123d.Edge.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.Edge.make_circle",
                    "signature": "build123d.Edge.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.Edge.make_ellipse",
                    "signature": "build123d.Edge.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.Edge.make_helix",
                    "signature": "build123d.Edge.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.Edge.make_line",
                    "signature": "build123d.Edge.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.Edge.make_mid_way",
                    "signature": "build123d.Edge.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.Edge.make_spline",
                    "signature": "build123d.Edge.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.Edge.make_spline_approx",
                    "signature": "build123d.Edge.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.Edge.make_tangent_arc",
                    "signature": "build123d.Edge.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.Edge.make_three_point_arc",
                    "signature": "build123d.Edge.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.Edge.mesh",
                    "signature": "build123d.Edge.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.mirror",
                    "signature": "build123d.Edge.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Edge.move",
                    "signature": "build123d.Edge.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.moved",
                    "signature": "build123d.Edge.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Edge.normal",
                    "signature": "build123d.Edge.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.offset_2d",
                    "signature": "build123d.Edge.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.Edge.param_at",
                    "signature": "build123d.Edge.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.Edge.param_at_point",
                    "signature": "build123d.Edge.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.Edge.perpendicular_line",
                    "signature": "build123d.Edge.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.Edge.position_at",
                    "signature": "build123d.Edge.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.Edge.positions",
                    "signature": "build123d.Edge.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.Edge.project",
                    "signature": "build123d.Edge.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.project_faces",
                    "signature": "build123d.Edge.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Edge.project_to_shape",
                    "signature": "build123d.Edge.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.Edge.project_to_viewport",
                    "signature": "build123d.Edge.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Edge.relocate",
                    "signature": "build123d.Edge.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Edge.reversed",
                    "signature": "build123d.Edge.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.Edge.rotate",
                    "signature": "build123d.Edge.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Edge.scale",
                    "signature": "build123d.Edge.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.shape_type",
                    "signature": "build123d.Edge.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Edge.shell",
                    "signature": "build123d.Edge.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Edge.shells",
                    "signature": "build123d.Edge.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Edge.show_topology",
                    "signature": "build123d.Edge.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Edge.solid",
                    "signature": "build123d.Edge.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Edge.solids",
                    "signature": "build123d.Edge.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Edge.split",
                    "signature": "build123d.Edge.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Edge.split_by_perimeter",
                    "signature": "build123d.Edge.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Edge.start_point",
                    "signature": "build123d.Edge.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Edge.tangent_angle_at",
                    "signature": "build123d.Edge.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.Edge.tangent_at",
                    "signature": "build123d.Edge.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.Edge.tessellate",
                    "signature": "build123d.Edge.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Edge.to_arcs",
                    "signature": "build123d.Edge.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Edge.to_axis",
                    "signature": "build123d.Edge.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.Edge.to_splines",
                    "signature": "build123d.Edge.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Edge.to_vtk_poly_data",
                    "signature": "build123d.Edge.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Edge.to_wire",
                    "signature": "build123d.Edge.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.Edge.transform_geometry",
                    "signature": "build123d.Edge.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Edge.transform_shape",
                    "signature": "build123d.Edge.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Edge.transformed",
                    "signature": "build123d.Edge.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Edge.translate",
                    "signature": "build123d.Edge.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Edge.trim",
                    "signature": "build123d.Edge.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.Edge.trim_to_length",
                    "signature": "build123d.Edge.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.Edge.vertex",
                    "signature": "build123d.Edge.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Edge.vertices",
                    "signature": "build123d.Edge.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Edge.wire",
                    "signature": "build123d.Edge.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Edge.wires",
                    "signature": "build123d.Edge.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "An Edge in build123d is a fundamental element in the topological data structure\nrepresenting a one-dimensional geometric entity within a 3D model. It encapsulates\ninformation about a curve, which could be a line, arc, or other parametrically\ndefined shape. Edge is crucial in for precise modeling and manipulation of curves,\nfacilitating operations like filleting, chamfering, and Boolean operations. It\nserves as a building block for constructing complex structures, such as wires\nand faces."
        },
        {
            "name": "build123d.Ellipse",
            "signature": "build123d.Ellipse(x_radius: 'float', y_radius: 'float', rotation: 'float' = 0, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Ellipse.bounding_box",
                    "signature": "build123d.Ellipse.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Ellipse.cast",
                    "signature": "build123d.Ellipse.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Ellipse.center",
                    "signature": "build123d.Ellipse.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Ellipse.chamfer",
                    "signature": "build123d.Ellipse.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Ellipse.clean",
                    "signature": "build123d.Ellipse.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Ellipse.closest_points",
                    "signature": "build123d.Ellipse.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Ellipse.combined_center",
                    "signature": "build123d.Ellipse.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Ellipse.compound",
                    "signature": "build123d.Ellipse.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Ellipse.compounds",
                    "signature": "build123d.Ellipse.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Ellipse.compute_mass",
                    "signature": "build123d.Ellipse.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.copy",
                    "signature": "build123d.Ellipse.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Ellipse.copy_attributes_to",
                    "signature": "build123d.Ellipse.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Ellipse.cut",
                    "signature": "build123d.Ellipse.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.distance",
                    "signature": "build123d.Ellipse.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.distance_to",
                    "signature": "build123d.Ellipse.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Ellipse.distance_to_with_closest_points",
                    "signature": "build123d.Ellipse.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Ellipse.distances",
                    "signature": "build123d.Ellipse.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.do_children_intersect",
                    "signature": "build123d.Ellipse.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Ellipse.dprism",
                    "signature": "build123d.Ellipse.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Ellipse.edge",
                    "signature": "build123d.Ellipse.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Ellipse.edges",
                    "signature": "build123d.Ellipse.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Ellipse.export_brep",
                    "signature": "build123d.Ellipse.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.export_step",
                    "signature": "build123d.Ellipse.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Ellipse.export_stl",
                    "signature": "build123d.Ellipse.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Ellipse.extrude",
                    "signature": "build123d.Ellipse.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Ellipse.face",
                    "signature": "build123d.Ellipse.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Ellipse.faces",
                    "signature": "build123d.Ellipse.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Ellipse.faces_intersected_by_axis",
                    "signature": "build123d.Ellipse.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Ellipse.fillet",
                    "signature": "build123d.Ellipse.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Ellipse.find_intersection",
                    "signature": "build123d.Ellipse.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Ellipse.find_intersection_points",
                    "signature": "build123d.Ellipse.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Ellipse.first_level_shapes",
                    "signature": "build123d.Ellipse.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Ellipse.fix",
                    "signature": "build123d.Ellipse.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Ellipse.fuse",
                    "signature": "build123d.Ellipse.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.get_type",
                    "signature": "build123d.Ellipse.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Ellipse.hash_code",
                    "signature": "build123d.Ellipse.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.hollow",
                    "signature": "build123d.Ellipse.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Ellipse.intersect",
                    "signature": "build123d.Ellipse.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.is_equal",
                    "signature": "build123d.Ellipse.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.is_inside",
                    "signature": "build123d.Ellipse.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Ellipse.is_null",
                    "signature": "build123d.Ellipse.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.is_same",
                    "signature": "build123d.Ellipse.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.is_valid",
                    "signature": "build123d.Ellipse.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.iter_path_reverse",
                    "signature": "build123d.Ellipse.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Ellipse.locate",
                    "signature": "build123d.Ellipse.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.located",
                    "signature": "build123d.Ellipse.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Ellipse.make_compound",
                    "signature": "build123d.Ellipse.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.make_text",
                    "signature": "build123d.Ellipse.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Ellipse.make_triad",
                    "signature": "build123d.Ellipse.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Ellipse.max_fillet",
                    "signature": "build123d.Ellipse.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Ellipse.mesh",
                    "signature": "build123d.Ellipse.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.mirror",
                    "signature": "build123d.Ellipse.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Ellipse.move",
                    "signature": "build123d.Ellipse.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.moved",
                    "signature": "build123d.Ellipse.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Ellipse.offset_3d",
                    "signature": "build123d.Ellipse.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Ellipse.project_faces",
                    "signature": "build123d.Ellipse.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Ellipse.project_to_viewport",
                    "signature": "build123d.Ellipse.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Ellipse.relocate",
                    "signature": "build123d.Ellipse.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Ellipse.rotate",
                    "signature": "build123d.Ellipse.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Ellipse.scale",
                    "signature": "build123d.Ellipse.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.shape_type",
                    "signature": "build123d.Ellipse.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Ellipse.shell",
                    "signature": "build123d.Ellipse.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Ellipse.shells",
                    "signature": "build123d.Ellipse.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Ellipse.show_topology",
                    "signature": "build123d.Ellipse.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Ellipse.solid",
                    "signature": "build123d.Ellipse.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Ellipse.solids",
                    "signature": "build123d.Ellipse.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Ellipse.split",
                    "signature": "build123d.Ellipse.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Ellipse.split_by_perimeter",
                    "signature": "build123d.Ellipse.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Ellipse.tessellate",
                    "signature": "build123d.Ellipse.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Ellipse.to_arcs",
                    "signature": "build123d.Ellipse.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Ellipse.to_splines",
                    "signature": "build123d.Ellipse.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Ellipse.to_vtk_poly_data",
                    "signature": "build123d.Ellipse.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Ellipse.transform_geometry",
                    "signature": "build123d.Ellipse.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Ellipse.transform_shape",
                    "signature": "build123d.Ellipse.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Ellipse.transformed",
                    "signature": "build123d.Ellipse.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Ellipse.translate",
                    "signature": "build123d.Ellipse.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Ellipse.unwrap",
                    "signature": "build123d.Ellipse.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Ellipse.vertex",
                    "signature": "build123d.Ellipse.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Ellipse.vertices",
                    "signature": "build123d.Ellipse.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Ellipse.wire",
                    "signature": "build123d.Ellipse.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Ellipse.wires",
                    "signature": "build123d.Ellipse.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Ellipse\n\nAdd ellipse(s) to sketch.\n\nArgs:\n    x_radius (float): horizontal radius\n    y_radius (float): vertical radius\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.EllipticalCenterArc",
            "signature": "build123d.EllipticalCenterArc(center: 'VectorLike', x_radius: 'float', y_radius: 'float', start_angle: 'float' = 0.0, end_angle: 'float' = 90.0, rotation: 'float' = 0.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.EllipticalCenterArc.bounding_box",
                    "signature": "build123d.EllipticalCenterArc.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.cast",
                    "signature": "build123d.EllipticalCenterArc.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.EllipticalCenterArc.center",
                    "signature": "build123d.EllipticalCenterArc.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.EllipticalCenterArc.clean",
                    "signature": "build123d.EllipticalCenterArc.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.EllipticalCenterArc.close",
                    "signature": "build123d.EllipticalCenterArc.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.EllipticalCenterArc.closest_points",
                    "signature": "build123d.EllipticalCenterArc.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.EllipticalCenterArc.combined_center",
                    "signature": "build123d.EllipticalCenterArc.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.EllipticalCenterArc.common_plane",
                    "signature": "build123d.EllipticalCenterArc.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.EllipticalCenterArc.compound",
                    "signature": "build123d.EllipticalCenterArc.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.EllipticalCenterArc.compounds",
                    "signature": "build123d.EllipticalCenterArc.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.compute_mass",
                    "signature": "build123d.EllipticalCenterArc.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.copy",
                    "signature": "build123d.EllipticalCenterArc.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.EllipticalCenterArc.copy_attributes_to",
                    "signature": "build123d.EllipticalCenterArc.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.EllipticalCenterArc.cut",
                    "signature": "build123d.EllipticalCenterArc.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.distance",
                    "signature": "build123d.EllipticalCenterArc.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.distance_to",
                    "signature": "build123d.EllipticalCenterArc.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.EllipticalCenterArc.distance_to_with_closest_points",
                    "signature": "build123d.EllipticalCenterArc.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.distances",
                    "signature": "build123d.EllipticalCenterArc.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.distribute_locations",
                    "signature": "build123d.EllipticalCenterArc.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.EllipticalCenterArc.edge",
                    "signature": "build123d.EllipticalCenterArc.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.EllipticalCenterArc.edges",
                    "signature": "build123d.EllipticalCenterArc.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.end_point",
                    "signature": "build123d.EllipticalCenterArc.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.EllipticalCenterArc.export_brep",
                    "signature": "build123d.EllipticalCenterArc.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.export_step",
                    "signature": "build123d.EllipticalCenterArc.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.EllipticalCenterArc.export_stl",
                    "signature": "build123d.EllipticalCenterArc.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.EllipticalCenterArc.extrude",
                    "signature": "build123d.EllipticalCenterArc.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.face",
                    "signature": "build123d.EllipticalCenterArc.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.EllipticalCenterArc.faces",
                    "signature": "build123d.EllipticalCenterArc.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.faces_intersected_by_axis",
                    "signature": "build123d.EllipticalCenterArc.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.EllipticalCenterArc.find_intersection",
                    "signature": "build123d.EllipticalCenterArc.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.EllipticalCenterArc.find_intersection_points",
                    "signature": "build123d.EllipticalCenterArc.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.EllipticalCenterArc.find_tangent",
                    "signature": "build123d.EllipticalCenterArc.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.EllipticalCenterArc.fix",
                    "signature": "build123d.EllipticalCenterArc.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.EllipticalCenterArc.fuse",
                    "signature": "build123d.EllipticalCenterArc.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.hash_code",
                    "signature": "build123d.EllipticalCenterArc.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.intersect",
                    "signature": "build123d.EllipticalCenterArc.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.EllipticalCenterArc.is_equal",
                    "signature": "build123d.EllipticalCenterArc.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.is_null",
                    "signature": "build123d.EllipticalCenterArc.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.is_same",
                    "signature": "build123d.EllipticalCenterArc.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.is_valid",
                    "signature": "build123d.EllipticalCenterArc.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.iter_path_reverse",
                    "signature": "build123d.EllipticalCenterArc.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.EllipticalCenterArc.locate",
                    "signature": "build123d.EllipticalCenterArc.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.located",
                    "signature": "build123d.EllipticalCenterArc.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.EllipticalCenterArc.location_at",
                    "signature": "build123d.EllipticalCenterArc.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.EllipticalCenterArc.locations",
                    "signature": "build123d.EllipticalCenterArc.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.EllipticalCenterArc.make_bezier",
                    "signature": "build123d.EllipticalCenterArc.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.EllipticalCenterArc.make_circle",
                    "signature": "build123d.EllipticalCenterArc.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.EllipticalCenterArc.make_ellipse",
                    "signature": "build123d.EllipticalCenterArc.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.EllipticalCenterArc.make_helix",
                    "signature": "build123d.EllipticalCenterArc.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.EllipticalCenterArc.make_line",
                    "signature": "build123d.EllipticalCenterArc.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.EllipticalCenterArc.make_mid_way",
                    "signature": "build123d.EllipticalCenterArc.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.EllipticalCenterArc.make_spline",
                    "signature": "build123d.EllipticalCenterArc.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.EllipticalCenterArc.make_spline_approx",
                    "signature": "build123d.EllipticalCenterArc.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.EllipticalCenterArc.make_tangent_arc",
                    "signature": "build123d.EllipticalCenterArc.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.EllipticalCenterArc.make_three_point_arc",
                    "signature": "build123d.EllipticalCenterArc.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.EllipticalCenterArc.mesh",
                    "signature": "build123d.EllipticalCenterArc.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.mirror",
                    "signature": "build123d.EllipticalCenterArc.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.move",
                    "signature": "build123d.EllipticalCenterArc.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.moved",
                    "signature": "build123d.EllipticalCenterArc.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.EllipticalCenterArc.normal",
                    "signature": "build123d.EllipticalCenterArc.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.offset_2d",
                    "signature": "build123d.EllipticalCenterArc.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.EllipticalCenterArc.param_at",
                    "signature": "build123d.EllipticalCenterArc.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.EllipticalCenterArc.param_at_point",
                    "signature": "build123d.EllipticalCenterArc.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.EllipticalCenterArc.perpendicular_line",
                    "signature": "build123d.EllipticalCenterArc.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.EllipticalCenterArc.position_at",
                    "signature": "build123d.EllipticalCenterArc.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.EllipticalCenterArc.positions",
                    "signature": "build123d.EllipticalCenterArc.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.EllipticalCenterArc.project",
                    "signature": "build123d.EllipticalCenterArc.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.project_faces",
                    "signature": "build123d.EllipticalCenterArc.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.EllipticalCenterArc.project_to_shape",
                    "signature": "build123d.EllipticalCenterArc.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.EllipticalCenterArc.project_to_viewport",
                    "signature": "build123d.EllipticalCenterArc.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.EllipticalCenterArc.relocate",
                    "signature": "build123d.EllipticalCenterArc.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.EllipticalCenterArc.reversed",
                    "signature": "build123d.EllipticalCenterArc.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.EllipticalCenterArc.rotate",
                    "signature": "build123d.EllipticalCenterArc.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.EllipticalCenterArc.scale",
                    "signature": "build123d.EllipticalCenterArc.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.shape_type",
                    "signature": "build123d.EllipticalCenterArc.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.EllipticalCenterArc.shell",
                    "signature": "build123d.EllipticalCenterArc.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.EllipticalCenterArc.shells",
                    "signature": "build123d.EllipticalCenterArc.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.show_topology",
                    "signature": "build123d.EllipticalCenterArc.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.EllipticalCenterArc.solid",
                    "signature": "build123d.EllipticalCenterArc.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.EllipticalCenterArc.solids",
                    "signature": "build123d.EllipticalCenterArc.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.split",
                    "signature": "build123d.EllipticalCenterArc.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.EllipticalCenterArc.split_by_perimeter",
                    "signature": "build123d.EllipticalCenterArc.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.EllipticalCenterArc.start_point",
                    "signature": "build123d.EllipticalCenterArc.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.EllipticalCenterArc.tangent_angle_at",
                    "signature": "build123d.EllipticalCenterArc.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.EllipticalCenterArc.tangent_at",
                    "signature": "build123d.EllipticalCenterArc.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.EllipticalCenterArc.tessellate",
                    "signature": "build123d.EllipticalCenterArc.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.EllipticalCenterArc.to_arcs",
                    "signature": "build123d.EllipticalCenterArc.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.EllipticalCenterArc.to_axis",
                    "signature": "build123d.EllipticalCenterArc.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.EllipticalCenterArc.to_splines",
                    "signature": "build123d.EllipticalCenterArc.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.EllipticalCenterArc.to_vtk_poly_data",
                    "signature": "build123d.EllipticalCenterArc.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.EllipticalCenterArc.to_wire",
                    "signature": "build123d.EllipticalCenterArc.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.EllipticalCenterArc.transform_geometry",
                    "signature": "build123d.EllipticalCenterArc.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.EllipticalCenterArc.transform_shape",
                    "signature": "build123d.EllipticalCenterArc.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.EllipticalCenterArc.transformed",
                    "signature": "build123d.EllipticalCenterArc.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.EllipticalCenterArc.translate",
                    "signature": "build123d.EllipticalCenterArc.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalCenterArc.trim",
                    "signature": "build123d.EllipticalCenterArc.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.EllipticalCenterArc.trim_to_length",
                    "signature": "build123d.EllipticalCenterArc.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.EllipticalCenterArc.vertex",
                    "signature": "build123d.EllipticalCenterArc.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.EllipticalCenterArc.vertices",
                    "signature": "build123d.EllipticalCenterArc.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.EllipticalCenterArc.wire",
                    "signature": "build123d.EllipticalCenterArc.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.EllipticalCenterArc.wires",
                    "signature": "build123d.EllipticalCenterArc.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Elliptical Center Arc\n\nMakes an arc of an ellipse from a center point.\n\nArgs:\n    center (VectorLike): ellipse center\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    start_angle (float, optional): Defaults to 0.0.\n    end_angle (float, optional): Defaults to 90.0.\n    rotation (float, optional): amount to rotate arc. Defaults to 0.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.EllipticalStartArc",
            "signature": "build123d.EllipticalStartArc(start: 'VectorLike', end: 'VectorLike', x_radius: 'float', y_radius: 'float', rotation: 'float' = 0.0, large_arc: 'bool' = False, sweep_flag: 'bool' = True, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), mode: 'Mode' = <Mode.ADD>) -> 'Edge'",
            "methods": [
                {
                    "name": "build123d.EllipticalStartArc.bounding_box",
                    "signature": "build123d.EllipticalStartArc.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.cast",
                    "signature": "build123d.EllipticalStartArc.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.EllipticalStartArc.center",
                    "signature": "build123d.EllipticalStartArc.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.EllipticalStartArc.clean",
                    "signature": "build123d.EllipticalStartArc.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.EllipticalStartArc.close",
                    "signature": "build123d.EllipticalStartArc.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.EllipticalStartArc.closest_points",
                    "signature": "build123d.EllipticalStartArc.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.EllipticalStartArc.combined_center",
                    "signature": "build123d.EllipticalStartArc.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.EllipticalStartArc.common_plane",
                    "signature": "build123d.EllipticalStartArc.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.EllipticalStartArc.compound",
                    "signature": "build123d.EllipticalStartArc.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.EllipticalStartArc.compounds",
                    "signature": "build123d.EllipticalStartArc.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.compute_mass",
                    "signature": "build123d.EllipticalStartArc.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.copy",
                    "signature": "build123d.EllipticalStartArc.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.EllipticalStartArc.copy_attributes_to",
                    "signature": "build123d.EllipticalStartArc.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.EllipticalStartArc.cut",
                    "signature": "build123d.EllipticalStartArc.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.distance",
                    "signature": "build123d.EllipticalStartArc.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.distance_to",
                    "signature": "build123d.EllipticalStartArc.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.EllipticalStartArc.distance_to_with_closest_points",
                    "signature": "build123d.EllipticalStartArc.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.distances",
                    "signature": "build123d.EllipticalStartArc.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.distribute_locations",
                    "signature": "build123d.EllipticalStartArc.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.EllipticalStartArc.edge",
                    "signature": "build123d.EllipticalStartArc.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.EllipticalStartArc.edges",
                    "signature": "build123d.EllipticalStartArc.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.end_point",
                    "signature": "build123d.EllipticalStartArc.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.EllipticalStartArc.export_brep",
                    "signature": "build123d.EllipticalStartArc.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.export_step",
                    "signature": "build123d.EllipticalStartArc.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.EllipticalStartArc.export_stl",
                    "signature": "build123d.EllipticalStartArc.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.EllipticalStartArc.extrude",
                    "signature": "build123d.EllipticalStartArc.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.face",
                    "signature": "build123d.EllipticalStartArc.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.EllipticalStartArc.faces",
                    "signature": "build123d.EllipticalStartArc.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.faces_intersected_by_axis",
                    "signature": "build123d.EllipticalStartArc.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.EllipticalStartArc.find_intersection",
                    "signature": "build123d.EllipticalStartArc.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.EllipticalStartArc.find_intersection_points",
                    "signature": "build123d.EllipticalStartArc.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.EllipticalStartArc.find_tangent",
                    "signature": "build123d.EllipticalStartArc.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.EllipticalStartArc.fix",
                    "signature": "build123d.EllipticalStartArc.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.EllipticalStartArc.fuse",
                    "signature": "build123d.EllipticalStartArc.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.hash_code",
                    "signature": "build123d.EllipticalStartArc.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.intersect",
                    "signature": "build123d.EllipticalStartArc.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.EllipticalStartArc.is_equal",
                    "signature": "build123d.EllipticalStartArc.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.is_null",
                    "signature": "build123d.EllipticalStartArc.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.is_same",
                    "signature": "build123d.EllipticalStartArc.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.is_valid",
                    "signature": "build123d.EllipticalStartArc.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.iter_path_reverse",
                    "signature": "build123d.EllipticalStartArc.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.EllipticalStartArc.locate",
                    "signature": "build123d.EllipticalStartArc.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.located",
                    "signature": "build123d.EllipticalStartArc.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.EllipticalStartArc.location_at",
                    "signature": "build123d.EllipticalStartArc.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.EllipticalStartArc.locations",
                    "signature": "build123d.EllipticalStartArc.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.EllipticalStartArc.make_bezier",
                    "signature": "build123d.EllipticalStartArc.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.EllipticalStartArc.make_circle",
                    "signature": "build123d.EllipticalStartArc.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.EllipticalStartArc.make_ellipse",
                    "signature": "build123d.EllipticalStartArc.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.EllipticalStartArc.make_helix",
                    "signature": "build123d.EllipticalStartArc.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.EllipticalStartArc.make_line",
                    "signature": "build123d.EllipticalStartArc.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.EllipticalStartArc.make_mid_way",
                    "signature": "build123d.EllipticalStartArc.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.EllipticalStartArc.make_spline",
                    "signature": "build123d.EllipticalStartArc.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.EllipticalStartArc.make_spline_approx",
                    "signature": "build123d.EllipticalStartArc.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.EllipticalStartArc.make_tangent_arc",
                    "signature": "build123d.EllipticalStartArc.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.EllipticalStartArc.make_three_point_arc",
                    "signature": "build123d.EllipticalStartArc.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.EllipticalStartArc.mesh",
                    "signature": "build123d.EllipticalStartArc.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.mirror",
                    "signature": "build123d.EllipticalStartArc.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.move",
                    "signature": "build123d.EllipticalStartArc.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.moved",
                    "signature": "build123d.EllipticalStartArc.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.EllipticalStartArc.normal",
                    "signature": "build123d.EllipticalStartArc.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.offset_2d",
                    "signature": "build123d.EllipticalStartArc.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.EllipticalStartArc.param_at",
                    "signature": "build123d.EllipticalStartArc.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.EllipticalStartArc.param_at_point",
                    "signature": "build123d.EllipticalStartArc.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.EllipticalStartArc.perpendicular_line",
                    "signature": "build123d.EllipticalStartArc.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.EllipticalStartArc.position_at",
                    "signature": "build123d.EllipticalStartArc.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.EllipticalStartArc.positions",
                    "signature": "build123d.EllipticalStartArc.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.EllipticalStartArc.project",
                    "signature": "build123d.EllipticalStartArc.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.project_faces",
                    "signature": "build123d.EllipticalStartArc.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.EllipticalStartArc.project_to_shape",
                    "signature": "build123d.EllipticalStartArc.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.EllipticalStartArc.project_to_viewport",
                    "signature": "build123d.EllipticalStartArc.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.EllipticalStartArc.relocate",
                    "signature": "build123d.EllipticalStartArc.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.EllipticalStartArc.reversed",
                    "signature": "build123d.EllipticalStartArc.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.EllipticalStartArc.rotate",
                    "signature": "build123d.EllipticalStartArc.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.EllipticalStartArc.scale",
                    "signature": "build123d.EllipticalStartArc.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.shape_type",
                    "signature": "build123d.EllipticalStartArc.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.EllipticalStartArc.shell",
                    "signature": "build123d.EllipticalStartArc.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.EllipticalStartArc.shells",
                    "signature": "build123d.EllipticalStartArc.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.show_topology",
                    "signature": "build123d.EllipticalStartArc.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.EllipticalStartArc.solid",
                    "signature": "build123d.EllipticalStartArc.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.EllipticalStartArc.solids",
                    "signature": "build123d.EllipticalStartArc.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.split",
                    "signature": "build123d.EllipticalStartArc.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.EllipticalStartArc.split_by_perimeter",
                    "signature": "build123d.EllipticalStartArc.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.EllipticalStartArc.start_point",
                    "signature": "build123d.EllipticalStartArc.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.EllipticalStartArc.tangent_angle_at",
                    "signature": "build123d.EllipticalStartArc.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.EllipticalStartArc.tangent_at",
                    "signature": "build123d.EllipticalStartArc.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.EllipticalStartArc.tessellate",
                    "signature": "build123d.EllipticalStartArc.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.EllipticalStartArc.to_arcs",
                    "signature": "build123d.EllipticalStartArc.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.EllipticalStartArc.to_axis",
                    "signature": "build123d.EllipticalStartArc.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.EllipticalStartArc.to_splines",
                    "signature": "build123d.EllipticalStartArc.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.EllipticalStartArc.to_vtk_poly_data",
                    "signature": "build123d.EllipticalStartArc.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.EllipticalStartArc.to_wire",
                    "signature": "build123d.EllipticalStartArc.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.EllipticalStartArc.transform_geometry",
                    "signature": "build123d.EllipticalStartArc.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.EllipticalStartArc.transform_shape",
                    "signature": "build123d.EllipticalStartArc.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.EllipticalStartArc.transformed",
                    "signature": "build123d.EllipticalStartArc.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.EllipticalStartArc.translate",
                    "signature": "build123d.EllipticalStartArc.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.EllipticalStartArc.trim",
                    "signature": "build123d.EllipticalStartArc.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.EllipticalStartArc.trim_to_length",
                    "signature": "build123d.EllipticalStartArc.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.EllipticalStartArc.vertex",
                    "signature": "build123d.EllipticalStartArc.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.EllipticalStartArc.vertices",
                    "signature": "build123d.EllipticalStartArc.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.EllipticalStartArc.wire",
                    "signature": "build123d.EllipticalStartArc.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.EllipticalStartArc.wires",
                    "signature": "build123d.EllipticalStartArc.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Elliptical Start Arc\n\nMakes an arc of an ellipse from the start point.\n\nArgs:\n    start (VectorLike): initial point of arc\n    end (VectorLike): final point of arc\n    x_radius (float): semi-major radius\n    y_radius (float): semi-minor radius\n    rotation (float, optional): the angle from the x-axis of the plane to the x-axis\n        of the ellipse. Defaults to 0.0.\n    large_arc (bool, optional): True if the arc spans greater than 180 degrees.\n        Defaults to True.\n    sweep_flag (bool, optional): False if the line joining center to arc sweeps through\n        decreasing angles, or True if it sweeps through increasing angles. Defaults to True.\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Export2D",
            "signature": "build123d.Export2D()",
            "methods": [],
            "variables": [
                "DEFAULT_COLOR_INDEX",
                "DEFAULT_LINE_TYPE",
                "DEFAULT_LINE_WEIGHT",
                "LINETYPE_DEFS",
                "LTYPE_SCALE",
                "PARAMETRIC_TOLERANCE"
            ],
            "docstring": "Base class for 2D exporters (DXF, SVG)."
        },
        {
            "name": "build123d.ExportDXF",
            "signature": "build123d.ExportDXF(version: str = 'AC1027', unit: build123d.build_enums.Unit = <Unit.MM>, color: Optional[build123d.exporters.ColorIndex] = None, line_weight: Optional[float] = None, line_type: Optional[build123d.exporters.LineType] = None)",
            "methods": [
                {
                    "name": "build123d.ExportDXF.add_layer",
                    "signature": "build123d.ExportDXF.add_layer(self, name: str, *, color: Optional[build123d.exporters.ColorIndex] = None, line_weight: Optional[float] = None, line_type: Optional[build123d.exporters.LineType] = None) -> Self",
                    "docstring": "add_layer\n\nAdds a new layer to the DXF export with the given properties.\n\nArgs:\n    name (str): The name of the layer definition. Must be unique among all layers.\n    color (Optional[ColorIndex], optional): The color index for shapes on this layer.\n        It can be specified as a ColorIndex enum or None. Defaults to None.\n    line_weight (Optional[float], optional): The line weight (stroke width) for shapes\n        on this layer, in millimeters. Defaults to None.\n    line_type (Optional[LineType], optional): The line type for shapes on this layer.\n        It should be a LineType enum or None. Defaults to None.\n\nReturns:\n    Self: DXF document with additional layer"
                },
                {
                    "name": "build123d.ExportDXF.add_shape",
                    "signature": "build123d.ExportDXF.add_shape(self, shape: Union[build123d.topology.Shape, Iterable[build123d.topology.Shape]], layer: str = '') -> Self",
                    "docstring": "add_shape\n\nAdds a shape to the specified layer.\n\nArgs:\n    shape (Union[Shape, Iterable[Shape]]): The shape or collection of shapes to be\n          added. It can be a single Shape object or an iterable of Shape objects.\n    layer (str, optional): The name of the layer where the shape will be\n        added. If not specified, the default layer will be used. Defaults to \"\".\n\nReturns:\n    Self: Document with additional shape"
                },
                {
                    "name": "build123d.ExportDXF.write",
                    "signature": "build123d.ExportDXF.write(self, file_name: Union[os.PathLike, str, bytes])",
                    "docstring": "write\n\nWrites the DXF data to the specified file name.\n\nArgs:\n    file_name (Union[PathLike, str, bytes]): The file name (including path) where the DXF data will\n        be written."
                }
            ],
            "variables": [
                "DEFAULT_COLOR_INDEX",
                "DEFAULT_LINE_TYPE",
                "DEFAULT_LINE_WEIGHT",
                "LINETYPE_DEFS",
                "LTYPE_SCALE",
                "METRIC_UNITS",
                "PARAMETRIC_TOLERANCE"
            ],
            "docstring": "The ExportDXF class provides functionality for exporting 2D shapes to DXF\n(Drawing Exchange Format) format. DXF is a widely used file format for\nexchanging CAD (Computer-Aided Design) data between different software\napplications.\n\n\nArgs:\n    version (str, optional): The DXF version to use for the output file.\n        Defaults to ezdxf.DXF2013.\n    unit (Unit, optional): The unit used for the exported DXF. It should be\n        one of the Unit enums: Unit.MC, Unit.MM, Unit.CM,\n        Unit.M, Unit.IN, or Unit.FT. Defaults to Unit.MM.\n    color (Optional[ColorIndex], optional): The default color index for shapes.\n        It can be specified as a ColorIndex enum or None.. Defaults to None.\n    line_weight (Optional[float], optional): The default line weight\n        (stroke width) for shapes, in millimeters. . Defaults to None.\n    line_type (Optional[LineType], optional): e default line type for shapes.\n        It should be a LineType enum or None.. Defaults to None.\n\n\nExample:\n\n    .. code-block:: python\n\n        exporter = ExportDXF(unit=Unit.MM, line_weight=0.5)\n        exporter.add_layer(\"Layer 1\", color=ColorIndex.RED, line_type=LineType.DASHED)\n        exporter.add_shape(shape_object, layer=\"Layer 1\")\n        exporter.write(\"output.dxf\")\n\nRaises:\n    ValueError: unit not supported"
        },
        {
            "name": "build123d.ExportSVG",
            "signature": "build123d.ExportSVG(unit: build123d.build_enums.Unit = <Unit.MM>, scale: float = 1, margin: float = 0, fit_to_stroke: bool = True, precision: int = 6, fill_color: Union[build123d.exporters.ColorIndex, ezdxf.colors.RGB, build123d.geometry.Color, NoneType] = None, line_color: Union[build123d.exporters.ColorIndex, ezdxf.colors.RGB, build123d.geometry.Color, NoneType] = <ColorIndex.BLACK: 7>, line_weight: float = 0.09, line_type: build123d.exporters.LineType = <LineType.CONTINUOUS: 'CONTINUOUS'>, dot_length: Union[build123d.exporters.DotLength, float] = <DotLength.INKSCAPE_COMPAT: 0.01>)",
            "methods": [
                {
                    "name": "build123d.ExportSVG.add_layer",
                    "signature": "build123d.ExportSVG.add_layer(self, name: str, *, fill_color: Union[build123d.exporters.ColorIndex, ezdxf.colors.RGB, build123d.geometry.Color, NoneType] = None, line_color: Union[build123d.exporters.ColorIndex, ezdxf.colors.RGB, build123d.geometry.Color, NoneType] = <ColorIndex.BLACK: 7>, line_weight: float = 0.09, line_type: build123d.exporters.LineType = <LineType.CONTINUOUS: 'CONTINUOUS'>) -> Self",
                    "docstring": "add_layer\n\nAdds a new layer to the SVG export with the given properties.\n\nArgs:\n    name (str): The name of the layer. Must be unique among all layers.\n    fill_color (Union[ColorIndex, RGB, Color, None], optional): The fill color for shapes\n        on this layer. It can be specified as a ColorIndex, an RGB tuple,\n        a Color, or None.  Defaults to None.\n    line_color (Union[ColorIndex, RGB, Color, None], optional): The line color for shapes on\n        this layer. It can be specified as a ColorIndex or an RGB tuple,\n        a Color, or None.  Defaults to Export2D.DEFAULT_COLOR_INDEX.\n    line_weight (float, optional): The line weight (stroke width) for shapes on\n        this layer, in millimeters. Defaults to Export2D.DEFAULT_LINE_WEIGHT.\n    line_type (LineType, optional): The line type for shapes on this layer.\n        It should be a LineType enum. Defaults to Export2D.DEFAULT_LINE_TYPE.\n\nRaises:\n    ValueError: Duplicate layer name\n    ValueError: Unknown linetype\n\nReturns:\n    Self: Drawing with an additional layer"
                },
                {
                    "name": "build123d.ExportSVG.add_shape",
                    "signature": "build123d.ExportSVG.add_shape(self, shape: Union[build123d.topology.Shape, Iterable[build123d.topology.Shape]], layer: str = '', reverse_wires: bool = False)",
                    "docstring": "add_shape\n\nAdds a shape or a collection of shapes to the specified layer.\n\nArgs:\n    shape (Union[Shape, Iterable[Shape]]): The shape or collection of shapes to be\n          added. It can be a single Shape object or an iterable of Shape objects.\n    layer (str, optional): The name of the layer where the shape(s) will be added.\n        Defaults to \"\".\n    reverse_wires (bool, optional): A boolean indicating whether the wires of the\n        shape(s) should be in reversed direction. Defaults to False.\n\nRaises:\n    ValueError: Undefined layer"
                },
                {
                    "name": "build123d.ExportSVG.write",
                    "signature": "build123d.ExportSVG.write(self, path: Union[os.PathLike, str, bytes])",
                    "docstring": "write\n\nWrites the SVG data to the specified file path.\n\nArgs:\n    path (Union[PathLike, str, bytes]): The file path where the SVG data will be written."
                }
            ],
            "variables": [
                "DEFAULT_COLOR_INDEX",
                "DEFAULT_LINE_TYPE",
                "DEFAULT_LINE_WEIGHT",
                "LINETYPE_DEFS",
                "LTYPE_SCALE",
                "PARAMETRIC_TOLERANCE"
            ],
            "docstring": "ExportSVG\n\nSVG file export functionality.\n\nThe ExportSVG class provides functionality for exporting 2D shapes to SVG\n(Scalable Vector Graphics) format. SVG is a widely used vector graphics format\nthat is supported by web browsers and various graphic editors.\n\nArgs:\n    unit (Unit, optional): The unit used for the exported SVG. It should be one of\n        the Unit enums: Unit.MM, Unit.CM, or Unit.IN. Defaults to\n        Unit.MM.\n    scale (float, optional): The scaling factor applied to the exported SVG.\n        Defaults to 1.\n    margin (float, optional): The margin added around the exported shapes.\n        Defaults to 0.\n    fit_to_stroke (bool, optional): A boolean indicating whether the SVG view box\n        should fit the strokes of the shapes. Defaults to True.\n    precision (int, optional): The number of decimal places used for rounding\n        coordinates in the SVG. Defaults to 6.\n    fill_color (Union[ColorIndex, RGB, None], optional): The default fill color\n        for shapes. It can be specified as a ColorIndex, an RGB tuple, or None.\n        Defaults to None.\n    line_color (Union[ColorIndex, RGB, None], optional): The default line color for\n        shapes. It can be specified as a ColorIndex or an RGB tuple, or None.\n        Defaults to Export2D.DEFAULT_COLOR_INDEX.\n    line_weight (float, optional): The default line weight (stroke width) for\n        shapes, in millimeters. Defaults to Export2D.DEFAULT_LINE_WEIGHT.\n    line_type (LineType, optional): The default line type for shapes. It should be\n        a LineType enum. Defaults to Export2D.DEFAULT_LINE_TYPE.\n    dot_length (Union[DotLength, float], optional): The width of rendered dots in a\n        Can be either a DotLength enum or a float value in tenths of an inch.\n        Defaults to DotLength.INKSCAPE_COMPAT.\n\n\nExample:\n\n    .. code-block:: python\n\n        exporter = ExportSVG(unit=Unit.MM, line_weight=0.5)\n        exporter.add_layer(\"Layer 1\", fill_color=(255, 0, 0), line_color=(0, 0, 255))\n        exporter.add_shape(shape_object, layer=\"Layer 1\")\n        exporter.write(\"output.svg\")\n\nRaises:\n    ValueError: Invalid unit."
        },
        {
            "name": "build123d.ExtensionLine",
            "signature": "build123d.ExtensionLine(border: Union[build123d.topology.Wire, build123d.topology.Edge, list[Union[build123d.geometry.Vector, build123d.topology.Vertex, tuple[float, float, float]]]], offset: float, draft: build123d.drafting.Draft, sketch: build123d.topology.Sketch = None, label: str = None, arrows: tuple[bool, bool] = (True, True), tolerance: Union[float, tuple[float, float]] = None, label_angle: bool = False, project_line: Union[build123d.geometry.Vector, tuple[float, float], tuple[float, float, float], Iterable[float]] = None, mode: build123d.build_enums.Mode = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.ExtensionLine.bounding_box",
                    "signature": "build123d.ExtensionLine.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.ExtensionLine.cast",
                    "signature": "build123d.ExtensionLine.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.ExtensionLine.center",
                    "signature": "build123d.ExtensionLine.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.ExtensionLine.chamfer",
                    "signature": "build123d.ExtensionLine.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.ExtensionLine.clean",
                    "signature": "build123d.ExtensionLine.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.ExtensionLine.closest_points",
                    "signature": "build123d.ExtensionLine.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.ExtensionLine.combined_center",
                    "signature": "build123d.ExtensionLine.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.ExtensionLine.compound",
                    "signature": "build123d.ExtensionLine.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.ExtensionLine.compounds",
                    "signature": "build123d.ExtensionLine.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.ExtensionLine.compute_mass",
                    "signature": "build123d.ExtensionLine.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.copy",
                    "signature": "build123d.ExtensionLine.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.ExtensionLine.copy_attributes_to",
                    "signature": "build123d.ExtensionLine.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.ExtensionLine.cut",
                    "signature": "build123d.ExtensionLine.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.distance",
                    "signature": "build123d.ExtensionLine.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.distance_to",
                    "signature": "build123d.ExtensionLine.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.ExtensionLine.distance_to_with_closest_points",
                    "signature": "build123d.ExtensionLine.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.ExtensionLine.distances",
                    "signature": "build123d.ExtensionLine.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.do_children_intersect",
                    "signature": "build123d.ExtensionLine.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.ExtensionLine.dprism",
                    "signature": "build123d.ExtensionLine.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.ExtensionLine.edge",
                    "signature": "build123d.ExtensionLine.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.ExtensionLine.edges",
                    "signature": "build123d.ExtensionLine.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.ExtensionLine.export_brep",
                    "signature": "build123d.ExtensionLine.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.export_step",
                    "signature": "build123d.ExtensionLine.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.ExtensionLine.export_stl",
                    "signature": "build123d.ExtensionLine.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.ExtensionLine.extrude",
                    "signature": "build123d.ExtensionLine.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.ExtensionLine.face",
                    "signature": "build123d.ExtensionLine.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.ExtensionLine.faces",
                    "signature": "build123d.ExtensionLine.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.ExtensionLine.faces_intersected_by_axis",
                    "signature": "build123d.ExtensionLine.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.ExtensionLine.fillet",
                    "signature": "build123d.ExtensionLine.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.ExtensionLine.find_intersection",
                    "signature": "build123d.ExtensionLine.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.ExtensionLine.find_intersection_points",
                    "signature": "build123d.ExtensionLine.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.ExtensionLine.first_level_shapes",
                    "signature": "build123d.ExtensionLine.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.ExtensionLine.fix",
                    "signature": "build123d.ExtensionLine.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.ExtensionLine.fuse",
                    "signature": "build123d.ExtensionLine.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.get_type",
                    "signature": "build123d.ExtensionLine.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.ExtensionLine.hash_code",
                    "signature": "build123d.ExtensionLine.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.hollow",
                    "signature": "build123d.ExtensionLine.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.ExtensionLine.intersect",
                    "signature": "build123d.ExtensionLine.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.is_equal",
                    "signature": "build123d.ExtensionLine.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.is_inside",
                    "signature": "build123d.ExtensionLine.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.ExtensionLine.is_null",
                    "signature": "build123d.ExtensionLine.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.is_same",
                    "signature": "build123d.ExtensionLine.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.is_valid",
                    "signature": "build123d.ExtensionLine.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.iter_path_reverse",
                    "signature": "build123d.ExtensionLine.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.ExtensionLine.locate",
                    "signature": "build123d.ExtensionLine.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.located",
                    "signature": "build123d.ExtensionLine.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.ExtensionLine.make_compound",
                    "signature": "build123d.ExtensionLine.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.make_text",
                    "signature": "build123d.ExtensionLine.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.ExtensionLine.make_triad",
                    "signature": "build123d.ExtensionLine.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.ExtensionLine.max_fillet",
                    "signature": "build123d.ExtensionLine.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.ExtensionLine.mesh",
                    "signature": "build123d.ExtensionLine.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.mirror",
                    "signature": "build123d.ExtensionLine.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.ExtensionLine.move",
                    "signature": "build123d.ExtensionLine.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.moved",
                    "signature": "build123d.ExtensionLine.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.ExtensionLine.offset_3d",
                    "signature": "build123d.ExtensionLine.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.ExtensionLine.project_faces",
                    "signature": "build123d.ExtensionLine.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.ExtensionLine.project_to_viewport",
                    "signature": "build123d.ExtensionLine.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.ExtensionLine.relocate",
                    "signature": "build123d.ExtensionLine.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.ExtensionLine.rotate",
                    "signature": "build123d.ExtensionLine.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.ExtensionLine.scale",
                    "signature": "build123d.ExtensionLine.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.shape_type",
                    "signature": "build123d.ExtensionLine.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.ExtensionLine.shell",
                    "signature": "build123d.ExtensionLine.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.ExtensionLine.shells",
                    "signature": "build123d.ExtensionLine.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.ExtensionLine.show_topology",
                    "signature": "build123d.ExtensionLine.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.ExtensionLine.solid",
                    "signature": "build123d.ExtensionLine.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.ExtensionLine.solids",
                    "signature": "build123d.ExtensionLine.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.ExtensionLine.split",
                    "signature": "build123d.ExtensionLine.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.ExtensionLine.split_by_perimeter",
                    "signature": "build123d.ExtensionLine.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.ExtensionLine.tessellate",
                    "signature": "build123d.ExtensionLine.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.ExtensionLine.to_arcs",
                    "signature": "build123d.ExtensionLine.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.ExtensionLine.to_splines",
                    "signature": "build123d.ExtensionLine.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.ExtensionLine.to_vtk_poly_data",
                    "signature": "build123d.ExtensionLine.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.ExtensionLine.transform_geometry",
                    "signature": "build123d.ExtensionLine.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.ExtensionLine.transform_shape",
                    "signature": "build123d.ExtensionLine.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.ExtensionLine.transformed",
                    "signature": "build123d.ExtensionLine.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.ExtensionLine.translate",
                    "signature": "build123d.ExtensionLine.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.ExtensionLine.unwrap",
                    "signature": "build123d.ExtensionLine.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.ExtensionLine.vertex",
                    "signature": "build123d.ExtensionLine.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.ExtensionLine.vertices",
                    "signature": "build123d.ExtensionLine.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.ExtensionLine.wire",
                    "signature": "build123d.ExtensionLine.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.ExtensionLine.wires",
                    "signature": "build123d.ExtensionLine.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Extension Line\n\nCreate a dimension line with two lines extending outward from the part to dimension.\nTypically used for (but not restricted to) outside dimensions, with a pair of lines\nextending from the edge of a part to a dimension line.\n\nArgs:\n    border (PathDescriptor): a very general type of input defining the object to\n        be dimensioned. Typically this value would be extracted from the part but is\n        not restricted to this use.\n    offset (float): a distance to displace the dimension line from the edge of the object\n    draft (Draft): instance of Draft dataclass\n    label (str, optional): a text string which will replace the length (or arc length)\n        that would otherwise be extracted from the provided path. Providing a label is\n        useful when illustrating a parameterized input where the name of an argument\n        is desired not an actual measurement. Defaults to None.\n    arrows (tuple[bool, bool], optional): a pair of boolean values controlling the placement\n        of the start and end arrows. Defaults to (True, True).\n    tolerance (Union[float, tuple[float, float]], optional): an optional tolerance\n        value to add to the extracted length value. If a single tolerance value is provided\n        it is shown as \u00b1 the provided value while a pair of values are shown as\n        separate + and - values. Defaults to None.\n    label_angle (bool, optional): a flag indicating that instead of an extracted length\n        value, the size of the circular arc extracted from the path should be displayed\n        in degrees. Defaults to False.\n    project_line (Vector, optional): Vector line which to project dimension against.\n        Defaults to None.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Extrinsic",
            "signature": "build123d.Extrinsic()",
            "methods": [],
            "variables": [
                "XYX",
                "XYZ",
                "XZX",
                "XZY",
                "YXY",
                "YXZ",
                "YZX",
                "YZY",
                "ZXY",
                "ZXZ",
                "ZYX",
                "ZYZ",
                "name",
                "value"
            ],
            "docstring": "Order to apply extrinsic rotations by axis"
        },
        {
            "name": "build123d.Face",
            "signature": "build123d.Face(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Face.bounding_box",
                    "signature": "build123d.Face.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Face.cast",
                    "signature": "build123d.Face.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Face.center",
                    "signature": "build123d.Face.center(self, center_of=<CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of Face\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Face.chamfer_2d",
                    "signature": "build123d.Face.chamfer_2d(self, distance: 'float', distance2: 'float', vertices: 'Iterable[Vertex]', edge: 'Edge' = None) -> 'Face'",
                    "docstring": "Apply 2D chamfer to a face\n\nArgs:\n    distance (float): chamfer length\n    distance2 (float): chamfer length\n    vertices (Iterable[Vertex]): vertices to chamfer\n    edge (Edge): identifies the side where length is measured. The vertices must be\n        part of the edge\n\nRaises:\n    ValueError: Cannot chamfer at this location\n    ValueError: One or more vertices are not part of edge\n\nReturns:\n    Face: face with a chamfered corner(s)"
                },
                {
                    "name": "build123d.Face.clean",
                    "signature": "build123d.Face.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Face.closest_points",
                    "signature": "build123d.Face.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Face.combined_center",
                    "signature": "build123d.Face.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Face.compound",
                    "signature": "build123d.Face.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Face.compounds",
                    "signature": "build123d.Face.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Face.compute_mass",
                    "signature": "build123d.Face.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.copy",
                    "signature": "build123d.Face.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Face.copy_attributes_to",
                    "signature": "build123d.Face.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Face.cut",
                    "signature": "build123d.Face.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.distance",
                    "signature": "build123d.Face.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.distance_to",
                    "signature": "build123d.Face.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Face.distance_to_with_closest_points",
                    "signature": "build123d.Face.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Face.distances",
                    "signature": "build123d.Face.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.edge",
                    "signature": "build123d.Face.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Face.edges",
                    "signature": "build123d.Face.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Face.export_brep",
                    "signature": "build123d.Face.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.export_step",
                    "signature": "build123d.Face.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Face.export_stl",
                    "signature": "build123d.Face.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Face.extrude",
                    "signature": "build123d.Face.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Face.face",
                    "signature": "build123d.Face.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Face.faces",
                    "signature": "build123d.Face.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Face.faces_intersected_by_axis",
                    "signature": "build123d.Face.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Face.fillet_2d",
                    "signature": "build123d.Face.fillet_2d(self, radius: 'float', vertices: 'Iterable[Vertex]') -> 'Face'",
                    "docstring": "Apply 2D fillet to a face\n\nArgs:\n  radius: float:\n  vertices: Iterable[Vertex]:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.find_intersection",
                    "signature": "build123d.Face.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Face.find_intersection_points",
                    "signature": "build123d.Face.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Face.fix",
                    "signature": "build123d.Face.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Face.fuse",
                    "signature": "build123d.Face.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Face.hash_code",
                    "signature": "build123d.Face.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.inner_wires",
                    "signature": "build123d.Face.inner_wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "Extract the inner or hole wires from this Face"
                },
                {
                    "name": "build123d.Face.intersect",
                    "signature": "build123d.Face.intersect(self, *to_intersect: 'Union[Shape, Axis, Plane]') -> 'Shape'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Face.is_coplanar",
                    "signature": "build123d.Face.is_coplanar(self, plane: 'Plane') -> 'bool'",
                    "docstring": "Is this planar face coplanar with the provided plane"
                },
                {
                    "name": "build123d.Face.is_equal",
                    "signature": "build123d.Face.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.is_inside",
                    "signature": "build123d.Face.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Point inside Face\n\nReturns whether or not the point is inside a Face within the specified tolerance.\nPoints on the edge of the Face are considered inside.\n\nArgs:\n  point(VectorLike): tuple or Vector representing 3D point to be tested\n  tolerance(float): tolerance for inside determination. Defaults to 1.0e-6.\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool: indicating whether or not point is within Face"
                },
                {
                    "name": "build123d.Face.is_null",
                    "signature": "build123d.Face.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.is_same",
                    "signature": "build123d.Face.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.is_valid",
                    "signature": "build123d.Face.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.iter_path_reverse",
                    "signature": "build123d.Face.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Face.locate",
                    "signature": "build123d.Face.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.located",
                    "signature": "build123d.Face.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Face.location_at",
                    "signature": "build123d.Face.location_at(self, u: 'float', v: 'float', x_dir: 'VectorLike' = None) -> 'Location'",
                    "docstring": "Location at the u/v position of face"
                },
                {
                    "name": "build123d.Face.make_bezier_surface",
                    "signature": "build123d.Face.make_bezier_surface(points: 'list[list[VectorLike]]', weights: 'list[list[float]]' = None) -> 'Face'",
                    "docstring": "make_bezier_surface\n\nConstruct a B\u00e9zier surface from the provided 2d array of points.\n\nArgs:\n    points (list[list[VectorLike]]): a 2D list of control points\n    weights (list[list[float]], optional): control point weights. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Face: a potentially non-planar face"
                },
                {
                    "name": "build123d.Face.make_from_wires",
                    "signature": "build123d.Face.make_from_wires(outer_wire: 'Wire', inner_wires: 'Iterable[Wire]' = None) -> 'Face'",
                    "docstring": "make_from_wires\n\nMakes a planar face from one or more wires\n\nArgs:\n    outer_wire (Wire): closed perimeter wire\n    inner_wires (list[Wire], optional): holes. Defaults to None.\n\nRaises:\n    ValueError: outer wire not closed\n    ValueError: wires not planar\n    ValueError: inner wire not closed\n    ValueError: internal error\n\nReturns:\n    Face: planar face potentially with holes"
                },
                {
                    "name": "build123d.Face.make_holes",
                    "signature": "build123d.Face.make_holes(self, interior_wires: 'list[Wire]') -> 'Face'",
                    "docstring": "Make Holes in Face\n\nCreate holes in the Face 'self' from interior_wires which must be entirely interior.\nNote that making holes in faces is more efficient than using boolean operations\nwith solid object. Also note that OCCT core may fail unless the orientation of the wire\nis correct - use `Wire(forward_wire.wrapped.Reversed())` to reverse a wire.\n\nExample:\n\n    For example, make a series of slots on the curved walls of a cylinder.\n\n.. image:: slotted_cylinder.png\n\nArgs:\n  interior_wires: a list of hole outline wires\n  interior_wires: list[Wire]:\n\nReturns:\n  Face: 'self' with holes\n\nRaises:\n  RuntimeError: adding interior hole in non-planar face with provided interior_wires\n  RuntimeError: resulting face is not valid"
                },
                {
                    "name": "build123d.Face.make_plane",
                    "signature": "build123d.Face.make_plane(plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Face'",
                    "docstring": "Create a unlimited size Face aligned with plane"
                },
                {
                    "name": "build123d.Face.make_rect",
                    "signature": "build123d.Face.make_rect(width: 'float', height: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Face'",
                    "docstring": "make_rect\n\nMake a Rectangle centered on center with the given normal\n\nArgs:\n    width (float, optional): width (local x).\n    height (float, optional): height (local y).\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n\nReturns:\n    Face: The centered rectangle"
                },
                {
                    "name": "build123d.Face.make_surface",
                    "signature": "build123d.Face.make_surface(exterior: 'Union[Wire, Iterable[Edge]]', surface_points: 'Iterable[VectorLike]' = None, interior_wires: 'Iterable[Wire]' = None) -> 'Face'",
                    "docstring": "Create Non-Planar Face\n\nCreate a potentially non-planar face bounded by exterior (wire or edges),\noptionally refined by surface_points with optional holes defined by\ninterior_wires.\n\nArgs:\n    exterior (Union[Wire, list[Edge]]): Perimeter of face\n    surface_points (list[VectorLike], optional): Points on the surface that\n        refine the shape. Defaults to None.\n    interior_wires (list[Wire], optional): Hole(s) in the face. Defaults to None.\n\nRaises:\n    RuntimeError: Internal error building face\n    RuntimeError: Error building non-planar face with provided surface_points\n    RuntimeError: Error adding interior hole\n    RuntimeError: Generated face is invalid\n\nReturns:\n    Face: Potentially non-planar face"
                },
                {
                    "name": "build123d.Face.make_surface_from_array_of_points",
                    "signature": "build123d.Face.make_surface_from_array_of_points(points: 'list[list[VectorLike]]', tol: 'float' = 0.01, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 3) -> 'Face'",
                    "docstring": "make_surface_from_array_of_points\n\nApproximate a spline surface through the provided 2d array of points.\nThe first dimension correspond to points on the vertical direction in the parameter space of the face.\nThe second dimension correspond to points on the horizontal direction in the parameter space of the face.\nThe 2 dimensions are U,V dimensions of the parameter space of the face.\n\nArgs:\n    points (list[list[VectorLike]]): a 2D list of points, first dimension is V parameters second is U parameters.\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-2.\n    smoothing (Tuple[float, float, float], optional): optional tuple of\n        3 weights use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when\n        smoothing is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 3.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Face: a potentially non-planar face defined by points"
                },
                {
                    "name": "build123d.Face.make_surface_from_curves",
                    "signature": "build123d.Face.make_surface_from_curves(curve1: 'Union[Edge, Wire]', curve2: 'Union[Edge, Wire]') -> 'Face'",
                    "docstring": "make_surface_from_curves\n\nCreate a ruled surface out of two edges or two wires. If wires are used then\nthese must have the same number of edges.\n\nArgs:\n    curve1 (Union[Edge,Wire]): side of surface\n    curve2 (Union[Edge,Wire]): opposite side of surface\n\nReturns:\n    Face: potentially non planar surface"
                },
                {
                    "name": "build123d.Face.mesh",
                    "signature": "build123d.Face.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Face.mirror",
                    "signature": "build123d.Face.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Face.move",
                    "signature": "build123d.Face.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.moved",
                    "signature": "build123d.Face.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Face.normal_at",
                    "signature": "build123d.Face.normal_at(self, *args, **kwargs) -> 'Vector'",
                    "docstring": "normal_at\n\nComputes the normal vector at the desired location on the face.\n\nArgs:\n    surface_point (VectorLike, optional): a point that lies on the surface where the normal.\n        Defaults to None.\n\nReturns:\n    Vector: surface normal direction"
                },
                {
                    "name": "build123d.Face.offset",
                    "signature": "build123d.Face.offset(self, amount: 'float') -> 'Face'",
                    "docstring": "Return a copy of self moved along the normal by amount"
                },
                {
                    "name": "build123d.Face.outer_wire",
                    "signature": "build123d.Face.outer_wire(self) -> 'Wire'",
                    "docstring": "Extract the perimeter wire from this Face"
                },
                {
                    "name": "build123d.Face.position_at",
                    "signature": "build123d.Face.position_at(self, u: 'float', v: 'float') -> 'Vector'",
                    "docstring": "position_at\n\nComputes a point on the Face given u, v coordinates.\n\nArgs:\n    u (float): the horizontal coordinate in the parameter space of the Face,\n        between 0.0 and 1.0\n    v (float): the vertical coordinate in the parameter space of the Face,\n        between 0.0 and 1.0\n\nReturns:\n    Vector: point on Face"
                },
                {
                    "name": "build123d.Face.project_faces",
                    "signature": "build123d.Face.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Face.project_to_shape",
                    "signature": "build123d.Face.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike', taper: 'float' = 0) -> 'ShapeList[Face]'",
                    "docstring": "Project Face to target Object\n\nProject a Face onto a Shape generating new Face(s) on the surfaces of the object.\n\nA projection with no taper is illustrated below:\n\n.. image:: flatProjection.png\n    :alt: flatProjection\n\nNote that an array of faces is returned as the projection might result in faces\non the \"front\" and \"back\" of the object (or even more if there are intermediate\nsurfaces in the projection path). faces \"behind\" the projection are not\nreturned.\n\nArgs:\n    target_object (Shape): Object to project onto\n    direction (VectorLike): projection direction\n    taper (float, optional): taper angle. Defaults to 0.\n\nReturns:\n    ShapeList[Face]: Face(s) projected on target object ordered by distance"
                },
                {
                    "name": "build123d.Face.project_to_shape_alt",
                    "signature": "build123d.Face.project_to_shape_alt(self, target_object: 'Shape', direction: 'VectorLike') -> 'Union[None, Face, Compound]'",
                    "docstring": "project_to_shape_alt\n\nReturn the Faces contained within the first projection of self onto\nthe target.\n\nArgs:\n    target_object (Shape): Object to project onto\n    direction (VectorLike): projection direction\n\nReturns:\n    Union[None, Face, Compound]: projection"
                },
                {
                    "name": "build123d.Face.project_to_viewport",
                    "signature": "build123d.Face.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Face.relocate",
                    "signature": "build123d.Face.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Face.rotate",
                    "signature": "build123d.Face.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Face.scale",
                    "signature": "build123d.Face.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.sew_faces",
                    "signature": "build123d.Face.sew_faces(faces: 'Iterable[Face]') -> 'list[ShapeList[Face]]'",
                    "docstring": "sew faces\n\nGroup contiguous faces and return them in a list of ShapeList\n\nArgs:\n    faces (Iterable[Face]): Faces to sew together\n\nRaises:\n    RuntimeError: OCCT SewedShape generated unexpected output\n\nReturns:\n    list[ShapeList[Face]]: grouped contiguous faces"
                },
                {
                    "name": "build123d.Face.shape_type",
                    "signature": "build123d.Face.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Face.shell",
                    "signature": "build123d.Face.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Face.shells",
                    "signature": "build123d.Face.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Face.show_topology",
                    "signature": "build123d.Face.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Face.solid",
                    "signature": "build123d.Face.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Face.solids",
                    "signature": "build123d.Face.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Face.split",
                    "signature": "build123d.Face.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Face.split_by_perimeter",
                    "signature": "build123d.Face.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Face.sweep",
                    "signature": "build123d.Face.sweep(profile: 'Union[Curve, Edge, Wire]', path: 'Union[Curve, Edge, Wire]', transition=<Transition.TRANSFORMED>) -> 'Face'",
                    "docstring": "sweep\n\nSweep a 1D profile along a 1D path. Both the profile and path must be composed\nof only 1 Edge.\n\nArgs:\n    profile (Union[Curve,Edge,Wire]): the object to sweep\n    path (Union[Curve,Edge,Wire]): the path to follow when sweeping\n    transition (Transition, optional): handling of profile orientation at C1 path\n        discontinuities. Defaults to Transition.TRANSFORMED.\n\nRaises:\n    ValueError: Only 1 Edge allowed in profile & path\n\nReturns:\n    Face: resulting face, may be non-planar"
                },
                {
                    "name": "build123d.Face.tessellate",
                    "signature": "build123d.Face.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Face.thicken",
                    "signature": "build123d.Face.thicken(self, depth: 'float', normal_override: 'Optional[VectorLike]' = None) -> 'Solid'",
                    "docstring": "Thicken Face\n\nCreate a solid from a potentially non planar face by thickening along the normals.\n\n.. image:: thickenFace.png\n\nNon-planar faces are thickened both towards and away from the center of the sphere.\n\nArgs:\n    depth (float): Amount to thicken face(s), can be positive or negative.\n    normal_override (Vector, optional): The normal_override vector can be used to\n        indicate which way is 'up', potentially flipping the face normal direction\n        such that many faces with different normals all go in the same direction\n        (direction need only be +/- 90 degrees from the face normal). Defaults to None.\n\nRaises:\n    RuntimeError: Opencascade internal failures\n\nReturns:\n    Solid: The resulting Solid object"
                },
                {
                    "name": "build123d.Face.to_arcs",
                    "signature": "build123d.Face.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Face.to_splines",
                    "signature": "build123d.Face.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Face.to_vtk_poly_data",
                    "signature": "build123d.Face.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Face.transform_geometry",
                    "signature": "build123d.Face.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Face.transform_shape",
                    "signature": "build123d.Face.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Face.transformed",
                    "signature": "build123d.Face.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Face.translate",
                    "signature": "build123d.Face.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Face.vertex",
                    "signature": "build123d.Face.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Face.vertices",
                    "signature": "build123d.Face.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Face.wire",
                    "signature": "build123d.Face.wire(self) -> 'Wire'",
                    "docstring": "Return the outerwire, generate a warning if inner_wires present"
                },
                {
                    "name": "build123d.Face.wires",
                    "signature": "build123d.Face.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "center_location",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "geometry",
                "height",
                "is_leaf",
                "is_manifold",
                "is_planar",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume",
                "width"
            ],
            "docstring": "A Face in build123d represents a 3D bounded surface within the topological data\nstructure. It encapsulates geometric information, defining a face of a 3D shape.\nThese faces are integral components of complex structures, such as solids and\nshells. Face enables precise modeling and manipulation of surfaces, supporting\noperations like trimming, filleting, and Boolean operations."
        },
        {
            "name": "build123d.FilletPolyline",
            "signature": "build123d.FilletPolyline(*pts: 'Union[VectorLike, Iterable[VectorLike]]', radius: 'float', close: 'bool' = False, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.FilletPolyline.bounding_box",
                    "signature": "build123d.FilletPolyline.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.FilletPolyline.cast",
                    "signature": "build123d.FilletPolyline.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.FilletPolyline.center",
                    "signature": "build123d.FilletPolyline.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.FilletPolyline.chamfer_2d",
                    "signature": "build123d.FilletPolyline.chamfer_2d(self, distance: 'float', distance2: 'float', vertices: 'Iterable[Vertex]', edge: 'Edge' = None) -> 'Wire'",
                    "docstring": "chamfer_2d\n\nApply 2D chamfer to a wire\n\nArgs:\n    distance (float): chamfer length\n    distance2 (float): chamfer length\n    vertices (Iterable[Vertex]): vertices to chamfer\n    edge (Edge): identifies the side where length is measured. The vertices must be\n        part of the edge\n\nReturns:\n    Wire: chamfered wire"
                },
                {
                    "name": "build123d.FilletPolyline.clean",
                    "signature": "build123d.FilletPolyline.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.FilletPolyline.close",
                    "signature": "build123d.FilletPolyline.close(self) -> 'Wire'",
                    "docstring": "Close a Wire"
                },
                {
                    "name": "build123d.FilletPolyline.closest_points",
                    "signature": "build123d.FilletPolyline.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.FilletPolyline.combine",
                    "signature": "build123d.FilletPolyline.combine(wires: 'Iterable[Union[Wire, Edge]]', tol: 'float' = 1e-09) -> 'ShapeList[Wire]'",
                    "docstring": "combine\n\nCombine a list of wires and edges into a list of Wires.\n\nArgs:\n    wires (Iterable[Union[Wire, Edge]]): unsorted\n    tol (float, optional): tolerance. Defaults to 1e-9.\n\nReturns:\n    ShapeList[Wire]: Wires"
                },
                {
                    "name": "build123d.FilletPolyline.combined_center",
                    "signature": "build123d.FilletPolyline.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.FilletPolyline.common_plane",
                    "signature": "build123d.FilletPolyline.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.FilletPolyline.compound",
                    "signature": "build123d.FilletPolyline.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.FilletPolyline.compounds",
                    "signature": "build123d.FilletPolyline.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.FilletPolyline.compute_mass",
                    "signature": "build123d.FilletPolyline.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.copy",
                    "signature": "build123d.FilletPolyline.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.FilletPolyline.copy_attributes_to",
                    "signature": "build123d.FilletPolyline.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.FilletPolyline.cut",
                    "signature": "build123d.FilletPolyline.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.distance",
                    "signature": "build123d.FilletPolyline.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.distance_to",
                    "signature": "build123d.FilletPolyline.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.FilletPolyline.distance_to_with_closest_points",
                    "signature": "build123d.FilletPolyline.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.FilletPolyline.distances",
                    "signature": "build123d.FilletPolyline.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.edge",
                    "signature": "build123d.FilletPolyline.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.FilletPolyline.edges",
                    "signature": "build123d.FilletPolyline.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.FilletPolyline.end_point",
                    "signature": "build123d.FilletPolyline.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.FilletPolyline.export_brep",
                    "signature": "build123d.FilletPolyline.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.export_step",
                    "signature": "build123d.FilletPolyline.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.FilletPolyline.export_stl",
                    "signature": "build123d.FilletPolyline.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.FilletPolyline.extrude",
                    "signature": "build123d.FilletPolyline.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.FilletPolyline.face",
                    "signature": "build123d.FilletPolyline.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.FilletPolyline.faces",
                    "signature": "build123d.FilletPolyline.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.FilletPolyline.faces_intersected_by_axis",
                    "signature": "build123d.FilletPolyline.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.FilletPolyline.fillet_2d",
                    "signature": "build123d.FilletPolyline.fillet_2d(self, radius: 'float', vertices: 'Iterable[Vertex]') -> 'Wire'",
                    "docstring": "fillet_2d\n\nApply 2D fillet to a wire\n\nArgs:\n    radius (float):\n    vertices (Iterable[Vertex]): vertices to fillet\n\nReturns:\n    Wire: filleted wire"
                },
                {
                    "name": "build123d.FilletPolyline.find_intersection",
                    "signature": "build123d.FilletPolyline.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.FilletPolyline.find_intersection_points",
                    "signature": "build123d.FilletPolyline.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.FilletPolyline.fix",
                    "signature": "build123d.FilletPolyline.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.FilletPolyline.fix_degenerate_edges",
                    "signature": "build123d.FilletPolyline.fix_degenerate_edges(self, precision: 'float') -> 'Wire'",
                    "docstring": "fix_degenerate_edges\n\nFix a Wire that contains degenerate (very small) edges\n\nArgs:\n    precision (float): minimum value edge length\n\nReturns:\n    Wire: fixed wire"
                },
                {
                    "name": "build123d.FilletPolyline.fuse",
                    "signature": "build123d.FilletPolyline.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.FilletPolyline.hash_code",
                    "signature": "build123d.FilletPolyline.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.intersect",
                    "signature": "build123d.FilletPolyline.intersect(self, *to_intersect: 'Union[Shape, Axis, Plane]') -> 'Shape'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.FilletPolyline.is_equal",
                    "signature": "build123d.FilletPolyline.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.is_null",
                    "signature": "build123d.FilletPolyline.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.is_same",
                    "signature": "build123d.FilletPolyline.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.is_valid",
                    "signature": "build123d.FilletPolyline.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.iter_path_reverse",
                    "signature": "build123d.FilletPolyline.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.FilletPolyline.locate",
                    "signature": "build123d.FilletPolyline.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.located",
                    "signature": "build123d.FilletPolyline.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.FilletPolyline.location_at",
                    "signature": "build123d.FilletPolyline.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.FilletPolyline.locations",
                    "signature": "build123d.FilletPolyline.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.FilletPolyline.make_circle",
                    "signature": "build123d.FilletPolyline.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Wire'",
                    "docstring": "make_circle\n\nMakes a circle centered at the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane): base plane. Defaults to Plane.XY\n\nReturns:\n    Wire: a circle"
                },
                {
                    "name": "build123d.FilletPolyline.make_convex_hull",
                    "signature": "build123d.FilletPolyline.make_convex_hull(edges: 'Iterable[Edge]', tolerance: 'float' = 0.001) -> 'Wire'",
                    "docstring": "make_convex_hull\n\nCreate a wire of minimum length enclosing all of the provided edges.\n\nNote that edges can't overlap each other.\n\nArgs:\n    edges (Iterable[Edge]): edges defining the convex hull\n    tolerance (float): allowable error as a fraction of each edge length.\n        Defaults to 1e-3.\n\nRaises:\n    ValueError: edges overlap\n\nReturns:\n    Wire: convex hull perimeter"
                },
                {
                    "name": "build123d.FilletPolyline.make_ellipse",
                    "signature": "build123d.FilletPolyline.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>, closed: 'bool' = True) -> 'Wire'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): _description_. Defaults to 360.0.\n    end_angle (float, optional): _description_. Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n    closed (bool, optional): close the arc. Defaults to True.\n\nReturns:\n    Wire: an ellipse"
                },
                {
                    "name": "build123d.FilletPolyline.make_polygon",
                    "signature": "build123d.FilletPolyline.make_polygon(vertices: 'Iterable[VectorLike]', close: 'bool' = True) -> 'Wire'",
                    "docstring": "make_polygon\n\nCreate an irregular polygon by defining vertices\n\nArgs:\n    vertices (Iterable[VectorLike]):\n    close (bool, optional): close the polygon. Defaults to True.\n\nReturns:\n    Wire: an irregular polygon"
                },
                {
                    "name": "build123d.FilletPolyline.make_rect",
                    "signature": "build123d.FilletPolyline.make_rect(width: 'float', height: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Wire'",
                    "docstring": "Make Rectangle\n\nMake a Rectangle centered on center with the given normal\n\nArgs:\n    width (float): width (local x)\n    height (float): height (local y)\n    plane (Plane, optional): plane containing rectangle. Defaults to Plane.XY.\n\nReturns:\n    Wire: The centered rectangle"
                },
                {
                    "name": "build123d.FilletPolyline.make_wire",
                    "signature": "build123d.FilletPolyline.make_wire(edges: 'Iterable[Edge]', sequenced: 'bool' = False) -> 'Wire'",
                    "docstring": "make_wire\n\nBuild a Wire from the provided unsorted Edges. If sequenced is True the\nEdges are placed in such that the end of the nth Edge is coincident with\nthe n+1th Edge forming an unbroken sequence. Note that sequencing a list\nis relatively slow.\n\nArgs:\n    edges (Iterable[Edge]): Edges to assemble\n    sequenced (bool, optional): arrange in order. Defaults to False.\n\nRaises:\n    ValueError: Edges are disconnected and can't be sequenced.\n    RuntimeError: Wire is empty\n\nReturns:\n    Wire: assembled edges"
                },
                {
                    "name": "build123d.FilletPolyline.mesh",
                    "signature": "build123d.FilletPolyline.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.mirror",
                    "signature": "build123d.FilletPolyline.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.FilletPolyline.move",
                    "signature": "build123d.FilletPolyline.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.moved",
                    "signature": "build123d.FilletPolyline.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.FilletPolyline.normal",
                    "signature": "build123d.FilletPolyline.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.offset_2d",
                    "signature": "build123d.FilletPolyline.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.FilletPolyline.order_edges",
                    "signature": "build123d.FilletPolyline.order_edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "Return the edges in self ordered by wire direction and orientation"
                },
                {
                    "name": "build123d.FilletPolyline.param_at",
                    "signature": "build123d.FilletPolyline.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.FilletPolyline.param_at_point",
                    "signature": "build123d.FilletPolyline.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Parameter at point on Wire"
                },
                {
                    "name": "build123d.FilletPolyline.perpendicular_line",
                    "signature": "build123d.FilletPolyline.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.FilletPolyline.position_at",
                    "signature": "build123d.FilletPolyline.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.FilletPolyline.positions",
                    "signature": "build123d.FilletPolyline.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.FilletPolyline.project",
                    "signature": "build123d.FilletPolyline.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.project_faces",
                    "signature": "build123d.FilletPolyline.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.FilletPolyline.project_to_shape",
                    "signature": "build123d.FilletPolyline.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Wire]'",
                    "docstring": "Project Wire\n\nProject a Wire onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected wire(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.FilletPolyline.project_to_viewport",
                    "signature": "build123d.FilletPolyline.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.FilletPolyline.relocate",
                    "signature": "build123d.FilletPolyline.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.FilletPolyline.rotate",
                    "signature": "build123d.FilletPolyline.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.FilletPolyline.scale",
                    "signature": "build123d.FilletPolyline.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.shape_type",
                    "signature": "build123d.FilletPolyline.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.FilletPolyline.shell",
                    "signature": "build123d.FilletPolyline.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.FilletPolyline.shells",
                    "signature": "build123d.FilletPolyline.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.FilletPolyline.show_topology",
                    "signature": "build123d.FilletPolyline.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.FilletPolyline.solid",
                    "signature": "build123d.FilletPolyline.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.FilletPolyline.solids",
                    "signature": "build123d.FilletPolyline.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.FilletPolyline.split",
                    "signature": "build123d.FilletPolyline.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.FilletPolyline.split_by_perimeter",
                    "signature": "build123d.FilletPolyline.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.FilletPolyline.start_point",
                    "signature": "build123d.FilletPolyline.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.FilletPolyline.stitch",
                    "signature": "build123d.FilletPolyline.stitch(self, other: 'Wire') -> 'Wire'",
                    "docstring": "Attempt to stich wires\n\nArgs:\n  other: Wire:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.tangent_angle_at",
                    "signature": "build123d.FilletPolyline.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.FilletPolyline.tangent_at",
                    "signature": "build123d.FilletPolyline.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.FilletPolyline.tessellate",
                    "signature": "build123d.FilletPolyline.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.FilletPolyline.to_arcs",
                    "signature": "build123d.FilletPolyline.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.FilletPolyline.to_splines",
                    "signature": "build123d.FilletPolyline.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.FilletPolyline.to_vtk_poly_data",
                    "signature": "build123d.FilletPolyline.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.FilletPolyline.to_wire",
                    "signature": "build123d.FilletPolyline.to_wire(self) -> 'Wire'",
                    "docstring": "Return Wire - used as a pair with Edge.to_wire when self is Wire | Edge"
                },
                {
                    "name": "build123d.FilletPolyline.transform_geometry",
                    "signature": "build123d.FilletPolyline.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.FilletPolyline.transform_shape",
                    "signature": "build123d.FilletPolyline.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.FilletPolyline.transformed",
                    "signature": "build123d.FilletPolyline.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.FilletPolyline.translate",
                    "signature": "build123d.FilletPolyline.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.FilletPolyline.trim",
                    "signature": "build123d.FilletPolyline.trim(self: 'Wire', start: 'float', end: 'float') -> 'Wire'",
                    "docstring": "trim\n\nCreate a new wire by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Wire: trimmed wire"
                },
                {
                    "name": "build123d.FilletPolyline.vertex",
                    "signature": "build123d.FilletPolyline.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.FilletPolyline.vertices",
                    "signature": "build123d.FilletPolyline.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.FilletPolyline.wire",
                    "signature": "build123d.FilletPolyline.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.FilletPolyline.wires",
                    "signature": "build123d.FilletPolyline.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: FilletPolyline\n\nAdd a sequence of straight lines defined by successive points that\nare filleted to a given radius.\n\nArgs:\n    pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two or more points\n    radius (float): radius of filleted corners\n    close (bool, optional): close by generating an extra Edge. Defaults to False.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: Two or more points not provided\n    ValueError: radius must be positive"
        },
        {
            "name": "build123d.FontStyle",
            "signature": "build123d.FontStyle()",
            "methods": [],
            "variables": [
                "BOLD",
                "ITALIC",
                "REGULAR",
                "name",
                "value"
            ],
            "docstring": "Text Font Styles"
        },
        {
            "name": "build123d.FrameMethod",
            "signature": "build123d.FrameMethod()",
            "methods": [],
            "variables": [
                "CORRECTED",
                "FRENET",
                "name",
                "value"
            ],
            "docstring": "Moving frame calculation method"
        },
        {
            "name": "build123d.GeomType",
            "signature": "build123d.GeomType()",
            "methods": [],
            "variables": [
                "BEZIER",
                "BSPLINE",
                "CIRCLE",
                "CONE",
                "CYLINDER",
                "ELLIPSE",
                "EXTRUSION",
                "HYPERBOLA",
                "LINE",
                "OFFSET",
                "OTHER",
                "PARABOLA",
                "PLANE",
                "REVOLUTION",
                "SPHERE",
                "TORUS",
                "name",
                "value"
            ],
            "docstring": "CAD geometry object type"
        },
        {
            "name": "build123d.GridLocations",
            "signature": "build123d.GridLocations(x_spacing: 'float', y_spacing: 'float', x_count: 'int', y_count: 'int', align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>))",
            "methods": [],
            "variables": [
                "locations"
            ],
            "docstring": "Location Context: Rectangular Array\n\nCreates a context of rectangular array of locations for Part or Sketch\n\nArgs:\n    x_spacing (float): horizontal spacing\n    y_spacing (float): vertical spacing\n    x_count (int): number of horizontal points\n    y_count (int): number of vertical points\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n\n\nAttributes:\n    x_spacing (float): horizontal spacing\n    y_spacing (float): vertical spacing\n    x_count (int): number of horizontal points\n    y_count (int): number of vertical points\n    align (Union[Align, tuple[Align, Align]]): align min, center, or max of object.\n    local_locations (list{Location}): locations relative to workplane\n\nRaises:\n    ValueError: Either x or y count must be greater than or equal to one."
        },
        {
            "name": "build123d.GroupBy",
            "signature": "build123d.GroupBy(key_f: 'Callable[[T], K]', shapelist: 'Iterable[T]', *, reverse: 'bool' = False)",
            "methods": [
                {
                    "name": "build123d.GroupBy.group",
                    "signature": "build123d.GroupBy.group(self, key: 'K')",
                    "docstring": "Select group by key"
                },
                {
                    "name": "build123d.GroupBy.group_for",
                    "signature": "build123d.GroupBy.group_for(self, shape: 'T')",
                    "docstring": "Select group by shape"
                }
            ],
            "variables": [],
            "docstring": "Result of a Shape.groupby operation. Groups can be accessed by index or key"
        },
        {
            "name": "build123d.HeadType",
            "signature": "build123d.HeadType()",
            "methods": [],
            "variables": [
                "CURVED",
                "FILLETED",
                "STRAIGHT",
                "name",
                "value"
            ],
            "docstring": "Arrow head types"
        },
        {
            "name": "build123d.Helix",
            "signature": "build123d.Helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), direction: 'VectorLike' = (0, 0, 1), cone_angle: 'float' = 0, lefthand: 'bool' = False, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Helix.bounding_box",
                    "signature": "build123d.Helix.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Helix.cast",
                    "signature": "build123d.Helix.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Helix.center",
                    "signature": "build123d.Helix.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Helix.clean",
                    "signature": "build123d.Helix.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Helix.close",
                    "signature": "build123d.Helix.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.Helix.closest_points",
                    "signature": "build123d.Helix.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Helix.combined_center",
                    "signature": "build123d.Helix.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Helix.common_plane",
                    "signature": "build123d.Helix.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.Helix.compound",
                    "signature": "build123d.Helix.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Helix.compounds",
                    "signature": "build123d.Helix.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Helix.compute_mass",
                    "signature": "build123d.Helix.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.copy",
                    "signature": "build123d.Helix.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Helix.copy_attributes_to",
                    "signature": "build123d.Helix.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Helix.cut",
                    "signature": "build123d.Helix.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.distance",
                    "signature": "build123d.Helix.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.distance_to",
                    "signature": "build123d.Helix.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Helix.distance_to_with_closest_points",
                    "signature": "build123d.Helix.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Helix.distances",
                    "signature": "build123d.Helix.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.distribute_locations",
                    "signature": "build123d.Helix.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.Helix.edge",
                    "signature": "build123d.Helix.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Helix.edges",
                    "signature": "build123d.Helix.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Helix.end_point",
                    "signature": "build123d.Helix.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Helix.export_brep",
                    "signature": "build123d.Helix.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.export_step",
                    "signature": "build123d.Helix.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Helix.export_stl",
                    "signature": "build123d.Helix.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Helix.extrude",
                    "signature": "build123d.Helix.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Helix.face",
                    "signature": "build123d.Helix.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Helix.faces",
                    "signature": "build123d.Helix.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Helix.faces_intersected_by_axis",
                    "signature": "build123d.Helix.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Helix.find_intersection",
                    "signature": "build123d.Helix.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Helix.find_intersection_points",
                    "signature": "build123d.Helix.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.Helix.find_tangent",
                    "signature": "build123d.Helix.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.Helix.fix",
                    "signature": "build123d.Helix.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Helix.fuse",
                    "signature": "build123d.Helix.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Helix.hash_code",
                    "signature": "build123d.Helix.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.intersect",
                    "signature": "build123d.Helix.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Helix.is_equal",
                    "signature": "build123d.Helix.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.is_null",
                    "signature": "build123d.Helix.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.is_same",
                    "signature": "build123d.Helix.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.is_valid",
                    "signature": "build123d.Helix.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.iter_path_reverse",
                    "signature": "build123d.Helix.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Helix.locate",
                    "signature": "build123d.Helix.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.located",
                    "signature": "build123d.Helix.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Helix.location_at",
                    "signature": "build123d.Helix.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.Helix.locations",
                    "signature": "build123d.Helix.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.Helix.make_bezier",
                    "signature": "build123d.Helix.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.Helix.make_circle",
                    "signature": "build123d.Helix.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.Helix.make_ellipse",
                    "signature": "build123d.Helix.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.Helix.make_helix",
                    "signature": "build123d.Helix.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.Helix.make_line",
                    "signature": "build123d.Helix.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.Helix.make_mid_way",
                    "signature": "build123d.Helix.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.Helix.make_spline",
                    "signature": "build123d.Helix.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.Helix.make_spline_approx",
                    "signature": "build123d.Helix.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.Helix.make_tangent_arc",
                    "signature": "build123d.Helix.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.Helix.make_three_point_arc",
                    "signature": "build123d.Helix.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.Helix.mesh",
                    "signature": "build123d.Helix.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.mirror",
                    "signature": "build123d.Helix.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Helix.move",
                    "signature": "build123d.Helix.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.moved",
                    "signature": "build123d.Helix.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Helix.normal",
                    "signature": "build123d.Helix.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.offset_2d",
                    "signature": "build123d.Helix.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.Helix.param_at",
                    "signature": "build123d.Helix.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.Helix.param_at_point",
                    "signature": "build123d.Helix.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.Helix.perpendicular_line",
                    "signature": "build123d.Helix.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.Helix.position_at",
                    "signature": "build123d.Helix.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.Helix.positions",
                    "signature": "build123d.Helix.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.Helix.project",
                    "signature": "build123d.Helix.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.project_faces",
                    "signature": "build123d.Helix.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Helix.project_to_shape",
                    "signature": "build123d.Helix.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.Helix.project_to_viewport",
                    "signature": "build123d.Helix.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Helix.relocate",
                    "signature": "build123d.Helix.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Helix.reversed",
                    "signature": "build123d.Helix.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.Helix.rotate",
                    "signature": "build123d.Helix.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Helix.scale",
                    "signature": "build123d.Helix.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.shape_type",
                    "signature": "build123d.Helix.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Helix.shell",
                    "signature": "build123d.Helix.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Helix.shells",
                    "signature": "build123d.Helix.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Helix.show_topology",
                    "signature": "build123d.Helix.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Helix.solid",
                    "signature": "build123d.Helix.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Helix.solids",
                    "signature": "build123d.Helix.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Helix.split",
                    "signature": "build123d.Helix.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Helix.split_by_perimeter",
                    "signature": "build123d.Helix.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Helix.start_point",
                    "signature": "build123d.Helix.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Helix.tangent_angle_at",
                    "signature": "build123d.Helix.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.Helix.tangent_at",
                    "signature": "build123d.Helix.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.Helix.tessellate",
                    "signature": "build123d.Helix.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Helix.to_arcs",
                    "signature": "build123d.Helix.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Helix.to_axis",
                    "signature": "build123d.Helix.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.Helix.to_splines",
                    "signature": "build123d.Helix.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Helix.to_vtk_poly_data",
                    "signature": "build123d.Helix.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Helix.to_wire",
                    "signature": "build123d.Helix.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.Helix.transform_geometry",
                    "signature": "build123d.Helix.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Helix.transform_shape",
                    "signature": "build123d.Helix.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Helix.transformed",
                    "signature": "build123d.Helix.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Helix.translate",
                    "signature": "build123d.Helix.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Helix.trim",
                    "signature": "build123d.Helix.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.Helix.trim_to_length",
                    "signature": "build123d.Helix.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.Helix.vertex",
                    "signature": "build123d.Helix.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Helix.vertices",
                    "signature": "build123d.Helix.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Helix.wire",
                    "signature": "build123d.Helix.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Helix.wires",
                    "signature": "build123d.Helix.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Helix\n\nAdd a helix to the line.\n\nArgs:\n    pitch (float): distance between successive loops\n    height (float): helix size\n    radius (float): helix radius\n    center (VectorLike, optional): center point. Defaults to (0, 0, 0).\n    direction (VectorLike, optional): direction of central axis. Defaults to (0, 0, 1).\n    cone_angle (float, optional): conical angle. Defaults to 0.\n    lefthand (bool, optional): left handed helix. Defaults to False.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.HexLocations",
            "signature": "build123d.HexLocations(radius: 'float', x_count: 'int', y_count: 'int', major_radius: 'bool' = False, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>))",
            "methods": [],
            "variables": [
                "locations"
            ],
            "docstring": "Location Context: Hex Array\n\nCreates a context of hexagon array of locations for Part or Sketch. When creating\nhex locations for an array of circles, set `radius` to the radius of the circle\nplus one half the spacing between the circles.\n\nArgs:\n    radius (float): distance from origin to vertices (major), or\n        optionally from the origin to side (minor or apothem)\n        with major_radius = False\n    x_count (int): number of points ( > 0 )\n    y_count (int): number of points ( > 0 )\n    major_radius (bool): If True the radius is the major radius, else the\n        radius is the minor radius (also known as inscribed radius).\n        Defaults to False.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n\nAttributes:\n    radius (float): distance from origin to vertices (major), or\n        optionally from the origin to side (minor or apothem)\n        with major_radius = False\n    apothem (float): radius of the inscribed circle, also known as minor radius\n    x_count (int): number of points ( > 0 )\n    y_count (int): number of points ( > 0 )\n    major_radius (bool): If True the radius is the major radius, else the\n        radius is the minor radius (also known as inscribed radius).\n    align (Union[Align, tuple[Align, Align]]): align min, center, or max of object.\n    diagonal (float): major radius\n    local_locations (list{Location}): locations relative to workplane\n\nRaises:\n    ValueError: Spacing and count must be > 0"
        },
        {
            "name": "build123d.Hole",
            "signature": "build123d.Hole(radius: 'float', depth: 'float' = None, mode: 'Mode' = <Mode.SUBTRACT>)",
            "methods": [
                {
                    "name": "build123d.Hole.bounding_box",
                    "signature": "build123d.Hole.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Hole.cast",
                    "signature": "build123d.Hole.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Hole.center",
                    "signature": "build123d.Hole.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Hole.chamfer",
                    "signature": "build123d.Hole.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Hole.clean",
                    "signature": "build123d.Hole.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Hole.closest_points",
                    "signature": "build123d.Hole.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Hole.combined_center",
                    "signature": "build123d.Hole.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Hole.compound",
                    "signature": "build123d.Hole.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Hole.compounds",
                    "signature": "build123d.Hole.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Hole.compute_mass",
                    "signature": "build123d.Hole.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.copy",
                    "signature": "build123d.Hole.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Hole.copy_attributes_to",
                    "signature": "build123d.Hole.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Hole.cut",
                    "signature": "build123d.Hole.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.distance",
                    "signature": "build123d.Hole.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.distance_to",
                    "signature": "build123d.Hole.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Hole.distance_to_with_closest_points",
                    "signature": "build123d.Hole.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Hole.distances",
                    "signature": "build123d.Hole.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.do_children_intersect",
                    "signature": "build123d.Hole.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Hole.dprism",
                    "signature": "build123d.Hole.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Hole.edge",
                    "signature": "build123d.Hole.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Hole.edges",
                    "signature": "build123d.Hole.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Hole.export_brep",
                    "signature": "build123d.Hole.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.export_step",
                    "signature": "build123d.Hole.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Hole.export_stl",
                    "signature": "build123d.Hole.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Hole.extrude",
                    "signature": "build123d.Hole.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Hole.face",
                    "signature": "build123d.Hole.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Hole.faces",
                    "signature": "build123d.Hole.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Hole.faces_intersected_by_axis",
                    "signature": "build123d.Hole.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Hole.fillet",
                    "signature": "build123d.Hole.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Hole.find_intersection",
                    "signature": "build123d.Hole.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Hole.find_intersection_points",
                    "signature": "build123d.Hole.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Hole.first_level_shapes",
                    "signature": "build123d.Hole.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Hole.fix",
                    "signature": "build123d.Hole.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Hole.fuse",
                    "signature": "build123d.Hole.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.get_type",
                    "signature": "build123d.Hole.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Hole.hash_code",
                    "signature": "build123d.Hole.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.hollow",
                    "signature": "build123d.Hole.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Hole.intersect",
                    "signature": "build123d.Hole.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.is_equal",
                    "signature": "build123d.Hole.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.is_inside",
                    "signature": "build123d.Hole.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Hole.is_null",
                    "signature": "build123d.Hole.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.is_same",
                    "signature": "build123d.Hole.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.is_valid",
                    "signature": "build123d.Hole.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.iter_path_reverse",
                    "signature": "build123d.Hole.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Hole.locate",
                    "signature": "build123d.Hole.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.located",
                    "signature": "build123d.Hole.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Hole.make_compound",
                    "signature": "build123d.Hole.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Hole.make_text",
                    "signature": "build123d.Hole.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Hole.make_triad",
                    "signature": "build123d.Hole.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Hole.max_fillet",
                    "signature": "build123d.Hole.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Hole.mesh",
                    "signature": "build123d.Hole.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.mirror",
                    "signature": "build123d.Hole.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Hole.move",
                    "signature": "build123d.Hole.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.moved",
                    "signature": "build123d.Hole.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Hole.offset_3d",
                    "signature": "build123d.Hole.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Hole.project_faces",
                    "signature": "build123d.Hole.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Hole.project_to_viewport",
                    "signature": "build123d.Hole.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Hole.relocate",
                    "signature": "build123d.Hole.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Hole.rotate",
                    "signature": "build123d.Hole.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Hole.scale",
                    "signature": "build123d.Hole.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.shape_type",
                    "signature": "build123d.Hole.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Hole.shell",
                    "signature": "build123d.Hole.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Hole.shells",
                    "signature": "build123d.Hole.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Hole.show_topology",
                    "signature": "build123d.Hole.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Hole.solid",
                    "signature": "build123d.Hole.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Hole.solids",
                    "signature": "build123d.Hole.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Hole.split",
                    "signature": "build123d.Hole.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Hole.split_by_perimeter",
                    "signature": "build123d.Hole.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Hole.tessellate",
                    "signature": "build123d.Hole.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Hole.to_arcs",
                    "signature": "build123d.Hole.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Hole.to_splines",
                    "signature": "build123d.Hole.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Hole.to_vtk_poly_data",
                    "signature": "build123d.Hole.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Hole.transform_geometry",
                    "signature": "build123d.Hole.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Hole.transform_shape",
                    "signature": "build123d.Hole.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Hole.transformed",
                    "signature": "build123d.Hole.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Hole.translate",
                    "signature": "build123d.Hole.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Hole.unwrap",
                    "signature": "build123d.Hole.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Hole.vertex",
                    "signature": "build123d.Hole.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Hole.vertices",
                    "signature": "build123d.Hole.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Hole.wire",
                    "signature": "build123d.Hole.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Hole.wires",
                    "signature": "build123d.Hole.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Part Operation: Hole\n\nCreate a hole in part.\n\nArgs:\n    radius (float): hole size\n    depth (float, optional): hole depth - None implies through part. Defaults to None.\n    mode (Mode, optional): combination mode. Defaults to Mode.SUBTRACT."
        },
        {
            "name": "build123d.IntersectingLine",
            "signature": "build123d.IntersectingLine(start: 'VectorLike', direction: 'VectorLike', other: 'Union[Curve, Edge, Wire]', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.IntersectingLine.bounding_box",
                    "signature": "build123d.IntersectingLine.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.IntersectingLine.cast",
                    "signature": "build123d.IntersectingLine.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.IntersectingLine.center",
                    "signature": "build123d.IntersectingLine.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.IntersectingLine.clean",
                    "signature": "build123d.IntersectingLine.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.IntersectingLine.close",
                    "signature": "build123d.IntersectingLine.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.IntersectingLine.closest_points",
                    "signature": "build123d.IntersectingLine.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.IntersectingLine.combined_center",
                    "signature": "build123d.IntersectingLine.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.IntersectingLine.common_plane",
                    "signature": "build123d.IntersectingLine.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.IntersectingLine.compound",
                    "signature": "build123d.IntersectingLine.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.IntersectingLine.compounds",
                    "signature": "build123d.IntersectingLine.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.IntersectingLine.compute_mass",
                    "signature": "build123d.IntersectingLine.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.copy",
                    "signature": "build123d.IntersectingLine.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.IntersectingLine.copy_attributes_to",
                    "signature": "build123d.IntersectingLine.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.IntersectingLine.cut",
                    "signature": "build123d.IntersectingLine.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.distance",
                    "signature": "build123d.IntersectingLine.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.distance_to",
                    "signature": "build123d.IntersectingLine.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.IntersectingLine.distance_to_with_closest_points",
                    "signature": "build123d.IntersectingLine.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.IntersectingLine.distances",
                    "signature": "build123d.IntersectingLine.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.distribute_locations",
                    "signature": "build123d.IntersectingLine.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.IntersectingLine.edge",
                    "signature": "build123d.IntersectingLine.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.IntersectingLine.edges",
                    "signature": "build123d.IntersectingLine.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.IntersectingLine.end_point",
                    "signature": "build123d.IntersectingLine.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.IntersectingLine.export_brep",
                    "signature": "build123d.IntersectingLine.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.export_step",
                    "signature": "build123d.IntersectingLine.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.IntersectingLine.export_stl",
                    "signature": "build123d.IntersectingLine.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.IntersectingLine.extrude",
                    "signature": "build123d.IntersectingLine.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.IntersectingLine.face",
                    "signature": "build123d.IntersectingLine.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.IntersectingLine.faces",
                    "signature": "build123d.IntersectingLine.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.IntersectingLine.faces_intersected_by_axis",
                    "signature": "build123d.IntersectingLine.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.IntersectingLine.find_intersection",
                    "signature": "build123d.IntersectingLine.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.IntersectingLine.find_intersection_points",
                    "signature": "build123d.IntersectingLine.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.IntersectingLine.find_tangent",
                    "signature": "build123d.IntersectingLine.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.IntersectingLine.fix",
                    "signature": "build123d.IntersectingLine.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.IntersectingLine.fuse",
                    "signature": "build123d.IntersectingLine.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.IntersectingLine.hash_code",
                    "signature": "build123d.IntersectingLine.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.intersect",
                    "signature": "build123d.IntersectingLine.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.IntersectingLine.is_equal",
                    "signature": "build123d.IntersectingLine.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.is_null",
                    "signature": "build123d.IntersectingLine.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.is_same",
                    "signature": "build123d.IntersectingLine.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.is_valid",
                    "signature": "build123d.IntersectingLine.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.iter_path_reverse",
                    "signature": "build123d.IntersectingLine.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.IntersectingLine.locate",
                    "signature": "build123d.IntersectingLine.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.located",
                    "signature": "build123d.IntersectingLine.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.IntersectingLine.location_at",
                    "signature": "build123d.IntersectingLine.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.IntersectingLine.locations",
                    "signature": "build123d.IntersectingLine.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.IntersectingLine.make_bezier",
                    "signature": "build123d.IntersectingLine.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.IntersectingLine.make_circle",
                    "signature": "build123d.IntersectingLine.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.IntersectingLine.make_ellipse",
                    "signature": "build123d.IntersectingLine.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.IntersectingLine.make_helix",
                    "signature": "build123d.IntersectingLine.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.IntersectingLine.make_line",
                    "signature": "build123d.IntersectingLine.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.IntersectingLine.make_mid_way",
                    "signature": "build123d.IntersectingLine.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.IntersectingLine.make_spline",
                    "signature": "build123d.IntersectingLine.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.IntersectingLine.make_spline_approx",
                    "signature": "build123d.IntersectingLine.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.IntersectingLine.make_tangent_arc",
                    "signature": "build123d.IntersectingLine.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.IntersectingLine.make_three_point_arc",
                    "signature": "build123d.IntersectingLine.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.IntersectingLine.mesh",
                    "signature": "build123d.IntersectingLine.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.mirror",
                    "signature": "build123d.IntersectingLine.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.IntersectingLine.move",
                    "signature": "build123d.IntersectingLine.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.moved",
                    "signature": "build123d.IntersectingLine.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.IntersectingLine.normal",
                    "signature": "build123d.IntersectingLine.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.offset_2d",
                    "signature": "build123d.IntersectingLine.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.IntersectingLine.param_at",
                    "signature": "build123d.IntersectingLine.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.IntersectingLine.param_at_point",
                    "signature": "build123d.IntersectingLine.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.IntersectingLine.perpendicular_line",
                    "signature": "build123d.IntersectingLine.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.IntersectingLine.position_at",
                    "signature": "build123d.IntersectingLine.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.IntersectingLine.positions",
                    "signature": "build123d.IntersectingLine.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.IntersectingLine.project",
                    "signature": "build123d.IntersectingLine.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.project_faces",
                    "signature": "build123d.IntersectingLine.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.IntersectingLine.project_to_shape",
                    "signature": "build123d.IntersectingLine.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.IntersectingLine.project_to_viewport",
                    "signature": "build123d.IntersectingLine.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.IntersectingLine.relocate",
                    "signature": "build123d.IntersectingLine.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.IntersectingLine.reversed",
                    "signature": "build123d.IntersectingLine.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.IntersectingLine.rotate",
                    "signature": "build123d.IntersectingLine.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.IntersectingLine.scale",
                    "signature": "build123d.IntersectingLine.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.shape_type",
                    "signature": "build123d.IntersectingLine.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.IntersectingLine.shell",
                    "signature": "build123d.IntersectingLine.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.IntersectingLine.shells",
                    "signature": "build123d.IntersectingLine.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.IntersectingLine.show_topology",
                    "signature": "build123d.IntersectingLine.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.IntersectingLine.solid",
                    "signature": "build123d.IntersectingLine.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.IntersectingLine.solids",
                    "signature": "build123d.IntersectingLine.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.IntersectingLine.split",
                    "signature": "build123d.IntersectingLine.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.IntersectingLine.split_by_perimeter",
                    "signature": "build123d.IntersectingLine.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.IntersectingLine.start_point",
                    "signature": "build123d.IntersectingLine.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.IntersectingLine.tangent_angle_at",
                    "signature": "build123d.IntersectingLine.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.IntersectingLine.tangent_at",
                    "signature": "build123d.IntersectingLine.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.IntersectingLine.tessellate",
                    "signature": "build123d.IntersectingLine.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.IntersectingLine.to_arcs",
                    "signature": "build123d.IntersectingLine.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.IntersectingLine.to_axis",
                    "signature": "build123d.IntersectingLine.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.IntersectingLine.to_splines",
                    "signature": "build123d.IntersectingLine.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.IntersectingLine.to_vtk_poly_data",
                    "signature": "build123d.IntersectingLine.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.IntersectingLine.to_wire",
                    "signature": "build123d.IntersectingLine.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.IntersectingLine.transform_geometry",
                    "signature": "build123d.IntersectingLine.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.IntersectingLine.transform_shape",
                    "signature": "build123d.IntersectingLine.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.IntersectingLine.transformed",
                    "signature": "build123d.IntersectingLine.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.IntersectingLine.translate",
                    "signature": "build123d.IntersectingLine.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.IntersectingLine.trim",
                    "signature": "build123d.IntersectingLine.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.IntersectingLine.trim_to_length",
                    "signature": "build123d.IntersectingLine.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.IntersectingLine.vertex",
                    "signature": "build123d.IntersectingLine.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.IntersectingLine.vertices",
                    "signature": "build123d.IntersectingLine.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.IntersectingLine.wire",
                    "signature": "build123d.IntersectingLine.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.IntersectingLine.wires",
                    "signature": "build123d.IntersectingLine.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Intersecting Line Object: Line\n\nAdd a straight line that intersects another line at a given parameter and angle.\n\nArgs:\n    start (VectorLike): start point\n    direction (VectorLike): direction to make line\n    other (Edge): stop at the intersection of other\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Intrinsic",
            "signature": "build123d.Intrinsic()",
            "methods": [],
            "variables": [
                "XYX",
                "XYZ",
                "XZX",
                "XZY",
                "YXY",
                "YXZ",
                "YZX",
                "YZY",
                "ZXY",
                "ZXZ",
                "ZYX",
                "ZYZ",
                "name",
                "value"
            ],
            "docstring": "Order to apply intrinsic rotations by axis"
        },
        {
            "name": "build123d.JernArc",
            "signature": "build123d.JernArc(start: 'VectorLike', tangent: 'VectorLike', radius: 'float', arc_size: 'float', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.JernArc.bounding_box",
                    "signature": "build123d.JernArc.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.JernArc.cast",
                    "signature": "build123d.JernArc.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.JernArc.center",
                    "signature": "build123d.JernArc.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.JernArc.clean",
                    "signature": "build123d.JernArc.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.JernArc.close",
                    "signature": "build123d.JernArc.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.JernArc.closest_points",
                    "signature": "build123d.JernArc.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.JernArc.combined_center",
                    "signature": "build123d.JernArc.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.JernArc.common_plane",
                    "signature": "build123d.JernArc.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.JernArc.compound",
                    "signature": "build123d.JernArc.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.JernArc.compounds",
                    "signature": "build123d.JernArc.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.JernArc.compute_mass",
                    "signature": "build123d.JernArc.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.copy",
                    "signature": "build123d.JernArc.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.JernArc.copy_attributes_to",
                    "signature": "build123d.JernArc.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.JernArc.cut",
                    "signature": "build123d.JernArc.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.distance",
                    "signature": "build123d.JernArc.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.distance_to",
                    "signature": "build123d.JernArc.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.JernArc.distance_to_with_closest_points",
                    "signature": "build123d.JernArc.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.JernArc.distances",
                    "signature": "build123d.JernArc.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.distribute_locations",
                    "signature": "build123d.JernArc.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.JernArc.edge",
                    "signature": "build123d.JernArc.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.JernArc.edges",
                    "signature": "build123d.JernArc.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.JernArc.end_point",
                    "signature": "build123d.JernArc.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.JernArc.export_brep",
                    "signature": "build123d.JernArc.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.export_step",
                    "signature": "build123d.JernArc.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.JernArc.export_stl",
                    "signature": "build123d.JernArc.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.JernArc.extrude",
                    "signature": "build123d.JernArc.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.JernArc.face",
                    "signature": "build123d.JernArc.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.JernArc.faces",
                    "signature": "build123d.JernArc.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.JernArc.faces_intersected_by_axis",
                    "signature": "build123d.JernArc.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.JernArc.find_intersection",
                    "signature": "build123d.JernArc.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.JernArc.find_intersection_points",
                    "signature": "build123d.JernArc.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.JernArc.find_tangent",
                    "signature": "build123d.JernArc.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.JernArc.fix",
                    "signature": "build123d.JernArc.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.JernArc.fuse",
                    "signature": "build123d.JernArc.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.JernArc.hash_code",
                    "signature": "build123d.JernArc.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.intersect",
                    "signature": "build123d.JernArc.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.JernArc.is_equal",
                    "signature": "build123d.JernArc.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.is_null",
                    "signature": "build123d.JernArc.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.is_same",
                    "signature": "build123d.JernArc.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.is_valid",
                    "signature": "build123d.JernArc.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.iter_path_reverse",
                    "signature": "build123d.JernArc.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.JernArc.locate",
                    "signature": "build123d.JernArc.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.located",
                    "signature": "build123d.JernArc.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.JernArc.location_at",
                    "signature": "build123d.JernArc.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.JernArc.locations",
                    "signature": "build123d.JernArc.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.JernArc.make_bezier",
                    "signature": "build123d.JernArc.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.JernArc.make_circle",
                    "signature": "build123d.JernArc.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.JernArc.make_ellipse",
                    "signature": "build123d.JernArc.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.JernArc.make_helix",
                    "signature": "build123d.JernArc.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.JernArc.make_line",
                    "signature": "build123d.JernArc.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.JernArc.make_mid_way",
                    "signature": "build123d.JernArc.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.JernArc.make_spline",
                    "signature": "build123d.JernArc.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.JernArc.make_spline_approx",
                    "signature": "build123d.JernArc.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.JernArc.make_tangent_arc",
                    "signature": "build123d.JernArc.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.JernArc.make_three_point_arc",
                    "signature": "build123d.JernArc.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.JernArc.mesh",
                    "signature": "build123d.JernArc.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.mirror",
                    "signature": "build123d.JernArc.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.JernArc.move",
                    "signature": "build123d.JernArc.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.moved",
                    "signature": "build123d.JernArc.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.JernArc.normal",
                    "signature": "build123d.JernArc.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.offset_2d",
                    "signature": "build123d.JernArc.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.JernArc.param_at",
                    "signature": "build123d.JernArc.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.JernArc.param_at_point",
                    "signature": "build123d.JernArc.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.JernArc.perpendicular_line",
                    "signature": "build123d.JernArc.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.JernArc.position_at",
                    "signature": "build123d.JernArc.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.JernArc.positions",
                    "signature": "build123d.JernArc.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.JernArc.project",
                    "signature": "build123d.JernArc.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.project_faces",
                    "signature": "build123d.JernArc.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.JernArc.project_to_shape",
                    "signature": "build123d.JernArc.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.JernArc.project_to_viewport",
                    "signature": "build123d.JernArc.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.JernArc.relocate",
                    "signature": "build123d.JernArc.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.JernArc.reversed",
                    "signature": "build123d.JernArc.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.JernArc.rotate",
                    "signature": "build123d.JernArc.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.JernArc.scale",
                    "signature": "build123d.JernArc.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.shape_type",
                    "signature": "build123d.JernArc.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.JernArc.shell",
                    "signature": "build123d.JernArc.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.JernArc.shells",
                    "signature": "build123d.JernArc.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.JernArc.show_topology",
                    "signature": "build123d.JernArc.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.JernArc.solid",
                    "signature": "build123d.JernArc.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.JernArc.solids",
                    "signature": "build123d.JernArc.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.JernArc.split",
                    "signature": "build123d.JernArc.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.JernArc.split_by_perimeter",
                    "signature": "build123d.JernArc.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.JernArc.start_point",
                    "signature": "build123d.JernArc.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.JernArc.tangent_angle_at",
                    "signature": "build123d.JernArc.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.JernArc.tangent_at",
                    "signature": "build123d.JernArc.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.JernArc.tessellate",
                    "signature": "build123d.JernArc.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.JernArc.to_arcs",
                    "signature": "build123d.JernArc.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.JernArc.to_axis",
                    "signature": "build123d.JernArc.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.JernArc.to_splines",
                    "signature": "build123d.JernArc.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.JernArc.to_vtk_poly_data",
                    "signature": "build123d.JernArc.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.JernArc.to_wire",
                    "signature": "build123d.JernArc.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.JernArc.transform_geometry",
                    "signature": "build123d.JernArc.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.JernArc.transform_shape",
                    "signature": "build123d.JernArc.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.JernArc.transformed",
                    "signature": "build123d.JernArc.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.JernArc.translate",
                    "signature": "build123d.JernArc.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.JernArc.trim",
                    "signature": "build123d.JernArc.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.JernArc.trim_to_length",
                    "signature": "build123d.JernArc.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.JernArc.vertex",
                    "signature": "build123d.JernArc.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.JernArc.vertices",
                    "signature": "build123d.JernArc.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.JernArc.wire",
                    "signature": "build123d.JernArc.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.JernArc.wires",
                    "signature": "build123d.JernArc.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "JernArc\n\nCircular tangent arc with given radius and arc_size\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): tangent at start point\n    radius (float): arc radius\n    arc_size (float): arc size in degrees (negative to change direction)\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nAttributes:\n    start (Vector): start point\n    end_of_arc (Vector): end point of arc\n    center_point (Vector): center of arc"
        },
        {
            "name": "build123d.Joint",
            "signature": "build123d.Joint(label: 'str', parent: 'Union[Solid, Compound]')",
            "methods": [
                {
                    "name": "build123d.Joint.connect_to",
                    "signature": "build123d.Joint.connect_to(self, other: 'Joint')",
                    "docstring": "All derived classes must provide a connect_to method"
                },
                {
                    "name": "build123d.Joint.relative_to",
                    "signature": "build123d.Joint.relative_to(self, other: 'Joint') -> 'Location'",
                    "docstring": "Return relative location to another joint"
                }
            ],
            "variables": [
                "location",
                "symbol"
            ],
            "docstring": "Joint\n\nAbstract Base Joint class - used to join two components together\n\nArgs:\n    parent (Union[Solid, Compound]): object that joint to bound to\n\nAttributes:\n    label (str): user assigned label\n    parent (Shape): object joint is bound to\n    connected_to (Joint): joint that is connect to this joint"
        },
        {
            "name": "build123d.Keep",
            "signature": "build123d.Keep()",
            "methods": [],
            "variables": [
                "BOTH",
                "BOTTOM",
                "INSIDE",
                "OUTSIDE",
                "TOP",
                "name",
                "value"
            ],
            "docstring": "Split options"
        },
        {
            "name": "build123d.Kind",
            "signature": "build123d.Kind()",
            "methods": [],
            "variables": [
                "ARC",
                "INTERSECTION",
                "TANGENT",
                "name",
                "value"
            ],
            "docstring": "Offset corner transition"
        },
        {
            "name": "build123d.LengthMode",
            "signature": "build123d.LengthMode()",
            "methods": [],
            "variables": [
                "DIAGONAL",
                "HORIZONTAL",
                "VERTICAL",
                "name",
                "value"
            ],
            "docstring": "Method of specifying length along PolarLine"
        },
        {
            "name": "build123d.Line",
            "signature": "build123d.Line(*pts: 'Union[VectorLike, Iterable[VectorLike]]', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Line.bounding_box",
                    "signature": "build123d.Line.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Line.cast",
                    "signature": "build123d.Line.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Line.center",
                    "signature": "build123d.Line.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Line.clean",
                    "signature": "build123d.Line.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Line.close",
                    "signature": "build123d.Line.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.Line.closest_points",
                    "signature": "build123d.Line.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Line.combined_center",
                    "signature": "build123d.Line.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Line.common_plane",
                    "signature": "build123d.Line.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.Line.compound",
                    "signature": "build123d.Line.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Line.compounds",
                    "signature": "build123d.Line.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Line.compute_mass",
                    "signature": "build123d.Line.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.copy",
                    "signature": "build123d.Line.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Line.copy_attributes_to",
                    "signature": "build123d.Line.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Line.cut",
                    "signature": "build123d.Line.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.distance",
                    "signature": "build123d.Line.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.distance_to",
                    "signature": "build123d.Line.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Line.distance_to_with_closest_points",
                    "signature": "build123d.Line.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Line.distances",
                    "signature": "build123d.Line.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.distribute_locations",
                    "signature": "build123d.Line.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.Line.edge",
                    "signature": "build123d.Line.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Line.edges",
                    "signature": "build123d.Line.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Line.end_point",
                    "signature": "build123d.Line.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Line.export_brep",
                    "signature": "build123d.Line.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.export_step",
                    "signature": "build123d.Line.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Line.export_stl",
                    "signature": "build123d.Line.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Line.extrude",
                    "signature": "build123d.Line.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Line.face",
                    "signature": "build123d.Line.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Line.faces",
                    "signature": "build123d.Line.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Line.faces_intersected_by_axis",
                    "signature": "build123d.Line.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Line.find_intersection",
                    "signature": "build123d.Line.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Line.find_intersection_points",
                    "signature": "build123d.Line.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.Line.find_tangent",
                    "signature": "build123d.Line.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.Line.fix",
                    "signature": "build123d.Line.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Line.fuse",
                    "signature": "build123d.Line.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Line.hash_code",
                    "signature": "build123d.Line.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.intersect",
                    "signature": "build123d.Line.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Line.is_equal",
                    "signature": "build123d.Line.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.is_null",
                    "signature": "build123d.Line.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.is_same",
                    "signature": "build123d.Line.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.is_valid",
                    "signature": "build123d.Line.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.iter_path_reverse",
                    "signature": "build123d.Line.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Line.locate",
                    "signature": "build123d.Line.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.located",
                    "signature": "build123d.Line.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Line.location_at",
                    "signature": "build123d.Line.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.Line.locations",
                    "signature": "build123d.Line.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.Line.make_bezier",
                    "signature": "build123d.Line.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.Line.make_circle",
                    "signature": "build123d.Line.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.Line.make_ellipse",
                    "signature": "build123d.Line.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.Line.make_helix",
                    "signature": "build123d.Line.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.Line.make_line",
                    "signature": "build123d.Line.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.Line.make_mid_way",
                    "signature": "build123d.Line.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.Line.make_spline",
                    "signature": "build123d.Line.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.Line.make_spline_approx",
                    "signature": "build123d.Line.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.Line.make_tangent_arc",
                    "signature": "build123d.Line.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.Line.make_three_point_arc",
                    "signature": "build123d.Line.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.Line.mesh",
                    "signature": "build123d.Line.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Line.mirror",
                    "signature": "build123d.Line.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Line.move",
                    "signature": "build123d.Line.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.moved",
                    "signature": "build123d.Line.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Line.normal",
                    "signature": "build123d.Line.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.offset_2d",
                    "signature": "build123d.Line.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.Line.param_at",
                    "signature": "build123d.Line.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.Line.param_at_point",
                    "signature": "build123d.Line.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.Line.perpendicular_line",
                    "signature": "build123d.Line.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.Line.position_at",
                    "signature": "build123d.Line.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.Line.positions",
                    "signature": "build123d.Line.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.Line.project",
                    "signature": "build123d.Line.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.Line.project_faces",
                    "signature": "build123d.Line.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Line.project_to_shape",
                    "signature": "build123d.Line.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.Line.project_to_viewport",
                    "signature": "build123d.Line.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Line.relocate",
                    "signature": "build123d.Line.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Line.reversed",
                    "signature": "build123d.Line.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.Line.rotate",
                    "signature": "build123d.Line.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Line.scale",
                    "signature": "build123d.Line.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.shape_type",
                    "signature": "build123d.Line.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Line.shell",
                    "signature": "build123d.Line.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Line.shells",
                    "signature": "build123d.Line.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Line.show_topology",
                    "signature": "build123d.Line.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Line.solid",
                    "signature": "build123d.Line.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Line.solids",
                    "signature": "build123d.Line.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Line.split",
                    "signature": "build123d.Line.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Line.split_by_perimeter",
                    "signature": "build123d.Line.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Line.start_point",
                    "signature": "build123d.Line.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Line.tangent_angle_at",
                    "signature": "build123d.Line.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.Line.tangent_at",
                    "signature": "build123d.Line.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.Line.tessellate",
                    "signature": "build123d.Line.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Line.to_arcs",
                    "signature": "build123d.Line.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Line.to_axis",
                    "signature": "build123d.Line.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.Line.to_splines",
                    "signature": "build123d.Line.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Line.to_vtk_poly_data",
                    "signature": "build123d.Line.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Line.to_wire",
                    "signature": "build123d.Line.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.Line.transform_geometry",
                    "signature": "build123d.Line.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Line.transform_shape",
                    "signature": "build123d.Line.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Line.transformed",
                    "signature": "build123d.Line.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Line.translate",
                    "signature": "build123d.Line.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Line.trim",
                    "signature": "build123d.Line.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.Line.trim_to_length",
                    "signature": "build123d.Line.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.Line.vertex",
                    "signature": "build123d.Line.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Line.vertices",
                    "signature": "build123d.Line.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Line.wire",
                    "signature": "build123d.Line.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Line.wires",
                    "signature": "build123d.Line.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Line\n\nAdd a straight line defined by two end points.\n\nArgs:\n    pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two points\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: Two point not provided"
        },
        {
            "name": "build123d.LineType",
            "signature": "build123d.LineType()",
            "methods": [],
            "variables": [
                "BORDER",
                "BORDER2",
                "BORDERX2",
                "CENTER",
                "CENTER2",
                "CENTERX2",
                "CONTINUOUS",
                "DASHDOT",
                "DASHDOT2",
                "DASHDOTX2",
                "DASHED",
                "DASHED2",
                "DASHEDX2",
                "DIVIDE",
                "DIVIDE2",
                "DIVIDEX2",
                "DOT",
                "DOT2",
                "DOTX2",
                "HIDDEN",
                "HIDDEN2",
                "HIDDENX2",
                "ISO_DASH",
                "ISO_DASH_DOT",
                "ISO_DASH_DOUBLE_DOT",
                "ISO_DASH_SPACE",
                "ISO_DASH_TRIPLE_DOT",
                "ISO_DOT",
                "ISO_DOUBLE_DASH_DOT",
                "ISO_DOUBLE_DASH_DOUBLE_DOT",
                "ISO_DOUBLE_DASH_TRIPLE_DOT",
                "ISO_LONG_DASH_DOT",
                "ISO_LONG_DASH_DOUBLE_DOT",
                "ISO_LONG_DASH_DOUBLE_SHORT_DASH",
                "ISO_LONG_DASH_SHORT_DASH",
                "ISO_LONG_DASH_TRIPLE_DOT",
                "PHANTOM",
                "PHANTOM2",
                "PHANTOMX2"
            ],
            "docstring": "Line Types"
        },
        {
            "name": "build123d.LinearJoint",
            "signature": "build123d.LinearJoint(label: 'str', to_part: 'Union[Solid, Compound]' = None, axis: 'Axis' = ((0.0, 0.0, 0.0),(0.0, 0.0, 1.0)), linear_range: 'tuple[float, float]' = (0, inf))",
            "methods": [
                {
                    "name": "build123d.LinearJoint.connect_to",
                    "signature": "build123d.LinearJoint.connect_to(self, other: 'Joint', **kwargs)",
                    "docstring": "Connect LinearJoint to another Joint\n\nArgs:\n    other (Joint): joint to connect to\n    angle (float, optional): angle in degrees. Defaults to range min.\n    position (float, optional): linear position. Defaults to linear range min.\n\nRaises:\n    TypeError: other must be of type RevoluteJoint or RigidJoint\n    ValueError: position out of range\n    ValueError: angle out of range"
                },
                {
                    "name": "build123d.LinearJoint.relative_to",
                    "signature": "build123d.LinearJoint.relative_to(self, other, **kwargs)",
                    "docstring": "Relative location of LinearJoint to RevoluteJoint or RigidJoint\n\nArgs:\n    other (Joint): joint to connect to\n    angle (float, optional): angle in degrees. Defaults to range min.\n    position (float, optional): linear position. Defaults to linear range min.\n\nRaises:\n    TypeError: other must be of type RevoluteJoint or RigidJoint\n    ValueError: position out of range\n    ValueError: angle out of range"
                }
            ],
            "variables": [
                "location",
                "symbol"
            ],
            "docstring": "LinearJoint\n\nComponent moves along a single axis.\n\nArgs:\n    label (str): joint label\n    to_part (Union[Solid, Compound], optional): object to attach joint to\n    axis (Axis): axis of linear motion\n    range (tuple[float, float], optional): (min,max) position of joint.\n        Defaults to (0, inf).\n\nAttributes:\n    axis (Axis): joint axis\n    angle (float): angle of joint\n    linear_range (tuple[float,float]): min and max positional values\n    position (float): joint position\n    relative_axis (Axis): joint axis relative to bound part"
        },
        {
            "name": "build123d.Location",
            "signature": "build123d.Location(*args)",
            "methods": [
                {
                    "name": "build123d.Location.intersect",
                    "signature": "build123d.Location.intersect(self, *args, **kwargs)",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Location.inverse",
                    "signature": "build123d.Location.inverse(self) -> 'Location'",
                    "docstring": "Inverted location"
                },
                {
                    "name": "build123d.Location.to_axis",
                    "signature": "build123d.Location.to_axis(self) -> 'Axis'",
                    "docstring": "Convert the location into an Axis"
                },
                {
                    "name": "build123d.Location.to_tuple",
                    "signature": "build123d.Location.to_tuple(self) -> 'tuple[tuple[float, float, float], tuple[float, float, float]]'",
                    "docstring": "Convert the location to a translation, rotation tuple."
                }
            ],
            "variables": [
                "T",
                "orientation",
                "position",
                "x_axis",
                "y_axis",
                "z_axis"
            ],
            "docstring": "Location in 3D space. Depending on usage can be absolute or relative.\n\nThis class wraps the TopLoc_Location class from OCCT. It can be used to move Shape\nobjects in both relative and absolute manner. It is the preferred type to locate objects\nin build123d.\n\nAttributes:\n    wrapped (TopLoc_Location): the OCP location object"
        },
        {
            "name": "build123d.LocationEncoder",
            "signature": "build123d.LocationEncoder()",
            "methods": [
                {
                    "name": "build123d.LocationEncoder.default",
                    "signature": "build123d.LocationEncoder.default(self, o: 'Location') -> 'dict'",
                    "docstring": "Return a serializable object"
                },
                {
                    "name": "build123d.LocationEncoder.encode",
                    "signature": "build123d.LocationEncoder.encode(self, o)",
                    "docstring": "Return a JSON string representation of a Python data structure.\n\n>>> from json.encoder import JSONEncoder\n>>> JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n'{\"foo\": [\"bar\", \"baz\"]}'"
                },
                {
                    "name": "build123d.LocationEncoder.iterencode",
                    "signature": "build123d.LocationEncoder.iterencode(self, o, _one_shot=False)",
                    "docstring": "Encode the given object and yield each string\nrepresentation as available.\n\nFor example::\n\n    for chunk in JSONEncoder().iterencode(bigobject):\n        mysocket.write(chunk)"
                },
                {
                    "name": "build123d.LocationEncoder.location_hook",
                    "signature": "build123d.LocationEncoder.location_hook(obj) -> 'dict'",
                    "docstring": "Convert Locations loaded from json to Location objects\n\nExample:\n    read_json = json.load(infile, object_hook=LocationEncoder.location_hook)"
                }
            ],
            "variables": [
                "item_separator",
                "key_separator"
            ],
            "docstring": "Custom JSON Encoder for Location values\n\nExample:\n\n.. code::\n\n    data_dict = {\n        \"part1\": {\n            \"joint_one\": Location((1, 2, 3), (4, 5, 6)),\n            \"joint_two\": Location((7, 8, 9), (10, 11, 12)),\n        },\n        \"part2\": {\n            \"joint_one\": Location((13, 14, 15), (16, 17, 18)),\n            \"joint_two\": Location((19, 20, 21), (22, 23, 24)),\n        },\n    }\n    json_object = json.dumps(data_dict, indent=4, cls=LocationEncoder)\n    with open(\"sample.json\", \"w\") as outfile:\n        outfile.write(json_object)\n    with open(\"sample.json\", \"r\") as infile:\n        copy_data_dict = json.load(infile, object_hook=LocationEncoder.location_hook)"
        },
        {
            "name": "build123d.LocationList",
            "signature": "build123d.LocationList(locations: 'list[Location]')",
            "methods": [],
            "variables": [
                "locations"
            ],
            "docstring": "Location Context\n\nA stateful context of active locations. At least one must be active\nat all time. Note that local locations are stored and global locations\nare returned as a property of the local locations and the currently\nactive workplanes.\n\nArgs:\n    locations (list[Location]): list of locations to add to the context"
        },
        {
            "name": "build123d.Locations",
            "signature": "build123d.Locations(*pts: 'Union[VectorLike, Vertex, Location, Face, Plane, Axis, Iterable[VectorLike, Vertex, Location, Face, Plane, Axis]]')",
            "methods": [],
            "variables": [
                "locations"
            ],
            "docstring": "Location Context: Push Points\n\nCreates a context of locations for Part or Sketch\n\nArgs:\n    pts (Union[VectorLike, Vertex, Location, Face, Plane, Axis] or iterable of same):\n        sequence of points to push\n\nAttributes:\n    local_locations (list{Location}): locations relative to workplane"
        },
        {
            "name": "build123d.Matrix",
            "signature": "build123d.Matrix(matrix=None)",
            "methods": [
                {
                    "name": "build123d.Matrix.inverse",
                    "signature": "build123d.Matrix.inverse(self) -> 'Matrix'",
                    "docstring": "Invert Matrix"
                },
                {
                    "name": "build123d.Matrix.multiply",
                    "signature": "build123d.Matrix.multiply(self, other)",
                    "docstring": "Matrix multiplication"
                },
                {
                    "name": "build123d.Matrix.rotate",
                    "signature": "build123d.Matrix.rotate(self, axis: 'Axis', angle: 'float')",
                    "docstring": "General rotate about axis"
                },
                {
                    "name": "build123d.Matrix.transposed_list",
                    "signature": "build123d.Matrix.transposed_list(self) -> 'Sequence[float]'",
                    "docstring": "Needed by the cqparts gltf exporter"
                }
            ],
            "variables": [],
            "docstring": "A 3d , 4x4 transformation matrix.\n\nUsed to move geometry in space.\n\nThe provided \"matrix\" parameter may be None, a gp_GTrsf, or a nested list of\nvalues.\n\nIf given a nested list, it is expected to be of the form:\n\n    [[m11, m12, m13, m14],\n     [m21, m22, m23, m24],\n     [m31, m32, m33, m34]]\n\nA fourth row may be given, but it is expected to be: [0.0, 0.0, 0.0, 1.0]\nsince this is a transform matrix.\n\nAttributes:\n    wrapped (gp_GTrsf): the OCP transformation function"
        },
        {
            "name": "build123d.MeshType",
            "signature": "build123d.MeshType()",
            "methods": [],
            "variables": [
                "MODEL",
                "OTHER",
                "SOLIDSUPPORT",
                "SUPPORT",
                "name",
                "value"
            ],
            "docstring": "3MF mesh types typically for 3D printing"
        },
        {
            "name": "build123d.Mesher",
            "signature": "build123d.Mesher(unit: build123d.build_enums.Unit = <Unit.MM>)",
            "methods": [
                {
                    "name": "build123d.Mesher.add_code_to_metadata",
                    "signature": "build123d.Mesher.add_code_to_metadata(self)",
                    "docstring": "Add the code calling this method to the 3MF metadata with the custom\nname space `build123d`, name equal to the base file name and the type\nas `python`"
                },
                {
                    "name": "build123d.Mesher.add_meta_data",
                    "signature": "build123d.Mesher.add_meta_data(self, name_space: str, name: str, value: str, metadata_type: str, must_preserve: bool)",
                    "docstring": "add_meta_data\n\nAdd meta data to the models\n\nArgs:\n    name_space (str): categorizer of different metadata entries\n    name (str): metadata label\n    value (str): metadata content\n    metadata_type (str): metadata type\n    must_preserve (bool): metadata must not be removed if unused"
                },
                {
                    "name": "build123d.Mesher.add_shape",
                    "signature": "build123d.Mesher.add_shape(self, shape: Union[build123d.topology.Shape, Iterable[build123d.topology.Shape]], linear_deflection: float = 0.001, angular_deflection: float = 0.1, mesh_type: build123d.build_enums.MeshType = <MeshType.MODEL>, part_number: str = None, uuid_value: <module 'uuid' from '/home/pding/mambaforge/envs/codecad/lib/python3.11/uuid.py'> = None)",
                    "docstring": "add_shape\n\nAdd a shape to the 3MF/STL file.\n\nArgs:\n    shape (Union[Shape, Iterable[Shape]]): build123d object\n    linear_deflection (float, optional): mesh control for edges. Defaults to 0.001.\n    angular_deflection (float, optional): mesh control for non-planar surfaces.\n        Defaults to 0.1.\n    mesh_type (MeshType, optional): 3D printing use of mesh. Defaults to MeshType.MODEL.\n    part_number (str, optional): part #. Defaults to None.\n    uuid_value (uuid, optional): value from uuid package. Defaults to None.\n\nRaises:\n    RuntimeError: 3mf mesh is invalid\n    Warning: Degenerate shape skipped\n    Warning: 3mf mesh is not manifold"
                },
                {
                    "name": "build123d.Mesher.get_mesh_properties",
                    "signature": "build123d.Mesher.get_mesh_properties(self) -> list[dict]",
                    "docstring": "Retrieve the properties from all the meshes"
                },
                {
                    "name": "build123d.Mesher.get_meta_data",
                    "signature": "build123d.Mesher.get_meta_data(self) -> list[dict]",
                    "docstring": "Retrieve all of the metadata"
                },
                {
                    "name": "build123d.Mesher.get_meta_data_by_key",
                    "signature": "build123d.Mesher.get_meta_data_by_key(self, name_space: str, name: str) -> dict",
                    "docstring": "Retrive the metadata value and type for the provided name space and name"
                },
                {
                    "name": "build123d.Mesher.read",
                    "signature": "build123d.Mesher.read(self, file_name: Union[os.PathLike, str, bytes]) -> list[build123d.topology.Shape]",
                    "docstring": "read\n\nArgs:\n    file_name Union[PathLike, str, bytes]: file path\n\nRaises:\n    ValueError: Unknown file format - must be 3mf or stl\n\nReturns:\n    list[Shape]: build123d shapes extracted from mesh file"
                },
                {
                    "name": "build123d.Mesher.write",
                    "signature": "build123d.Mesher.write(self, file_name: Union[os.PathLike, str, bytes])",
                    "docstring": "write\n\nArgs:\n    file_name Union[Pathlike, str, bytes]: file path\n\nRaises:\n    ValueError: Unknown file format - must be 3mf or stl"
                }
            ],
            "variables": [
                "library_version",
                "mesh_count",
                "model_unit",
                "triangle_counts",
                "vertex_counts"
            ],
            "docstring": "Mesher\n\nTool for exporting and importing meshed objects stored in 3MF or STL files.\n\nArgs:\n    unit (Unit, optional): model units. Defaults to Unit.MM."
        },
        {
            "name": "build123d.Mixin1D",
            "signature": "build123d.Mixin1D()",
            "methods": [
                {
                    "name": "build123d.Mixin1D.center",
                    "signature": "build123d.Mixin1D.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Mixin1D.common_plane",
                    "signature": "build123d.Mixin1D.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.Mixin1D.end_point",
                    "signature": "build123d.Mixin1D.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Mixin1D.location_at",
                    "signature": "build123d.Mixin1D.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.Mixin1D.locations",
                    "signature": "build123d.Mixin1D.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.Mixin1D.normal",
                    "signature": "build123d.Mixin1D.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Mixin1D.offset_2d",
                    "signature": "build123d.Mixin1D.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.Mixin1D.param_at",
                    "signature": "build123d.Mixin1D.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.Mixin1D.perpendicular_line",
                    "signature": "build123d.Mixin1D.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.Mixin1D.position_at",
                    "signature": "build123d.Mixin1D.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.Mixin1D.positions",
                    "signature": "build123d.Mixin1D.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.Mixin1D.project",
                    "signature": "build123d.Mixin1D.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.Mixin1D.start_point",
                    "signature": "build123d.Mixin1D.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Mixin1D.tangent_angle_at",
                    "signature": "build123d.Mixin1D.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.Mixin1D.tangent_at",
                    "signature": "build123d.Mixin1D.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                }
            ],
            "variables": [
                "is_closed",
                "is_forward",
                "length",
                "radius",
                "volume"
            ],
            "docstring": "Methods to add to the Edge and Wire classes"
        },
        {
            "name": "build123d.Mixin3D",
            "signature": "build123d.Mixin3D()",
            "methods": [
                {
                    "name": "build123d.Mixin3D.center",
                    "signature": "build123d.Mixin3D.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Mixin3D.chamfer",
                    "signature": "build123d.Mixin3D.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Mixin3D.dprism",
                    "signature": "build123d.Mixin3D.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Mixin3D.fillet",
                    "signature": "build123d.Mixin3D.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Mixin3D.hollow",
                    "signature": "build123d.Mixin3D.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Mixin3D.is_inside",
                    "signature": "build123d.Mixin3D.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Mixin3D.max_fillet",
                    "signature": "build123d.Mixin3D.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Mixin3D.offset_3d",
                    "signature": "build123d.Mixin3D.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                }
            ],
            "variables": [],
            "docstring": "Additional methods to add to 3D Shape classes"
        },
        {
            "name": "build123d.Mode",
            "signature": "build123d.Mode()",
            "methods": [],
            "variables": [
                "ADD",
                "INTERSECT",
                "PRIVATE",
                "REPLACE",
                "SUBTRACT",
                "name",
                "value"
            ],
            "docstring": "Combination Mode"
        },
        {
            "name": "build123d.NumberDisplay",
            "signature": "build123d.NumberDisplay()",
            "methods": [],
            "variables": [
                "DECIMAL",
                "FRACTION",
                "name",
                "value"
            ],
            "docstring": "Methods for displaying numbers"
        },
        {
            "name": "build123d.PageSize",
            "signature": "build123d.PageSize()",
            "methods": [],
            "variables": [
                "A0",
                "A1",
                "A10",
                "A2",
                "A3",
                "A4",
                "A5",
                "A6",
                "A7",
                "A8",
                "A9",
                "LEDGER",
                "LEGAL",
                "LETTER",
                "name",
                "value"
            ],
            "docstring": "Align object about Axis"
        },
        {
            "name": "build123d.Part",
            "signature": "build123d.Part()",
            "methods": [
                {
                    "name": "build123d.Part.bounding_box",
                    "signature": "build123d.Part.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Part.cast",
                    "signature": "build123d.Part.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Part.center",
                    "signature": "build123d.Part.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Part.chamfer",
                    "signature": "build123d.Part.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Part.clean",
                    "signature": "build123d.Part.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Part.closest_points",
                    "signature": "build123d.Part.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Part.combined_center",
                    "signature": "build123d.Part.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Part.compound",
                    "signature": "build123d.Part.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Part.compounds",
                    "signature": "build123d.Part.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Part.compute_mass",
                    "signature": "build123d.Part.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.copy",
                    "signature": "build123d.Part.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Part.copy_attributes_to",
                    "signature": "build123d.Part.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Part.cut",
                    "signature": "build123d.Part.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.distance",
                    "signature": "build123d.Part.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.distance_to",
                    "signature": "build123d.Part.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Part.distance_to_with_closest_points",
                    "signature": "build123d.Part.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Part.distances",
                    "signature": "build123d.Part.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.do_children_intersect",
                    "signature": "build123d.Part.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Part.dprism",
                    "signature": "build123d.Part.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Part.edge",
                    "signature": "build123d.Part.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Part.edges",
                    "signature": "build123d.Part.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Part.export_brep",
                    "signature": "build123d.Part.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.export_step",
                    "signature": "build123d.Part.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Part.export_stl",
                    "signature": "build123d.Part.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Part.extrude",
                    "signature": "build123d.Part.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Part.face",
                    "signature": "build123d.Part.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Part.faces",
                    "signature": "build123d.Part.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Part.faces_intersected_by_axis",
                    "signature": "build123d.Part.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Part.fillet",
                    "signature": "build123d.Part.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Part.find_intersection",
                    "signature": "build123d.Part.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Part.find_intersection_points",
                    "signature": "build123d.Part.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Part.first_level_shapes",
                    "signature": "build123d.Part.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Part.fix",
                    "signature": "build123d.Part.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Part.fuse",
                    "signature": "build123d.Part.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Part.get_type",
                    "signature": "build123d.Part.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Part.hash_code",
                    "signature": "build123d.Part.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.hollow",
                    "signature": "build123d.Part.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Part.intersect",
                    "signature": "build123d.Part.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.is_equal",
                    "signature": "build123d.Part.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.is_inside",
                    "signature": "build123d.Part.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Part.is_null",
                    "signature": "build123d.Part.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.is_same",
                    "signature": "build123d.Part.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.is_valid",
                    "signature": "build123d.Part.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.iter_path_reverse",
                    "signature": "build123d.Part.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Part.locate",
                    "signature": "build123d.Part.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.located",
                    "signature": "build123d.Part.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Part.make_compound",
                    "signature": "build123d.Part.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Part.make_text",
                    "signature": "build123d.Part.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Part.make_triad",
                    "signature": "build123d.Part.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Part.max_fillet",
                    "signature": "build123d.Part.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Part.mesh",
                    "signature": "build123d.Part.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Part.mirror",
                    "signature": "build123d.Part.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Part.move",
                    "signature": "build123d.Part.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.moved",
                    "signature": "build123d.Part.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Part.offset_3d",
                    "signature": "build123d.Part.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Part.project_faces",
                    "signature": "build123d.Part.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Part.project_to_viewport",
                    "signature": "build123d.Part.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Part.relocate",
                    "signature": "build123d.Part.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Part.rotate",
                    "signature": "build123d.Part.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Part.scale",
                    "signature": "build123d.Part.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.shape_type",
                    "signature": "build123d.Part.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Part.shell",
                    "signature": "build123d.Part.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Part.shells",
                    "signature": "build123d.Part.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Part.show_topology",
                    "signature": "build123d.Part.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Part.solid",
                    "signature": "build123d.Part.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Part.solids",
                    "signature": "build123d.Part.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Part.split",
                    "signature": "build123d.Part.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Part.split_by_perimeter",
                    "signature": "build123d.Part.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Part.tessellate",
                    "signature": "build123d.Part.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Part.to_arcs",
                    "signature": "build123d.Part.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Part.to_splines",
                    "signature": "build123d.Part.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Part.to_vtk_poly_data",
                    "signature": "build123d.Part.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Part.transform_geometry",
                    "signature": "build123d.Part.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Part.transform_shape",
                    "signature": "build123d.Part.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Part.transformed",
                    "signature": "build123d.Part.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Part.translate",
                    "signature": "build123d.Part.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Part.unwrap",
                    "signature": "build123d.Part.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Part.vertex",
                    "signature": "build123d.Part.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Part.vertices",
                    "signature": "build123d.Part.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Part.wire",
                    "signature": "build123d.Part.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Part.wires",
                    "signature": "build123d.Part.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "A Compound containing 3D objects - aka Solids"
        },
        {
            "name": "build123d.Plane",
            "signature": "build123d.Plane(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Plane.contains",
                    "signature": "build123d.Plane.contains(self, obj: 'Union[VectorLike, Axis]', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "contains\n\nIs this point or Axis fully contained in this plane?\n\nArgs:\n    obj (Union[VectorLike,Axis]): point or Axis to  evaluate\n    tolerance (float, optional): comparison tolerance. Defaults to TOLERANCE.\n\nReturns:\n    bool: self contains point or Axis"
                },
                {
                    "name": "build123d.Plane.from_local_coords",
                    "signature": "build123d.Plane.from_local_coords(self, obj: 'Union[tuple, Vector, Any, BoundBox]')",
                    "docstring": "Reposition the object relative from this plane\n\nArgs:\n    obj: Union[VectorLike, Shape, BoundBox] an object to reposition. Note that\n    type Any refers to all topological classes.\n\nReturns:\n    an object of the same type, but repositioned to world coordinates"
                },
                {
                    "name": "build123d.Plane.get_topods_face_normal",
                    "signature": "build123d.Plane.get_topods_face_normal(face: 'TopoDS_Face') -> 'Vector'",
                    "docstring": "Find the normal at the center of a TopoDS_Face"
                },
                {
                    "name": "build123d.Plane.intersect",
                    "signature": "build123d.Plane.intersect(self, *args, **kwargs)",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Plane.location_between",
                    "signature": "build123d.Plane.location_between(self, other: 'Plane') -> 'Location'",
                    "docstring": "Return a location representing the translation from self to other"
                },
                {
                    "name": "build123d.Plane.move",
                    "signature": "build123d.Plane.move(self, loc: 'Location') -> 'Plane'",
                    "docstring": "Change the position & orientation of self by applying a relative location\n\nArgs:\n    loc (Location): relative change\n\nReturns:\n    Plane: relocated plane"
                },
                {
                    "name": "build123d.Plane.offset",
                    "signature": "build123d.Plane.offset(self, amount: 'float') -> 'Plane'",
                    "docstring": "Move the Plane by amount in the direction of z_dir"
                },
                {
                    "name": "build123d.Plane.reverse",
                    "signature": "build123d.Plane.reverse(self) -> 'Plane'",
                    "docstring": "Reverse z direction of plane"
                },
                {
                    "name": "build123d.Plane.rotated",
                    "signature": "build123d.Plane.rotated(self, rotation: 'VectorLike' = (0, 0, 0), ordering: 'Union[Extrinsic, Intrinsic]' = None) -> 'Plane'",
                    "docstring": "Returns a copy of this plane, rotated about the specified axes\n\nSince the z axis is always normal the plane, rotating around Z will\nalways produce a plane that is parallel to this one.\n\nThe origin of the workplane is unaffected by the rotation.\n\nRotations are done in order x, y, z. If you need a different order,\nmanually chain together multiple rotate() commands.\n\nArgs:\n    rotation (VectorLike, optional): (xDegrees, yDegrees, zDegrees). Defaults to (0, 0, 0).\n    ordering (Union[Intrinsic, Extrinsic], optional): order of rotations in Intrinsic or Extrinsic rotation mode, defaults to Intrinsic.XYZ\n\nReturns:\n    Plane: a copy of this plane rotated as requested."
                },
                {
                    "name": "build123d.Plane.shift_origin",
                    "signature": "build123d.Plane.shift_origin(self, locator: \"Union[Axis, VectorLike, 'Vertex']\") -> 'Plane'",
                    "docstring": "shift plane origin\n\nCreates a new plane with the origin moved within the plane to the point of intersection\nof the axis or at the given Vertex. The plane's x_dir and z_dir are unchanged.\n\nArgs:\n    locator (Union[Axis, VectorLike, Vertex]): Either Axis that intersects the new\n        plane origin or Vertex within Plane.\n\nRaises:\n    ValueError: Vertex isn't within plane\n    ValueError: Point isn't within plane\n    ValueError: Axis doesn't intersect plane\n\nReturns:\n    Plane: plane with new origin"
                },
                {
                    "name": "build123d.Plane.to_gp_ax2",
                    "signature": "build123d.Plane.to_gp_ax2(self) -> 'gp_Ax2'",
                    "docstring": "Return gp_Ax2 version of the plane"
                },
                {
                    "name": "build123d.Plane.to_local_coords",
                    "signature": "build123d.Plane.to_local_coords(self, obj: 'Union[VectorLike, Any, BoundBox]')",
                    "docstring": "Reposition the object relative to this plane\n\nArgs:\n    obj: Union[VectorLike, Shape, BoundBox] an object to reposition. Note that\n    type Any refers to all topological classes.\n\nReturns:\n    an object of the same type, but repositioned to local coordinates"
                }
            ],
            "variables": [
                "location",
                "origin"
            ],
            "docstring": "Plane\n\nA plane is positioned in space with a coordinate system such that the plane is defined by\nthe origin, x_dir (X direction), y_dir (Y direction), and z_dir (Z direction) of this coordinate\nsystem, which is the \"local coordinate system\" of the plane. The z_dir is a vector normal to the\nplane. The coordinate system is right-handed.\n\nA plane allows the use of local 2D coordinates, which are later converted to\nglobal, 3d coordinates when the operations are complete.\n\nPlanes can be created from faces as workplanes for feature creation on objects.\n\n=========   ====== ======== ========\nName        x_dir  y_dir    z_dir\n=========   ====== ======== ========\nXY           +x     +y       +z\nYZ           +y     +z       +x\nZX           +z     +x       +y\nXZ           +x     +z       -y\nYX           +y     +x       -z\nZY           +z     +y       -x\nfront        +x     +z       -y\nback         -x     +z       +y\nleft         -y     +z       -x\nright        +y     +z       +x\ntop          +x     +y       +z\nbottom       +x     -y       -z\nisometric    +x+y   -x+y+z   +x+y-z\n=========   ====== ======== ========\n\nArgs:\n    gp_pln (gp_Pln): an OCCT plane object\n    origin (Union[tuple[float, float, float], Vector]): the origin in global coordinates\n    x_dir (Union[tuple[float, float, float], Vector], optional): an optional vector\n        representing the X Direction. Defaults to None.\n    z_dir (Union[tuple[float, float, float], Vector], optional): the normal direction\n        for the plane. Defaults to (0, 0, 1).\n\nAttributes:\n    origin (Vector): global position of local (0,0,0) point\n    x_dir (Vector): x direction\n    y_dir (Vector): y direction\n    z_dir (Vector): z direction\n    local_coord_system (gp_Ax3): OCP coordinate system\n    forward_transform (Matrix): forward location transformation matrix\n    reverse_transform (Matrix): reverse location transformation matrix\n    wrapped (gp_Pln): the OCP plane object\n\nRaises:\n    ValueError: z_dir must be non null\n    ValueError: x_dir must be non null\n    ValueError: the specified x_dir is not orthogonal to the provided normal\n\nReturns:\n    Plane: A plane"
        },
        {
            "name": "build123d.PlaneMeta",
            "signature": "build123d.PlaneMeta()",
            "methods": [
                {
                    "name": "build123d.PlaneMeta.mro",
                    "signature": "build123d.PlaneMeta.mro(self, /)",
                    "docstring": "Return a type's method resolution order."
                }
            ],
            "variables": [
                "XY",
                "XZ",
                "YX",
                "YZ",
                "ZX",
                "ZY",
                "back",
                "bottom",
                "front",
                "isometric",
                "left",
                "right",
                "top"
            ],
            "docstring": "Plane meta class to enable class properties"
        },
        {
            "name": "build123d.PolarLine",
            "signature": "build123d.PolarLine(start: 'VectorLike', length: 'float', angle: 'float' = None, direction: 'VectorLike' = None, length_mode: 'LengthMode' = <LengthMode.DIAGONAL>, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.PolarLine.bounding_box",
                    "signature": "build123d.PolarLine.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.PolarLine.cast",
                    "signature": "build123d.PolarLine.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.PolarLine.center",
                    "signature": "build123d.PolarLine.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.PolarLine.clean",
                    "signature": "build123d.PolarLine.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.PolarLine.close",
                    "signature": "build123d.PolarLine.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.PolarLine.closest_points",
                    "signature": "build123d.PolarLine.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.PolarLine.combined_center",
                    "signature": "build123d.PolarLine.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.PolarLine.common_plane",
                    "signature": "build123d.PolarLine.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.PolarLine.compound",
                    "signature": "build123d.PolarLine.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.PolarLine.compounds",
                    "signature": "build123d.PolarLine.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.PolarLine.compute_mass",
                    "signature": "build123d.PolarLine.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.copy",
                    "signature": "build123d.PolarLine.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.PolarLine.copy_attributes_to",
                    "signature": "build123d.PolarLine.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.PolarLine.cut",
                    "signature": "build123d.PolarLine.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.distance",
                    "signature": "build123d.PolarLine.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.distance_to",
                    "signature": "build123d.PolarLine.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.PolarLine.distance_to_with_closest_points",
                    "signature": "build123d.PolarLine.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.PolarLine.distances",
                    "signature": "build123d.PolarLine.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.distribute_locations",
                    "signature": "build123d.PolarLine.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.PolarLine.edge",
                    "signature": "build123d.PolarLine.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.PolarLine.edges",
                    "signature": "build123d.PolarLine.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.PolarLine.end_point",
                    "signature": "build123d.PolarLine.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.PolarLine.export_brep",
                    "signature": "build123d.PolarLine.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.export_step",
                    "signature": "build123d.PolarLine.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.PolarLine.export_stl",
                    "signature": "build123d.PolarLine.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.PolarLine.extrude",
                    "signature": "build123d.PolarLine.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.PolarLine.face",
                    "signature": "build123d.PolarLine.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.PolarLine.faces",
                    "signature": "build123d.PolarLine.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.PolarLine.faces_intersected_by_axis",
                    "signature": "build123d.PolarLine.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.PolarLine.find_intersection",
                    "signature": "build123d.PolarLine.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.PolarLine.find_intersection_points",
                    "signature": "build123d.PolarLine.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.PolarLine.find_tangent",
                    "signature": "build123d.PolarLine.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.PolarLine.fix",
                    "signature": "build123d.PolarLine.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.PolarLine.fuse",
                    "signature": "build123d.PolarLine.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.PolarLine.hash_code",
                    "signature": "build123d.PolarLine.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.intersect",
                    "signature": "build123d.PolarLine.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.PolarLine.is_equal",
                    "signature": "build123d.PolarLine.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.is_null",
                    "signature": "build123d.PolarLine.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.is_same",
                    "signature": "build123d.PolarLine.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.is_valid",
                    "signature": "build123d.PolarLine.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.iter_path_reverse",
                    "signature": "build123d.PolarLine.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.PolarLine.locate",
                    "signature": "build123d.PolarLine.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.located",
                    "signature": "build123d.PolarLine.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.PolarLine.location_at",
                    "signature": "build123d.PolarLine.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.PolarLine.locations",
                    "signature": "build123d.PolarLine.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.PolarLine.make_bezier",
                    "signature": "build123d.PolarLine.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.PolarLine.make_circle",
                    "signature": "build123d.PolarLine.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.PolarLine.make_ellipse",
                    "signature": "build123d.PolarLine.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.PolarLine.make_helix",
                    "signature": "build123d.PolarLine.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.PolarLine.make_line",
                    "signature": "build123d.PolarLine.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.PolarLine.make_mid_way",
                    "signature": "build123d.PolarLine.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.PolarLine.make_spline",
                    "signature": "build123d.PolarLine.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.PolarLine.make_spline_approx",
                    "signature": "build123d.PolarLine.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.PolarLine.make_tangent_arc",
                    "signature": "build123d.PolarLine.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.PolarLine.make_three_point_arc",
                    "signature": "build123d.PolarLine.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.PolarLine.mesh",
                    "signature": "build123d.PolarLine.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.mirror",
                    "signature": "build123d.PolarLine.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.PolarLine.move",
                    "signature": "build123d.PolarLine.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.moved",
                    "signature": "build123d.PolarLine.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.PolarLine.normal",
                    "signature": "build123d.PolarLine.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.offset_2d",
                    "signature": "build123d.PolarLine.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.PolarLine.param_at",
                    "signature": "build123d.PolarLine.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.PolarLine.param_at_point",
                    "signature": "build123d.PolarLine.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.PolarLine.perpendicular_line",
                    "signature": "build123d.PolarLine.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.PolarLine.position_at",
                    "signature": "build123d.PolarLine.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.PolarLine.positions",
                    "signature": "build123d.PolarLine.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.PolarLine.project",
                    "signature": "build123d.PolarLine.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.project_faces",
                    "signature": "build123d.PolarLine.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.PolarLine.project_to_shape",
                    "signature": "build123d.PolarLine.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.PolarLine.project_to_viewport",
                    "signature": "build123d.PolarLine.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.PolarLine.relocate",
                    "signature": "build123d.PolarLine.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.PolarLine.reversed",
                    "signature": "build123d.PolarLine.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.PolarLine.rotate",
                    "signature": "build123d.PolarLine.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.PolarLine.scale",
                    "signature": "build123d.PolarLine.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.shape_type",
                    "signature": "build123d.PolarLine.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.PolarLine.shell",
                    "signature": "build123d.PolarLine.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.PolarLine.shells",
                    "signature": "build123d.PolarLine.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.PolarLine.show_topology",
                    "signature": "build123d.PolarLine.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.PolarLine.solid",
                    "signature": "build123d.PolarLine.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.PolarLine.solids",
                    "signature": "build123d.PolarLine.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.PolarLine.split",
                    "signature": "build123d.PolarLine.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.PolarLine.split_by_perimeter",
                    "signature": "build123d.PolarLine.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.PolarLine.start_point",
                    "signature": "build123d.PolarLine.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.PolarLine.tangent_angle_at",
                    "signature": "build123d.PolarLine.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.PolarLine.tangent_at",
                    "signature": "build123d.PolarLine.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.PolarLine.tessellate",
                    "signature": "build123d.PolarLine.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.PolarLine.to_arcs",
                    "signature": "build123d.PolarLine.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.PolarLine.to_axis",
                    "signature": "build123d.PolarLine.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.PolarLine.to_splines",
                    "signature": "build123d.PolarLine.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.PolarLine.to_vtk_poly_data",
                    "signature": "build123d.PolarLine.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.PolarLine.to_wire",
                    "signature": "build123d.PolarLine.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.PolarLine.transform_geometry",
                    "signature": "build123d.PolarLine.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.PolarLine.transform_shape",
                    "signature": "build123d.PolarLine.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.PolarLine.transformed",
                    "signature": "build123d.PolarLine.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.PolarLine.translate",
                    "signature": "build123d.PolarLine.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.PolarLine.trim",
                    "signature": "build123d.PolarLine.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.PolarLine.trim_to_length",
                    "signature": "build123d.PolarLine.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.PolarLine.vertex",
                    "signature": "build123d.PolarLine.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.PolarLine.vertices",
                    "signature": "build123d.PolarLine.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.PolarLine.wire",
                    "signature": "build123d.PolarLine.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.PolarLine.wires",
                    "signature": "build123d.PolarLine.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Polar Line\n\nAdd line defined by a start point, length and angle.\n\nArgs:\n    start (VectorLike): start point\n    length (float): line length\n    angle (float): angle from the local \"X\" axis.\n    length_mode (LengthMode, optional): length value specifies a diagonal, horizontal\n        or vertical value. Defaults to LengthMode.DIAGONAL\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: Either angle or direction must be provided"
        },
        {
            "name": "build123d.PolarLocations",
            "signature": "build123d.PolarLocations(radius: 'float', count: 'int', start_angle: 'float' = 0.0, angular_range: 'float' = 360.0, rotate: 'bool' = True, endpoint: 'bool' = False)",
            "methods": [],
            "variables": [
                "locations"
            ],
            "docstring": "Location Context: Polar Array\n\nCreates a context of polar array of locations for Part or Sketch\n\nArgs:\n    radius (float): array radius\n    count (int): Number of points to push\n    start_angle (float, optional): angle to first point from +ve X axis. Defaults to 0.0.\n    angular_range (float, optional): magnitude of array from start angle. Defaults to 360.0.\n    rotate (bool, optional): Align locations with arc tangents. Defaults to True.\n    endpoint (bool, optional): If True, `start_angle` + `angular_range` is the last sample.\n        Otherwise, it is not included. Defaults to False.\n\nAttributes:\n    local_locations (list{Location}): locations relative to workplane\n\nRaises:\n    ValueError: Count must be greater than or equal to 1"
        },
        {
            "name": "build123d.Polygon",
            "signature": "build123d.Polygon(*pts: 'Union[VectorLike, Iterable[VectorLike]]', rotation: 'float' = 0, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Polygon.bounding_box",
                    "signature": "build123d.Polygon.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Polygon.cast",
                    "signature": "build123d.Polygon.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Polygon.center",
                    "signature": "build123d.Polygon.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Polygon.chamfer",
                    "signature": "build123d.Polygon.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Polygon.clean",
                    "signature": "build123d.Polygon.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Polygon.closest_points",
                    "signature": "build123d.Polygon.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Polygon.combined_center",
                    "signature": "build123d.Polygon.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Polygon.compound",
                    "signature": "build123d.Polygon.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Polygon.compounds",
                    "signature": "build123d.Polygon.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Polygon.compute_mass",
                    "signature": "build123d.Polygon.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.copy",
                    "signature": "build123d.Polygon.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Polygon.copy_attributes_to",
                    "signature": "build123d.Polygon.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Polygon.cut",
                    "signature": "build123d.Polygon.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.distance",
                    "signature": "build123d.Polygon.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.distance_to",
                    "signature": "build123d.Polygon.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Polygon.distance_to_with_closest_points",
                    "signature": "build123d.Polygon.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Polygon.distances",
                    "signature": "build123d.Polygon.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.do_children_intersect",
                    "signature": "build123d.Polygon.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Polygon.dprism",
                    "signature": "build123d.Polygon.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Polygon.edge",
                    "signature": "build123d.Polygon.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Polygon.edges",
                    "signature": "build123d.Polygon.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Polygon.export_brep",
                    "signature": "build123d.Polygon.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.export_step",
                    "signature": "build123d.Polygon.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Polygon.export_stl",
                    "signature": "build123d.Polygon.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Polygon.extrude",
                    "signature": "build123d.Polygon.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Polygon.face",
                    "signature": "build123d.Polygon.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Polygon.faces",
                    "signature": "build123d.Polygon.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Polygon.faces_intersected_by_axis",
                    "signature": "build123d.Polygon.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Polygon.fillet",
                    "signature": "build123d.Polygon.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Polygon.find_intersection",
                    "signature": "build123d.Polygon.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Polygon.find_intersection_points",
                    "signature": "build123d.Polygon.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Polygon.first_level_shapes",
                    "signature": "build123d.Polygon.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Polygon.fix",
                    "signature": "build123d.Polygon.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Polygon.fuse",
                    "signature": "build123d.Polygon.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.get_type",
                    "signature": "build123d.Polygon.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Polygon.hash_code",
                    "signature": "build123d.Polygon.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.hollow",
                    "signature": "build123d.Polygon.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Polygon.intersect",
                    "signature": "build123d.Polygon.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.is_equal",
                    "signature": "build123d.Polygon.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.is_inside",
                    "signature": "build123d.Polygon.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Polygon.is_null",
                    "signature": "build123d.Polygon.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.is_same",
                    "signature": "build123d.Polygon.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.is_valid",
                    "signature": "build123d.Polygon.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.iter_path_reverse",
                    "signature": "build123d.Polygon.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Polygon.locate",
                    "signature": "build123d.Polygon.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.located",
                    "signature": "build123d.Polygon.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Polygon.make_compound",
                    "signature": "build123d.Polygon.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Polygon.make_text",
                    "signature": "build123d.Polygon.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Polygon.make_triad",
                    "signature": "build123d.Polygon.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Polygon.max_fillet",
                    "signature": "build123d.Polygon.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Polygon.mesh",
                    "signature": "build123d.Polygon.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.mirror",
                    "signature": "build123d.Polygon.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Polygon.move",
                    "signature": "build123d.Polygon.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.moved",
                    "signature": "build123d.Polygon.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Polygon.offset_3d",
                    "signature": "build123d.Polygon.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Polygon.project_faces",
                    "signature": "build123d.Polygon.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Polygon.project_to_viewport",
                    "signature": "build123d.Polygon.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Polygon.relocate",
                    "signature": "build123d.Polygon.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Polygon.rotate",
                    "signature": "build123d.Polygon.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Polygon.scale",
                    "signature": "build123d.Polygon.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.shape_type",
                    "signature": "build123d.Polygon.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Polygon.shell",
                    "signature": "build123d.Polygon.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Polygon.shells",
                    "signature": "build123d.Polygon.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Polygon.show_topology",
                    "signature": "build123d.Polygon.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Polygon.solid",
                    "signature": "build123d.Polygon.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Polygon.solids",
                    "signature": "build123d.Polygon.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Polygon.split",
                    "signature": "build123d.Polygon.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Polygon.split_by_perimeter",
                    "signature": "build123d.Polygon.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Polygon.tessellate",
                    "signature": "build123d.Polygon.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Polygon.to_arcs",
                    "signature": "build123d.Polygon.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Polygon.to_splines",
                    "signature": "build123d.Polygon.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Polygon.to_vtk_poly_data",
                    "signature": "build123d.Polygon.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Polygon.transform_geometry",
                    "signature": "build123d.Polygon.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Polygon.transform_shape",
                    "signature": "build123d.Polygon.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Polygon.transformed",
                    "signature": "build123d.Polygon.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Polygon.translate",
                    "signature": "build123d.Polygon.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Polygon.unwrap",
                    "signature": "build123d.Polygon.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Polygon.vertex",
                    "signature": "build123d.Polygon.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Polygon.vertices",
                    "signature": "build123d.Polygon.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Polygon.wire",
                    "signature": "build123d.Polygon.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Polygon.wires",
                    "signature": "build123d.Polygon.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Polygon\n\nAdd polygon(s) defined by given sequence of points to sketch.\n\nNote that the order of the points define the normal of the Face that is created in\nAlgebra mode, where counter clockwise order creates Faces with their normal being up\nwhile a clockwise order will have a normal that is down.  In Builder mode, all Faces\nadded to the sketch are up.\n\nArgs:\n    pts (Union[VectorLike, Iterable[VectorLike]]): sequence of points defining the\n        vertices of the polygon\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Polyline",
            "signature": "build123d.Polyline(*pts: 'Union[VectorLike, Iterable[VectorLike]]', close: 'bool' = False, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Polyline.bounding_box",
                    "signature": "build123d.Polyline.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Polyline.cast",
                    "signature": "build123d.Polyline.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Polyline.center",
                    "signature": "build123d.Polyline.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Polyline.chamfer_2d",
                    "signature": "build123d.Polyline.chamfer_2d(self, distance: 'float', distance2: 'float', vertices: 'Iterable[Vertex]', edge: 'Edge' = None) -> 'Wire'",
                    "docstring": "chamfer_2d\n\nApply 2D chamfer to a wire\n\nArgs:\n    distance (float): chamfer length\n    distance2 (float): chamfer length\n    vertices (Iterable[Vertex]): vertices to chamfer\n    edge (Edge): identifies the side where length is measured. The vertices must be\n        part of the edge\n\nReturns:\n    Wire: chamfered wire"
                },
                {
                    "name": "build123d.Polyline.clean",
                    "signature": "build123d.Polyline.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Polyline.close",
                    "signature": "build123d.Polyline.close(self) -> 'Wire'",
                    "docstring": "Close a Wire"
                },
                {
                    "name": "build123d.Polyline.closest_points",
                    "signature": "build123d.Polyline.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Polyline.combine",
                    "signature": "build123d.Polyline.combine(wires: 'Iterable[Union[Wire, Edge]]', tol: 'float' = 1e-09) -> 'ShapeList[Wire]'",
                    "docstring": "combine\n\nCombine a list of wires and edges into a list of Wires.\n\nArgs:\n    wires (Iterable[Union[Wire, Edge]]): unsorted\n    tol (float, optional): tolerance. Defaults to 1e-9.\n\nReturns:\n    ShapeList[Wire]: Wires"
                },
                {
                    "name": "build123d.Polyline.combined_center",
                    "signature": "build123d.Polyline.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Polyline.common_plane",
                    "signature": "build123d.Polyline.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.Polyline.compound",
                    "signature": "build123d.Polyline.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Polyline.compounds",
                    "signature": "build123d.Polyline.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Polyline.compute_mass",
                    "signature": "build123d.Polyline.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.copy",
                    "signature": "build123d.Polyline.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Polyline.copy_attributes_to",
                    "signature": "build123d.Polyline.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Polyline.cut",
                    "signature": "build123d.Polyline.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.distance",
                    "signature": "build123d.Polyline.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.distance_to",
                    "signature": "build123d.Polyline.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Polyline.distance_to_with_closest_points",
                    "signature": "build123d.Polyline.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Polyline.distances",
                    "signature": "build123d.Polyline.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.edge",
                    "signature": "build123d.Polyline.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Polyline.edges",
                    "signature": "build123d.Polyline.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Polyline.end_point",
                    "signature": "build123d.Polyline.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Polyline.export_brep",
                    "signature": "build123d.Polyline.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.export_step",
                    "signature": "build123d.Polyline.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Polyline.export_stl",
                    "signature": "build123d.Polyline.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Polyline.extrude",
                    "signature": "build123d.Polyline.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Polyline.face",
                    "signature": "build123d.Polyline.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Polyline.faces",
                    "signature": "build123d.Polyline.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Polyline.faces_intersected_by_axis",
                    "signature": "build123d.Polyline.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Polyline.fillet_2d",
                    "signature": "build123d.Polyline.fillet_2d(self, radius: 'float', vertices: 'Iterable[Vertex]') -> 'Wire'",
                    "docstring": "fillet_2d\n\nApply 2D fillet to a wire\n\nArgs:\n    radius (float):\n    vertices (Iterable[Vertex]): vertices to fillet\n\nReturns:\n    Wire: filleted wire"
                },
                {
                    "name": "build123d.Polyline.find_intersection",
                    "signature": "build123d.Polyline.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Polyline.find_intersection_points",
                    "signature": "build123d.Polyline.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Polyline.fix",
                    "signature": "build123d.Polyline.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Polyline.fix_degenerate_edges",
                    "signature": "build123d.Polyline.fix_degenerate_edges(self, precision: 'float') -> 'Wire'",
                    "docstring": "fix_degenerate_edges\n\nFix a Wire that contains degenerate (very small) edges\n\nArgs:\n    precision (float): minimum value edge length\n\nReturns:\n    Wire: fixed wire"
                },
                {
                    "name": "build123d.Polyline.fuse",
                    "signature": "build123d.Polyline.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Polyline.hash_code",
                    "signature": "build123d.Polyline.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.intersect",
                    "signature": "build123d.Polyline.intersect(self, *to_intersect: 'Union[Shape, Axis, Plane]') -> 'Shape'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Polyline.is_equal",
                    "signature": "build123d.Polyline.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.is_null",
                    "signature": "build123d.Polyline.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.is_same",
                    "signature": "build123d.Polyline.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.is_valid",
                    "signature": "build123d.Polyline.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.iter_path_reverse",
                    "signature": "build123d.Polyline.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Polyline.locate",
                    "signature": "build123d.Polyline.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.located",
                    "signature": "build123d.Polyline.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Polyline.location_at",
                    "signature": "build123d.Polyline.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.Polyline.locations",
                    "signature": "build123d.Polyline.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.Polyline.make_circle",
                    "signature": "build123d.Polyline.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Wire'",
                    "docstring": "make_circle\n\nMakes a circle centered at the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane): base plane. Defaults to Plane.XY\n\nReturns:\n    Wire: a circle"
                },
                {
                    "name": "build123d.Polyline.make_convex_hull",
                    "signature": "build123d.Polyline.make_convex_hull(edges: 'Iterable[Edge]', tolerance: 'float' = 0.001) -> 'Wire'",
                    "docstring": "make_convex_hull\n\nCreate a wire of minimum length enclosing all of the provided edges.\n\nNote that edges can't overlap each other.\n\nArgs:\n    edges (Iterable[Edge]): edges defining the convex hull\n    tolerance (float): allowable error as a fraction of each edge length.\n        Defaults to 1e-3.\n\nRaises:\n    ValueError: edges overlap\n\nReturns:\n    Wire: convex hull perimeter"
                },
                {
                    "name": "build123d.Polyline.make_ellipse",
                    "signature": "build123d.Polyline.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>, closed: 'bool' = True) -> 'Wire'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): _description_. Defaults to 360.0.\n    end_angle (float, optional): _description_. Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n    closed (bool, optional): close the arc. Defaults to True.\n\nReturns:\n    Wire: an ellipse"
                },
                {
                    "name": "build123d.Polyline.make_polygon",
                    "signature": "build123d.Polyline.make_polygon(vertices: 'Iterable[VectorLike]', close: 'bool' = True) -> 'Wire'",
                    "docstring": "make_polygon\n\nCreate an irregular polygon by defining vertices\n\nArgs:\n    vertices (Iterable[VectorLike]):\n    close (bool, optional): close the polygon. Defaults to True.\n\nReturns:\n    Wire: an irregular polygon"
                },
                {
                    "name": "build123d.Polyline.make_rect",
                    "signature": "build123d.Polyline.make_rect(width: 'float', height: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Wire'",
                    "docstring": "Make Rectangle\n\nMake a Rectangle centered on center with the given normal\n\nArgs:\n    width (float): width (local x)\n    height (float): height (local y)\n    plane (Plane, optional): plane containing rectangle. Defaults to Plane.XY.\n\nReturns:\n    Wire: The centered rectangle"
                },
                {
                    "name": "build123d.Polyline.make_wire",
                    "signature": "build123d.Polyline.make_wire(edges: 'Iterable[Edge]', sequenced: 'bool' = False) -> 'Wire'",
                    "docstring": "make_wire\n\nBuild a Wire from the provided unsorted Edges. If sequenced is True the\nEdges are placed in such that the end of the nth Edge is coincident with\nthe n+1th Edge forming an unbroken sequence. Note that sequencing a list\nis relatively slow.\n\nArgs:\n    edges (Iterable[Edge]): Edges to assemble\n    sequenced (bool, optional): arrange in order. Defaults to False.\n\nRaises:\n    ValueError: Edges are disconnected and can't be sequenced.\n    RuntimeError: Wire is empty\n\nReturns:\n    Wire: assembled edges"
                },
                {
                    "name": "build123d.Polyline.mesh",
                    "signature": "build123d.Polyline.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.mirror",
                    "signature": "build123d.Polyline.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Polyline.move",
                    "signature": "build123d.Polyline.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.moved",
                    "signature": "build123d.Polyline.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Polyline.normal",
                    "signature": "build123d.Polyline.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.offset_2d",
                    "signature": "build123d.Polyline.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.Polyline.order_edges",
                    "signature": "build123d.Polyline.order_edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "Return the edges in self ordered by wire direction and orientation"
                },
                {
                    "name": "build123d.Polyline.param_at",
                    "signature": "build123d.Polyline.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.Polyline.param_at_point",
                    "signature": "build123d.Polyline.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Parameter at point on Wire"
                },
                {
                    "name": "build123d.Polyline.perpendicular_line",
                    "signature": "build123d.Polyline.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.Polyline.position_at",
                    "signature": "build123d.Polyline.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.Polyline.positions",
                    "signature": "build123d.Polyline.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.Polyline.project",
                    "signature": "build123d.Polyline.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.project_faces",
                    "signature": "build123d.Polyline.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Polyline.project_to_shape",
                    "signature": "build123d.Polyline.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Wire]'",
                    "docstring": "Project Wire\n\nProject a Wire onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected wire(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.Polyline.project_to_viewport",
                    "signature": "build123d.Polyline.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Polyline.relocate",
                    "signature": "build123d.Polyline.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Polyline.rotate",
                    "signature": "build123d.Polyline.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Polyline.scale",
                    "signature": "build123d.Polyline.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.shape_type",
                    "signature": "build123d.Polyline.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Polyline.shell",
                    "signature": "build123d.Polyline.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Polyline.shells",
                    "signature": "build123d.Polyline.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Polyline.show_topology",
                    "signature": "build123d.Polyline.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Polyline.solid",
                    "signature": "build123d.Polyline.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Polyline.solids",
                    "signature": "build123d.Polyline.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Polyline.split",
                    "signature": "build123d.Polyline.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Polyline.split_by_perimeter",
                    "signature": "build123d.Polyline.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Polyline.start_point",
                    "signature": "build123d.Polyline.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Polyline.stitch",
                    "signature": "build123d.Polyline.stitch(self, other: 'Wire') -> 'Wire'",
                    "docstring": "Attempt to stich wires\n\nArgs:\n  other: Wire:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.tangent_angle_at",
                    "signature": "build123d.Polyline.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.Polyline.tangent_at",
                    "signature": "build123d.Polyline.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.Polyline.tessellate",
                    "signature": "build123d.Polyline.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Polyline.to_arcs",
                    "signature": "build123d.Polyline.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Polyline.to_splines",
                    "signature": "build123d.Polyline.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Polyline.to_vtk_poly_data",
                    "signature": "build123d.Polyline.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Polyline.to_wire",
                    "signature": "build123d.Polyline.to_wire(self) -> 'Wire'",
                    "docstring": "Return Wire - used as a pair with Edge.to_wire when self is Wire | Edge"
                },
                {
                    "name": "build123d.Polyline.transform_geometry",
                    "signature": "build123d.Polyline.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Polyline.transform_shape",
                    "signature": "build123d.Polyline.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Polyline.transformed",
                    "signature": "build123d.Polyline.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Polyline.translate",
                    "signature": "build123d.Polyline.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Polyline.trim",
                    "signature": "build123d.Polyline.trim(self: 'Wire', start: 'float', end: 'float') -> 'Wire'",
                    "docstring": "trim\n\nCreate a new wire by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Wire: trimmed wire"
                },
                {
                    "name": "build123d.Polyline.vertex",
                    "signature": "build123d.Polyline.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Polyline.vertices",
                    "signature": "build123d.Polyline.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Polyline.wire",
                    "signature": "build123d.Polyline.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Polyline.wires",
                    "signature": "build123d.Polyline.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Polyline\n\nAdd a sequence of straight lines defined by successive point pairs.\n\nArgs:\n    pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two or more points\n    close (bool, optional): close by generating an extra Edge. Defaults to False.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: Two or more points not provided"
        },
        {
            "name": "build123d.Pos",
            "signature": "build123d.Pos(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Pos.intersect",
                    "signature": "build123d.Pos.intersect(self, *args, **kwargs)",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Pos.inverse",
                    "signature": "build123d.Pos.inverse(self) -> 'Location'",
                    "docstring": "Inverted location"
                },
                {
                    "name": "build123d.Pos.to_axis",
                    "signature": "build123d.Pos.to_axis(self) -> 'Axis'",
                    "docstring": "Convert the location into an Axis"
                },
                {
                    "name": "build123d.Pos.to_tuple",
                    "signature": "build123d.Pos.to_tuple(self) -> 'tuple[tuple[float, float, float], tuple[float, float, float]]'",
                    "docstring": "Convert the location to a translation, rotation tuple."
                }
            ],
            "variables": [
                "T",
                "orientation",
                "position",
                "x_axis",
                "y_axis",
                "z_axis"
            ],
            "docstring": "A position only sub-class of Location"
        },
        {
            "name": "build123d.PositionMode",
            "signature": "build123d.PositionMode()",
            "methods": [],
            "variables": [
                "LENGTH",
                "PARAMETER",
                "name",
                "value"
            ],
            "docstring": "Position along curve mode"
        },
        {
            "name": "build123d.PrecisionMode",
            "signature": "build123d.PrecisionMode()",
            "methods": [],
            "variables": [
                "AVERAGE",
                "GREATEST",
                "LEAST",
                "SESSION",
                "name",
                "value"
            ],
            "docstring": "When you export a model to a STEP file, the precision of the geometric data\n(such as the coordinates of points, the definitions of curves and surfaces, etc.)\ncan significantly impact the file size and the fidelity of the model when it is\nimported into another CAD system. Higher precision means that the geometric\ndata is described with more detail, which can improve the accuracy of the model\nin the target system but can also increase the file size."
        },
        {
            "name": "build123d.RadiusArc",
            "signature": "build123d.RadiusArc(start_point: 'VectorLike', end_point: 'VectorLike', radius: 'float', short_sagitta: 'bool' = True, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.RadiusArc.bounding_box",
                    "signature": "build123d.RadiusArc.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.RadiusArc.cast",
                    "signature": "build123d.RadiusArc.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.RadiusArc.center",
                    "signature": "build123d.RadiusArc.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.RadiusArc.clean",
                    "signature": "build123d.RadiusArc.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.RadiusArc.close",
                    "signature": "build123d.RadiusArc.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.RadiusArc.closest_points",
                    "signature": "build123d.RadiusArc.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.RadiusArc.combined_center",
                    "signature": "build123d.RadiusArc.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.RadiusArc.common_plane",
                    "signature": "build123d.RadiusArc.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.RadiusArc.compound",
                    "signature": "build123d.RadiusArc.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.RadiusArc.compounds",
                    "signature": "build123d.RadiusArc.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.RadiusArc.compute_mass",
                    "signature": "build123d.RadiusArc.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.copy",
                    "signature": "build123d.RadiusArc.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.RadiusArc.copy_attributes_to",
                    "signature": "build123d.RadiusArc.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.RadiusArc.cut",
                    "signature": "build123d.RadiusArc.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.distance",
                    "signature": "build123d.RadiusArc.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.distance_to",
                    "signature": "build123d.RadiusArc.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.RadiusArc.distance_to_with_closest_points",
                    "signature": "build123d.RadiusArc.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.RadiusArc.distances",
                    "signature": "build123d.RadiusArc.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.distribute_locations",
                    "signature": "build123d.RadiusArc.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.RadiusArc.edge",
                    "signature": "build123d.RadiusArc.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.RadiusArc.edges",
                    "signature": "build123d.RadiusArc.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.RadiusArc.end_point",
                    "signature": "build123d.RadiusArc.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.RadiusArc.export_brep",
                    "signature": "build123d.RadiusArc.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.export_step",
                    "signature": "build123d.RadiusArc.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.RadiusArc.export_stl",
                    "signature": "build123d.RadiusArc.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.RadiusArc.extrude",
                    "signature": "build123d.RadiusArc.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.RadiusArc.face",
                    "signature": "build123d.RadiusArc.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.RadiusArc.faces",
                    "signature": "build123d.RadiusArc.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.RadiusArc.faces_intersected_by_axis",
                    "signature": "build123d.RadiusArc.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.RadiusArc.find_intersection",
                    "signature": "build123d.RadiusArc.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.RadiusArc.find_intersection_points",
                    "signature": "build123d.RadiusArc.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.RadiusArc.find_tangent",
                    "signature": "build123d.RadiusArc.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.RadiusArc.fix",
                    "signature": "build123d.RadiusArc.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.RadiusArc.fuse",
                    "signature": "build123d.RadiusArc.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.RadiusArc.hash_code",
                    "signature": "build123d.RadiusArc.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.intersect",
                    "signature": "build123d.RadiusArc.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.RadiusArc.is_equal",
                    "signature": "build123d.RadiusArc.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.is_null",
                    "signature": "build123d.RadiusArc.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.is_same",
                    "signature": "build123d.RadiusArc.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.is_valid",
                    "signature": "build123d.RadiusArc.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.iter_path_reverse",
                    "signature": "build123d.RadiusArc.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.RadiusArc.locate",
                    "signature": "build123d.RadiusArc.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.located",
                    "signature": "build123d.RadiusArc.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.RadiusArc.location_at",
                    "signature": "build123d.RadiusArc.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.RadiusArc.locations",
                    "signature": "build123d.RadiusArc.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.RadiusArc.make_bezier",
                    "signature": "build123d.RadiusArc.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.RadiusArc.make_circle",
                    "signature": "build123d.RadiusArc.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.RadiusArc.make_ellipse",
                    "signature": "build123d.RadiusArc.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.RadiusArc.make_helix",
                    "signature": "build123d.RadiusArc.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.RadiusArc.make_line",
                    "signature": "build123d.RadiusArc.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.RadiusArc.make_mid_way",
                    "signature": "build123d.RadiusArc.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.RadiusArc.make_spline",
                    "signature": "build123d.RadiusArc.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.RadiusArc.make_spline_approx",
                    "signature": "build123d.RadiusArc.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.RadiusArc.make_tangent_arc",
                    "signature": "build123d.RadiusArc.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.RadiusArc.make_three_point_arc",
                    "signature": "build123d.RadiusArc.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.RadiusArc.mesh",
                    "signature": "build123d.RadiusArc.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.mirror",
                    "signature": "build123d.RadiusArc.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.RadiusArc.move",
                    "signature": "build123d.RadiusArc.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.moved",
                    "signature": "build123d.RadiusArc.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.RadiusArc.normal",
                    "signature": "build123d.RadiusArc.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.offset_2d",
                    "signature": "build123d.RadiusArc.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.RadiusArc.param_at",
                    "signature": "build123d.RadiusArc.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.RadiusArc.param_at_point",
                    "signature": "build123d.RadiusArc.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.RadiusArc.perpendicular_line",
                    "signature": "build123d.RadiusArc.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.RadiusArc.position_at",
                    "signature": "build123d.RadiusArc.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.RadiusArc.positions",
                    "signature": "build123d.RadiusArc.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.RadiusArc.project",
                    "signature": "build123d.RadiusArc.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.project_faces",
                    "signature": "build123d.RadiusArc.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.RadiusArc.project_to_shape",
                    "signature": "build123d.RadiusArc.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.RadiusArc.project_to_viewport",
                    "signature": "build123d.RadiusArc.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.RadiusArc.relocate",
                    "signature": "build123d.RadiusArc.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.RadiusArc.reversed",
                    "signature": "build123d.RadiusArc.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.RadiusArc.rotate",
                    "signature": "build123d.RadiusArc.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.RadiusArc.scale",
                    "signature": "build123d.RadiusArc.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.shape_type",
                    "signature": "build123d.RadiusArc.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.RadiusArc.shell",
                    "signature": "build123d.RadiusArc.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.RadiusArc.shells",
                    "signature": "build123d.RadiusArc.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.RadiusArc.show_topology",
                    "signature": "build123d.RadiusArc.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.RadiusArc.solid",
                    "signature": "build123d.RadiusArc.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.RadiusArc.solids",
                    "signature": "build123d.RadiusArc.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.RadiusArc.split",
                    "signature": "build123d.RadiusArc.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.RadiusArc.split_by_perimeter",
                    "signature": "build123d.RadiusArc.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.RadiusArc.start_point",
                    "signature": "build123d.RadiusArc.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.RadiusArc.tangent_angle_at",
                    "signature": "build123d.RadiusArc.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.RadiusArc.tangent_at",
                    "signature": "build123d.RadiusArc.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.RadiusArc.tessellate",
                    "signature": "build123d.RadiusArc.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.RadiusArc.to_arcs",
                    "signature": "build123d.RadiusArc.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.RadiusArc.to_axis",
                    "signature": "build123d.RadiusArc.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.RadiusArc.to_splines",
                    "signature": "build123d.RadiusArc.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.RadiusArc.to_vtk_poly_data",
                    "signature": "build123d.RadiusArc.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.RadiusArc.to_wire",
                    "signature": "build123d.RadiusArc.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.RadiusArc.transform_geometry",
                    "signature": "build123d.RadiusArc.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.RadiusArc.transform_shape",
                    "signature": "build123d.RadiusArc.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.RadiusArc.transformed",
                    "signature": "build123d.RadiusArc.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.RadiusArc.translate",
                    "signature": "build123d.RadiusArc.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.RadiusArc.trim",
                    "signature": "build123d.RadiusArc.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.RadiusArc.trim_to_length",
                    "signature": "build123d.RadiusArc.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.RadiusArc.vertex",
                    "signature": "build123d.RadiusArc.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.RadiusArc.vertices",
                    "signature": "build123d.RadiusArc.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.RadiusArc.wire",
                    "signature": "build123d.RadiusArc.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.RadiusArc.wires",
                    "signature": "build123d.RadiusArc.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Radius Arc\n\nAdd an arc defined by two end points and a radius\n\nArgs:\n    start_point (VectorLike): start\n    end_point (VectorLike): end\n    radius (float): radius\n    short_sagitta (bool): If True selects the short sagitta, else the\n        long sagitta crossing the center. Defaults to True.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: Insufficient radius to connect end points"
        },
        {
            "name": "build123d.Rectangle",
            "signature": "build123d.Rectangle(width: 'float', height: 'float', rotation: 'float' = 0, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Rectangle.bounding_box",
                    "signature": "build123d.Rectangle.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Rectangle.cast",
                    "signature": "build123d.Rectangle.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Rectangle.center",
                    "signature": "build123d.Rectangle.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Rectangle.chamfer",
                    "signature": "build123d.Rectangle.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Rectangle.clean",
                    "signature": "build123d.Rectangle.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Rectangle.closest_points",
                    "signature": "build123d.Rectangle.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Rectangle.combined_center",
                    "signature": "build123d.Rectangle.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Rectangle.compound",
                    "signature": "build123d.Rectangle.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Rectangle.compounds",
                    "signature": "build123d.Rectangle.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Rectangle.compute_mass",
                    "signature": "build123d.Rectangle.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.copy",
                    "signature": "build123d.Rectangle.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Rectangle.copy_attributes_to",
                    "signature": "build123d.Rectangle.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Rectangle.cut",
                    "signature": "build123d.Rectangle.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.distance",
                    "signature": "build123d.Rectangle.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.distance_to",
                    "signature": "build123d.Rectangle.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Rectangle.distance_to_with_closest_points",
                    "signature": "build123d.Rectangle.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Rectangle.distances",
                    "signature": "build123d.Rectangle.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.do_children_intersect",
                    "signature": "build123d.Rectangle.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Rectangle.dprism",
                    "signature": "build123d.Rectangle.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Rectangle.edge",
                    "signature": "build123d.Rectangle.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Rectangle.edges",
                    "signature": "build123d.Rectangle.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Rectangle.export_brep",
                    "signature": "build123d.Rectangle.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.export_step",
                    "signature": "build123d.Rectangle.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Rectangle.export_stl",
                    "signature": "build123d.Rectangle.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Rectangle.extrude",
                    "signature": "build123d.Rectangle.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Rectangle.face",
                    "signature": "build123d.Rectangle.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Rectangle.faces",
                    "signature": "build123d.Rectangle.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Rectangle.faces_intersected_by_axis",
                    "signature": "build123d.Rectangle.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Rectangle.fillet",
                    "signature": "build123d.Rectangle.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Rectangle.find_intersection",
                    "signature": "build123d.Rectangle.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Rectangle.find_intersection_points",
                    "signature": "build123d.Rectangle.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Rectangle.first_level_shapes",
                    "signature": "build123d.Rectangle.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Rectangle.fix",
                    "signature": "build123d.Rectangle.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Rectangle.fuse",
                    "signature": "build123d.Rectangle.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.get_type",
                    "signature": "build123d.Rectangle.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Rectangle.hash_code",
                    "signature": "build123d.Rectangle.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.hollow",
                    "signature": "build123d.Rectangle.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Rectangle.intersect",
                    "signature": "build123d.Rectangle.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.is_equal",
                    "signature": "build123d.Rectangle.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.is_inside",
                    "signature": "build123d.Rectangle.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Rectangle.is_null",
                    "signature": "build123d.Rectangle.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.is_same",
                    "signature": "build123d.Rectangle.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.is_valid",
                    "signature": "build123d.Rectangle.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.iter_path_reverse",
                    "signature": "build123d.Rectangle.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Rectangle.locate",
                    "signature": "build123d.Rectangle.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.located",
                    "signature": "build123d.Rectangle.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Rectangle.make_compound",
                    "signature": "build123d.Rectangle.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.make_text",
                    "signature": "build123d.Rectangle.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Rectangle.make_triad",
                    "signature": "build123d.Rectangle.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Rectangle.max_fillet",
                    "signature": "build123d.Rectangle.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Rectangle.mesh",
                    "signature": "build123d.Rectangle.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.mirror",
                    "signature": "build123d.Rectangle.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Rectangle.move",
                    "signature": "build123d.Rectangle.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.moved",
                    "signature": "build123d.Rectangle.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Rectangle.offset_3d",
                    "signature": "build123d.Rectangle.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Rectangle.project_faces",
                    "signature": "build123d.Rectangle.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Rectangle.project_to_viewport",
                    "signature": "build123d.Rectangle.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Rectangle.relocate",
                    "signature": "build123d.Rectangle.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Rectangle.rotate",
                    "signature": "build123d.Rectangle.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Rectangle.scale",
                    "signature": "build123d.Rectangle.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.shape_type",
                    "signature": "build123d.Rectangle.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Rectangle.shell",
                    "signature": "build123d.Rectangle.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Rectangle.shells",
                    "signature": "build123d.Rectangle.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Rectangle.show_topology",
                    "signature": "build123d.Rectangle.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Rectangle.solid",
                    "signature": "build123d.Rectangle.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Rectangle.solids",
                    "signature": "build123d.Rectangle.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Rectangle.split",
                    "signature": "build123d.Rectangle.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Rectangle.split_by_perimeter",
                    "signature": "build123d.Rectangle.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Rectangle.tessellate",
                    "signature": "build123d.Rectangle.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Rectangle.to_arcs",
                    "signature": "build123d.Rectangle.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Rectangle.to_splines",
                    "signature": "build123d.Rectangle.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Rectangle.to_vtk_poly_data",
                    "signature": "build123d.Rectangle.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Rectangle.transform_geometry",
                    "signature": "build123d.Rectangle.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Rectangle.transform_shape",
                    "signature": "build123d.Rectangle.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Rectangle.transformed",
                    "signature": "build123d.Rectangle.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Rectangle.translate",
                    "signature": "build123d.Rectangle.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Rectangle.unwrap",
                    "signature": "build123d.Rectangle.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Rectangle.vertex",
                    "signature": "build123d.Rectangle.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Rectangle.vertices",
                    "signature": "build123d.Rectangle.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Rectangle.wire",
                    "signature": "build123d.Rectangle.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Rectangle.wires",
                    "signature": "build123d.Rectangle.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Rectangle\n\nAdd rectangle(s) to sketch.\n\nArgs:\n    width (float): horizontal size\n    height (float): vertical size\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.RectangleRounded",
            "signature": "build123d.RectangleRounded(width: 'float', height: 'float', radius: 'float', rotation: 'float' = 0, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.RectangleRounded.bounding_box",
                    "signature": "build123d.RectangleRounded.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.RectangleRounded.cast",
                    "signature": "build123d.RectangleRounded.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.RectangleRounded.center",
                    "signature": "build123d.RectangleRounded.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.RectangleRounded.chamfer",
                    "signature": "build123d.RectangleRounded.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.RectangleRounded.clean",
                    "signature": "build123d.RectangleRounded.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.RectangleRounded.closest_points",
                    "signature": "build123d.RectangleRounded.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.RectangleRounded.combined_center",
                    "signature": "build123d.RectangleRounded.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.RectangleRounded.compound",
                    "signature": "build123d.RectangleRounded.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.RectangleRounded.compounds",
                    "signature": "build123d.RectangleRounded.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.RectangleRounded.compute_mass",
                    "signature": "build123d.RectangleRounded.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.copy",
                    "signature": "build123d.RectangleRounded.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.RectangleRounded.copy_attributes_to",
                    "signature": "build123d.RectangleRounded.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.RectangleRounded.cut",
                    "signature": "build123d.RectangleRounded.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.distance",
                    "signature": "build123d.RectangleRounded.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.distance_to",
                    "signature": "build123d.RectangleRounded.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.RectangleRounded.distance_to_with_closest_points",
                    "signature": "build123d.RectangleRounded.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.RectangleRounded.distances",
                    "signature": "build123d.RectangleRounded.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.do_children_intersect",
                    "signature": "build123d.RectangleRounded.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.RectangleRounded.dprism",
                    "signature": "build123d.RectangleRounded.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.RectangleRounded.edge",
                    "signature": "build123d.RectangleRounded.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.RectangleRounded.edges",
                    "signature": "build123d.RectangleRounded.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.RectangleRounded.export_brep",
                    "signature": "build123d.RectangleRounded.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.export_step",
                    "signature": "build123d.RectangleRounded.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.RectangleRounded.export_stl",
                    "signature": "build123d.RectangleRounded.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.RectangleRounded.extrude",
                    "signature": "build123d.RectangleRounded.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.RectangleRounded.face",
                    "signature": "build123d.RectangleRounded.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.RectangleRounded.faces",
                    "signature": "build123d.RectangleRounded.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.RectangleRounded.faces_intersected_by_axis",
                    "signature": "build123d.RectangleRounded.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.RectangleRounded.fillet",
                    "signature": "build123d.RectangleRounded.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.RectangleRounded.find_intersection",
                    "signature": "build123d.RectangleRounded.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.RectangleRounded.find_intersection_points",
                    "signature": "build123d.RectangleRounded.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.RectangleRounded.first_level_shapes",
                    "signature": "build123d.RectangleRounded.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.RectangleRounded.fix",
                    "signature": "build123d.RectangleRounded.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.RectangleRounded.fuse",
                    "signature": "build123d.RectangleRounded.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.get_type",
                    "signature": "build123d.RectangleRounded.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.RectangleRounded.hash_code",
                    "signature": "build123d.RectangleRounded.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.hollow",
                    "signature": "build123d.RectangleRounded.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.RectangleRounded.intersect",
                    "signature": "build123d.RectangleRounded.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.is_equal",
                    "signature": "build123d.RectangleRounded.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.is_inside",
                    "signature": "build123d.RectangleRounded.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.RectangleRounded.is_null",
                    "signature": "build123d.RectangleRounded.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.is_same",
                    "signature": "build123d.RectangleRounded.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.is_valid",
                    "signature": "build123d.RectangleRounded.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.iter_path_reverse",
                    "signature": "build123d.RectangleRounded.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.RectangleRounded.locate",
                    "signature": "build123d.RectangleRounded.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.located",
                    "signature": "build123d.RectangleRounded.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.RectangleRounded.make_compound",
                    "signature": "build123d.RectangleRounded.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.make_text",
                    "signature": "build123d.RectangleRounded.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.RectangleRounded.make_triad",
                    "signature": "build123d.RectangleRounded.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.RectangleRounded.max_fillet",
                    "signature": "build123d.RectangleRounded.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.RectangleRounded.mesh",
                    "signature": "build123d.RectangleRounded.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.mirror",
                    "signature": "build123d.RectangleRounded.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.RectangleRounded.move",
                    "signature": "build123d.RectangleRounded.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.moved",
                    "signature": "build123d.RectangleRounded.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.RectangleRounded.offset_3d",
                    "signature": "build123d.RectangleRounded.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.RectangleRounded.project_faces",
                    "signature": "build123d.RectangleRounded.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.RectangleRounded.project_to_viewport",
                    "signature": "build123d.RectangleRounded.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.RectangleRounded.relocate",
                    "signature": "build123d.RectangleRounded.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.RectangleRounded.rotate",
                    "signature": "build123d.RectangleRounded.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.RectangleRounded.scale",
                    "signature": "build123d.RectangleRounded.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.shape_type",
                    "signature": "build123d.RectangleRounded.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.RectangleRounded.shell",
                    "signature": "build123d.RectangleRounded.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.RectangleRounded.shells",
                    "signature": "build123d.RectangleRounded.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.RectangleRounded.show_topology",
                    "signature": "build123d.RectangleRounded.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.RectangleRounded.solid",
                    "signature": "build123d.RectangleRounded.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.RectangleRounded.solids",
                    "signature": "build123d.RectangleRounded.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.RectangleRounded.split",
                    "signature": "build123d.RectangleRounded.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.RectangleRounded.split_by_perimeter",
                    "signature": "build123d.RectangleRounded.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.RectangleRounded.tessellate",
                    "signature": "build123d.RectangleRounded.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.RectangleRounded.to_arcs",
                    "signature": "build123d.RectangleRounded.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.RectangleRounded.to_splines",
                    "signature": "build123d.RectangleRounded.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.RectangleRounded.to_vtk_poly_data",
                    "signature": "build123d.RectangleRounded.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.RectangleRounded.transform_geometry",
                    "signature": "build123d.RectangleRounded.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.RectangleRounded.transform_shape",
                    "signature": "build123d.RectangleRounded.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.RectangleRounded.transformed",
                    "signature": "build123d.RectangleRounded.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.RectangleRounded.translate",
                    "signature": "build123d.RectangleRounded.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.RectangleRounded.unwrap",
                    "signature": "build123d.RectangleRounded.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.RectangleRounded.vertex",
                    "signature": "build123d.RectangleRounded.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.RectangleRounded.vertices",
                    "signature": "build123d.RectangleRounded.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.RectangleRounded.wire",
                    "signature": "build123d.RectangleRounded.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.RectangleRounded.wires",
                    "signature": "build123d.RectangleRounded.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: RectangleRounded\n\nAdd rectangle(s) with filleted corners to sketch.\n\nArgs:\n    width (float): horizontal size\n    height (float): vertical size\n    radius (float): fillet radius\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.RegularPolygon",
            "signature": "build123d.RegularPolygon(radius: 'float', side_count: 'int', major_radius: 'bool' = True, rotation: 'float' = 0, align: 'tuple[Align, Align]' = (<Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.RegularPolygon.bounding_box",
                    "signature": "build123d.RegularPolygon.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.RegularPolygon.cast",
                    "signature": "build123d.RegularPolygon.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.RegularPolygon.center",
                    "signature": "build123d.RegularPolygon.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.RegularPolygon.chamfer",
                    "signature": "build123d.RegularPolygon.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.RegularPolygon.clean",
                    "signature": "build123d.RegularPolygon.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.RegularPolygon.closest_points",
                    "signature": "build123d.RegularPolygon.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.RegularPolygon.combined_center",
                    "signature": "build123d.RegularPolygon.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.RegularPolygon.compound",
                    "signature": "build123d.RegularPolygon.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.RegularPolygon.compounds",
                    "signature": "build123d.RegularPolygon.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.RegularPolygon.compute_mass",
                    "signature": "build123d.RegularPolygon.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.copy",
                    "signature": "build123d.RegularPolygon.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.RegularPolygon.copy_attributes_to",
                    "signature": "build123d.RegularPolygon.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.RegularPolygon.cut",
                    "signature": "build123d.RegularPolygon.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.distance",
                    "signature": "build123d.RegularPolygon.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.distance_to",
                    "signature": "build123d.RegularPolygon.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.RegularPolygon.distance_to_with_closest_points",
                    "signature": "build123d.RegularPolygon.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.RegularPolygon.distances",
                    "signature": "build123d.RegularPolygon.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.do_children_intersect",
                    "signature": "build123d.RegularPolygon.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.RegularPolygon.dprism",
                    "signature": "build123d.RegularPolygon.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.RegularPolygon.edge",
                    "signature": "build123d.RegularPolygon.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.RegularPolygon.edges",
                    "signature": "build123d.RegularPolygon.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.RegularPolygon.export_brep",
                    "signature": "build123d.RegularPolygon.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.export_step",
                    "signature": "build123d.RegularPolygon.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.RegularPolygon.export_stl",
                    "signature": "build123d.RegularPolygon.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.RegularPolygon.extrude",
                    "signature": "build123d.RegularPolygon.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.RegularPolygon.face",
                    "signature": "build123d.RegularPolygon.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.RegularPolygon.faces",
                    "signature": "build123d.RegularPolygon.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.RegularPolygon.faces_intersected_by_axis",
                    "signature": "build123d.RegularPolygon.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.RegularPolygon.fillet",
                    "signature": "build123d.RegularPolygon.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.RegularPolygon.find_intersection",
                    "signature": "build123d.RegularPolygon.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.RegularPolygon.find_intersection_points",
                    "signature": "build123d.RegularPolygon.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.RegularPolygon.first_level_shapes",
                    "signature": "build123d.RegularPolygon.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.RegularPolygon.fix",
                    "signature": "build123d.RegularPolygon.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.RegularPolygon.fuse",
                    "signature": "build123d.RegularPolygon.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.get_type",
                    "signature": "build123d.RegularPolygon.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.RegularPolygon.hash_code",
                    "signature": "build123d.RegularPolygon.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.hollow",
                    "signature": "build123d.RegularPolygon.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.RegularPolygon.intersect",
                    "signature": "build123d.RegularPolygon.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.is_equal",
                    "signature": "build123d.RegularPolygon.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.is_inside",
                    "signature": "build123d.RegularPolygon.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.RegularPolygon.is_null",
                    "signature": "build123d.RegularPolygon.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.is_same",
                    "signature": "build123d.RegularPolygon.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.is_valid",
                    "signature": "build123d.RegularPolygon.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.iter_path_reverse",
                    "signature": "build123d.RegularPolygon.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.RegularPolygon.locate",
                    "signature": "build123d.RegularPolygon.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.located",
                    "signature": "build123d.RegularPolygon.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.RegularPolygon.make_compound",
                    "signature": "build123d.RegularPolygon.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.make_text",
                    "signature": "build123d.RegularPolygon.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.RegularPolygon.make_triad",
                    "signature": "build123d.RegularPolygon.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.RegularPolygon.max_fillet",
                    "signature": "build123d.RegularPolygon.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.RegularPolygon.mesh",
                    "signature": "build123d.RegularPolygon.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.mirror",
                    "signature": "build123d.RegularPolygon.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.RegularPolygon.move",
                    "signature": "build123d.RegularPolygon.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.moved",
                    "signature": "build123d.RegularPolygon.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.RegularPolygon.offset_3d",
                    "signature": "build123d.RegularPolygon.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.RegularPolygon.project_faces",
                    "signature": "build123d.RegularPolygon.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.RegularPolygon.project_to_viewport",
                    "signature": "build123d.RegularPolygon.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.RegularPolygon.relocate",
                    "signature": "build123d.RegularPolygon.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.RegularPolygon.rotate",
                    "signature": "build123d.RegularPolygon.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.RegularPolygon.scale",
                    "signature": "build123d.RegularPolygon.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.shape_type",
                    "signature": "build123d.RegularPolygon.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.RegularPolygon.shell",
                    "signature": "build123d.RegularPolygon.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.RegularPolygon.shells",
                    "signature": "build123d.RegularPolygon.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.RegularPolygon.show_topology",
                    "signature": "build123d.RegularPolygon.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.RegularPolygon.solid",
                    "signature": "build123d.RegularPolygon.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.RegularPolygon.solids",
                    "signature": "build123d.RegularPolygon.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.RegularPolygon.split",
                    "signature": "build123d.RegularPolygon.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.RegularPolygon.split_by_perimeter",
                    "signature": "build123d.RegularPolygon.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.RegularPolygon.tessellate",
                    "signature": "build123d.RegularPolygon.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.RegularPolygon.to_arcs",
                    "signature": "build123d.RegularPolygon.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.RegularPolygon.to_splines",
                    "signature": "build123d.RegularPolygon.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.RegularPolygon.to_vtk_poly_data",
                    "signature": "build123d.RegularPolygon.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.RegularPolygon.transform_geometry",
                    "signature": "build123d.RegularPolygon.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.RegularPolygon.transform_shape",
                    "signature": "build123d.RegularPolygon.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.RegularPolygon.transformed",
                    "signature": "build123d.RegularPolygon.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.RegularPolygon.translate",
                    "signature": "build123d.RegularPolygon.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.RegularPolygon.unwrap",
                    "signature": "build123d.RegularPolygon.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.RegularPolygon.vertex",
                    "signature": "build123d.RegularPolygon.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.RegularPolygon.vertices",
                    "signature": "build123d.RegularPolygon.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.RegularPolygon.wire",
                    "signature": "build123d.RegularPolygon.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.RegularPolygon.wires",
                    "signature": "build123d.RegularPolygon.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Regular Polygon\n\nAdd regular polygon(s) to sketch.\n\nArgs:\n    radius (float): distance from origin to vertices (major), or\n        optionally from the origin to side (minor) with major_radius = False\n    side_count (int): number of polygon sides\n    major_radius (bool): If True the radius is the major radius, else the\n        radius is the minor radius (also known as inscribed radius).\n        Defaults to True.\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.RevoluteJoint",
            "signature": "build123d.RevoluteJoint(label: 'str', to_part: 'Union[Solid, Compound]' = None, axis: 'Axis' = ((0.0, 0.0, 0.0),(0.0, 0.0, 1.0)), angle_reference: 'VectorLike' = None, angular_range: 'tuple[float, float]' = (0, 360))",
            "methods": [
                {
                    "name": "build123d.RevoluteJoint.connect_to",
                    "signature": "build123d.RevoluteJoint.connect_to(self, other: 'RigidJoint', *, angle: 'float' = None)",
                    "docstring": "Connect RevoluteJoint and RigidJoint\n\nArgs:\n    other (RigidJoint): relative to joint\n    angle (float, optional): angle in degrees. Defaults to range min.\n\nReturns:\n    TypeError: other must of type RigidJoint\n    ValueError: angle out of range"
                },
                {
                    "name": "build123d.RevoluteJoint.relative_to",
                    "signature": "build123d.RevoluteJoint.relative_to(self, other: 'RigidJoint', *, angle: 'float' = None)",
                    "docstring": "Relative location of RevoluteJoint to RigidJoint\n\nArgs:\n    other (RigidJoint): relative to joint\n    angle (float, optional): angle in degrees. Defaults to range min.\n\nRaises:\n    TypeError: other must of type RigidJoint\n    ValueError: angle out of range"
                }
            ],
            "variables": [
                "location",
                "symbol"
            ],
            "docstring": "RevoluteJoint\n\nComponent rotates around axis like a hinge.\n\nArgs:\n    label (str): joint label\n    to_part (Union[Solid, Compound], optional): object to attach joint to\n    axis (Axis): axis of rotation\n    angle_reference (VectorLike, optional): direction normal to axis defining where\n        angles will be measured from. Defaults to None.\n    range (tuple[float, float], optional): (min,max) angle of joint. Defaults to (0, 360).\n\nAttributes:\n    angle (float): angle of joint\n    angle_reference (Vector): reference for angular positions\n    angular_range (tuple[float,float]): min and max angular position of joint\n    relative_axis (Axis): joint axis relative to bound part\n\nRaises:\n    ValueError: angle_reference must be normal to axis"
        },
        {
            "name": "build123d.RigidJoint",
            "signature": "build123d.RigidJoint(label: 'str', to_part: 'Optional[Union[Solid, Compound]]' = None, joint_location: 'Union[Location, None]' = None)",
            "methods": [
                {
                    "name": "build123d.RigidJoint.connect_to",
                    "signature": "build123d.RigidJoint.connect_to(self, other: 'Joint', **kwargs)",
                    "docstring": "Connect the RigidJoint to another Joint\n\nArgs:\n    other (Joint): joint to connect to\n    angle (float, optional): angle in degrees. Defaults to range min.\n    angles (RotationLike, optional): angles about axes in degrees. Defaults to\n        range minimums.\n    position (float, optional): linear position. Defaults to linear range min."
                },
                {
                    "name": "build123d.RigidJoint.relative_to",
                    "signature": "build123d.RigidJoint.relative_to(self, other: 'Joint', **kwargs) -> 'Location'",
                    "docstring": "Relative location of RigidJoint to another Joint\n\nArgs:\n    other (RigidJoint): relative to joint\n    angle (float, optional): angle in degrees. Defaults to range min.\n    angles (RotationLike, optional): angles about axes in degrees. Defaults to\n        range minimums.\n    position (float, optional): linear position. Defaults to linear range min.\n\nRaises:\n    TypeError: other must be of a type in: BallJoint, CylindricalJoint,\n        LinearJoint, RevoluteJoint, RigidJoint."
                }
            ],
            "variables": [
                "location",
                "symbol"
            ],
            "docstring": "RigidJoint\n\nA rigid joint fixes two components to one another.\n\nArgs:\n    label (str): joint label\n    to_part (Union[Solid, Compound], optional): object to attach joint to\n    joint_location (Location): global location of joint\n\nAttributes:\n    relative_location (Location): joint location relative to bound object"
        },
        {
            "name": "build123d.Rot",
            "signature": "build123d.Rot(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Rot.intersect",
                    "signature": "build123d.Rot.intersect(self, *args, **kwargs)",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Rot.inverse",
                    "signature": "build123d.Rot.inverse(self) -> 'Location'",
                    "docstring": "Inverted location"
                },
                {
                    "name": "build123d.Rot.to_axis",
                    "signature": "build123d.Rot.to_axis(self) -> 'Axis'",
                    "docstring": "Convert the location into an Axis"
                },
                {
                    "name": "build123d.Rot.to_tuple",
                    "signature": "build123d.Rot.to_tuple(self) -> 'tuple[tuple[float, float, float], tuple[float, float, float]]'",
                    "docstring": "Convert the location to a translation, rotation tuple."
                }
            ],
            "variables": [
                "T",
                "orientation",
                "position",
                "x_axis",
                "y_axis",
                "z_axis"
            ],
            "docstring": "Subclass of Location used only for object rotation\n\nAttributes:\n    X (float): rotation in degrees about X axis\n    Y (float): rotation in degrees about Y axis\n    Z (float): rotation in degrees about Z axis\n    optionally specify rotation ordering with Intrinsic or Extrinsic enums, defaults to Intrinsic.XYZ"
        },
        {
            "name": "build123d.Rotation",
            "signature": "build123d.Rotation(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Rotation.intersect",
                    "signature": "build123d.Rotation.intersect(self, *args, **kwargs)",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Rotation.inverse",
                    "signature": "build123d.Rotation.inverse(self) -> 'Location'",
                    "docstring": "Inverted location"
                },
                {
                    "name": "build123d.Rotation.to_axis",
                    "signature": "build123d.Rotation.to_axis(self) -> 'Axis'",
                    "docstring": "Convert the location into an Axis"
                },
                {
                    "name": "build123d.Rotation.to_tuple",
                    "signature": "build123d.Rotation.to_tuple(self) -> 'tuple[tuple[float, float, float], tuple[float, float, float]]'",
                    "docstring": "Convert the location to a translation, rotation tuple."
                }
            ],
            "variables": [
                "T",
                "orientation",
                "position",
                "x_axis",
                "y_axis",
                "z_axis"
            ],
            "docstring": "Subclass of Location used only for object rotation\n\nAttributes:\n    X (float): rotation in degrees about X axis\n    Y (float): rotation in degrees about Y axis\n    Z (float): rotation in degrees about Z axis\n    optionally specify rotation ordering with Intrinsic or Extrinsic enums, defaults to Intrinsic.XYZ"
        },
        {
            "name": "build123d.SagittaArc",
            "signature": "build123d.SagittaArc(start_point: 'VectorLike', end_point: 'VectorLike', sagitta: 'float', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.SagittaArc.bounding_box",
                    "signature": "build123d.SagittaArc.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.SagittaArc.cast",
                    "signature": "build123d.SagittaArc.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.SagittaArc.center",
                    "signature": "build123d.SagittaArc.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.SagittaArc.clean",
                    "signature": "build123d.SagittaArc.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.SagittaArc.close",
                    "signature": "build123d.SagittaArc.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.SagittaArc.closest_points",
                    "signature": "build123d.SagittaArc.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.SagittaArc.combined_center",
                    "signature": "build123d.SagittaArc.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.SagittaArc.common_plane",
                    "signature": "build123d.SagittaArc.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.SagittaArc.compound",
                    "signature": "build123d.SagittaArc.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.SagittaArc.compounds",
                    "signature": "build123d.SagittaArc.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.SagittaArc.compute_mass",
                    "signature": "build123d.SagittaArc.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.copy",
                    "signature": "build123d.SagittaArc.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.SagittaArc.copy_attributes_to",
                    "signature": "build123d.SagittaArc.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.SagittaArc.cut",
                    "signature": "build123d.SagittaArc.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.distance",
                    "signature": "build123d.SagittaArc.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.distance_to",
                    "signature": "build123d.SagittaArc.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.SagittaArc.distance_to_with_closest_points",
                    "signature": "build123d.SagittaArc.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.SagittaArc.distances",
                    "signature": "build123d.SagittaArc.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.distribute_locations",
                    "signature": "build123d.SagittaArc.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.SagittaArc.edge",
                    "signature": "build123d.SagittaArc.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.SagittaArc.edges",
                    "signature": "build123d.SagittaArc.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.SagittaArc.end_point",
                    "signature": "build123d.SagittaArc.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.SagittaArc.export_brep",
                    "signature": "build123d.SagittaArc.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.export_step",
                    "signature": "build123d.SagittaArc.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.SagittaArc.export_stl",
                    "signature": "build123d.SagittaArc.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.SagittaArc.extrude",
                    "signature": "build123d.SagittaArc.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.SagittaArc.face",
                    "signature": "build123d.SagittaArc.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.SagittaArc.faces",
                    "signature": "build123d.SagittaArc.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.SagittaArc.faces_intersected_by_axis",
                    "signature": "build123d.SagittaArc.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.SagittaArc.find_intersection",
                    "signature": "build123d.SagittaArc.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.SagittaArc.find_intersection_points",
                    "signature": "build123d.SagittaArc.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.SagittaArc.find_tangent",
                    "signature": "build123d.SagittaArc.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.SagittaArc.fix",
                    "signature": "build123d.SagittaArc.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.SagittaArc.fuse",
                    "signature": "build123d.SagittaArc.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.SagittaArc.hash_code",
                    "signature": "build123d.SagittaArc.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.intersect",
                    "signature": "build123d.SagittaArc.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.SagittaArc.is_equal",
                    "signature": "build123d.SagittaArc.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.is_null",
                    "signature": "build123d.SagittaArc.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.is_same",
                    "signature": "build123d.SagittaArc.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.is_valid",
                    "signature": "build123d.SagittaArc.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.iter_path_reverse",
                    "signature": "build123d.SagittaArc.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.SagittaArc.locate",
                    "signature": "build123d.SagittaArc.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.located",
                    "signature": "build123d.SagittaArc.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.SagittaArc.location_at",
                    "signature": "build123d.SagittaArc.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.SagittaArc.locations",
                    "signature": "build123d.SagittaArc.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.SagittaArc.make_bezier",
                    "signature": "build123d.SagittaArc.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.SagittaArc.make_circle",
                    "signature": "build123d.SagittaArc.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.SagittaArc.make_ellipse",
                    "signature": "build123d.SagittaArc.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.SagittaArc.make_helix",
                    "signature": "build123d.SagittaArc.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.SagittaArc.make_line",
                    "signature": "build123d.SagittaArc.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.SagittaArc.make_mid_way",
                    "signature": "build123d.SagittaArc.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.SagittaArc.make_spline",
                    "signature": "build123d.SagittaArc.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.SagittaArc.make_spline_approx",
                    "signature": "build123d.SagittaArc.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.SagittaArc.make_tangent_arc",
                    "signature": "build123d.SagittaArc.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.SagittaArc.make_three_point_arc",
                    "signature": "build123d.SagittaArc.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.SagittaArc.mesh",
                    "signature": "build123d.SagittaArc.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.mirror",
                    "signature": "build123d.SagittaArc.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.SagittaArc.move",
                    "signature": "build123d.SagittaArc.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.moved",
                    "signature": "build123d.SagittaArc.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.SagittaArc.normal",
                    "signature": "build123d.SagittaArc.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.offset_2d",
                    "signature": "build123d.SagittaArc.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.SagittaArc.param_at",
                    "signature": "build123d.SagittaArc.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.SagittaArc.param_at_point",
                    "signature": "build123d.SagittaArc.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.SagittaArc.perpendicular_line",
                    "signature": "build123d.SagittaArc.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.SagittaArc.position_at",
                    "signature": "build123d.SagittaArc.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.SagittaArc.positions",
                    "signature": "build123d.SagittaArc.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.SagittaArc.project",
                    "signature": "build123d.SagittaArc.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.project_faces",
                    "signature": "build123d.SagittaArc.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.SagittaArc.project_to_shape",
                    "signature": "build123d.SagittaArc.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.SagittaArc.project_to_viewport",
                    "signature": "build123d.SagittaArc.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.SagittaArc.relocate",
                    "signature": "build123d.SagittaArc.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.SagittaArc.reversed",
                    "signature": "build123d.SagittaArc.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.SagittaArc.rotate",
                    "signature": "build123d.SagittaArc.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.SagittaArc.scale",
                    "signature": "build123d.SagittaArc.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.shape_type",
                    "signature": "build123d.SagittaArc.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.SagittaArc.shell",
                    "signature": "build123d.SagittaArc.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.SagittaArc.shells",
                    "signature": "build123d.SagittaArc.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.SagittaArc.show_topology",
                    "signature": "build123d.SagittaArc.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.SagittaArc.solid",
                    "signature": "build123d.SagittaArc.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.SagittaArc.solids",
                    "signature": "build123d.SagittaArc.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.SagittaArc.split",
                    "signature": "build123d.SagittaArc.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.SagittaArc.split_by_perimeter",
                    "signature": "build123d.SagittaArc.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.SagittaArc.start_point",
                    "signature": "build123d.SagittaArc.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.SagittaArc.tangent_angle_at",
                    "signature": "build123d.SagittaArc.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.SagittaArc.tangent_at",
                    "signature": "build123d.SagittaArc.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.SagittaArc.tessellate",
                    "signature": "build123d.SagittaArc.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.SagittaArc.to_arcs",
                    "signature": "build123d.SagittaArc.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.SagittaArc.to_axis",
                    "signature": "build123d.SagittaArc.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.SagittaArc.to_splines",
                    "signature": "build123d.SagittaArc.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.SagittaArc.to_vtk_poly_data",
                    "signature": "build123d.SagittaArc.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.SagittaArc.to_wire",
                    "signature": "build123d.SagittaArc.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.SagittaArc.transform_geometry",
                    "signature": "build123d.SagittaArc.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.SagittaArc.transform_shape",
                    "signature": "build123d.SagittaArc.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.SagittaArc.transformed",
                    "signature": "build123d.SagittaArc.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.SagittaArc.translate",
                    "signature": "build123d.SagittaArc.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.SagittaArc.trim",
                    "signature": "build123d.SagittaArc.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.SagittaArc.trim_to_length",
                    "signature": "build123d.SagittaArc.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.SagittaArc.vertex",
                    "signature": "build123d.SagittaArc.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.SagittaArc.vertices",
                    "signature": "build123d.SagittaArc.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.SagittaArc.wire",
                    "signature": "build123d.SagittaArc.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.SagittaArc.wires",
                    "signature": "build123d.SagittaArc.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Sagitta Arc\n\nAdd an arc defined by two points and the height of the arc (sagitta).\n\nArgs:\n    start_point (VectorLike): start\n    end_point (VectorLike): end\n    sagitta (float): arc height\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Select",
            "signature": "build123d.Select()",
            "methods": [],
            "variables": [
                "ALL",
                "LAST",
                "NEW",
                "name",
                "value"
            ],
            "docstring": "Selector scope - all, last operation or new objects"
        },
        {
            "name": "build123d.Shape",
            "signature": "build123d.Shape(obj: 'TopoDS_Shape' = None, label: 'str' = '', color: 'Color' = None, parent: 'Compound' = None)",
            "methods": [
                {
                    "name": "build123d.Shape.bounding_box",
                    "signature": "build123d.Shape.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Shape.cast",
                    "signature": "build123d.Shape.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Shape.center",
                    "signature": "build123d.Shape.center(self) -> 'Vector'",
                    "docstring": "All of the derived classes from Shape need a center method"
                },
                {
                    "name": "build123d.Shape.clean",
                    "signature": "build123d.Shape.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Shape.closest_points",
                    "signature": "build123d.Shape.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Shape.combined_center",
                    "signature": "build123d.Shape.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Shape.compound",
                    "signature": "build123d.Shape.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Shape.compounds",
                    "signature": "build123d.Shape.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Shape.compute_mass",
                    "signature": "build123d.Shape.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.copy",
                    "signature": "build123d.Shape.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Shape.copy_attributes_to",
                    "signature": "build123d.Shape.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Shape.cut",
                    "signature": "build123d.Shape.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.distance",
                    "signature": "build123d.Shape.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.distance_to",
                    "signature": "build123d.Shape.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Shape.distance_to_with_closest_points",
                    "signature": "build123d.Shape.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Shape.distances",
                    "signature": "build123d.Shape.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.edge",
                    "signature": "build123d.Shape.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Shape.edges",
                    "signature": "build123d.Shape.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Shape.export_brep",
                    "signature": "build123d.Shape.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.export_step",
                    "signature": "build123d.Shape.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Shape.export_stl",
                    "signature": "build123d.Shape.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Shape.extrude",
                    "signature": "build123d.Shape.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Shape.face",
                    "signature": "build123d.Shape.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Shape.faces",
                    "signature": "build123d.Shape.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Shape.faces_intersected_by_axis",
                    "signature": "build123d.Shape.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Shape.find_intersection",
                    "signature": "build123d.Shape.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Shape.find_intersection_points",
                    "signature": "build123d.Shape.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Shape.fix",
                    "signature": "build123d.Shape.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Shape.fuse",
                    "signature": "build123d.Shape.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Shape.hash_code",
                    "signature": "build123d.Shape.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.intersect",
                    "signature": "build123d.Shape.intersect(self, *to_intersect: 'Union[Shape, Axis, Plane]') -> 'Shape'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Shape.is_equal",
                    "signature": "build123d.Shape.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.is_null",
                    "signature": "build123d.Shape.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.is_same",
                    "signature": "build123d.Shape.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.is_valid",
                    "signature": "build123d.Shape.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.iter_path_reverse",
                    "signature": "build123d.Shape.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Shape.locate",
                    "signature": "build123d.Shape.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.located",
                    "signature": "build123d.Shape.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Shape.mesh",
                    "signature": "build123d.Shape.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.mirror",
                    "signature": "build123d.Shape.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Shape.move",
                    "signature": "build123d.Shape.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.moved",
                    "signature": "build123d.Shape.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Shape.project_faces",
                    "signature": "build123d.Shape.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Shape.project_to_viewport",
                    "signature": "build123d.Shape.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Shape.relocate",
                    "signature": "build123d.Shape.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Shape.rotate",
                    "signature": "build123d.Shape.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Shape.scale",
                    "signature": "build123d.Shape.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.shape_type",
                    "signature": "build123d.Shape.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Shape.shell",
                    "signature": "build123d.Shape.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Shape.shells",
                    "signature": "build123d.Shape.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Shape.show_topology",
                    "signature": "build123d.Shape.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Shape.solid",
                    "signature": "build123d.Shape.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Shape.solids",
                    "signature": "build123d.Shape.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Shape.split",
                    "signature": "build123d.Shape.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Shape.split_by_perimeter",
                    "signature": "build123d.Shape.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Shape.tessellate",
                    "signature": "build123d.Shape.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Shape.to_arcs",
                    "signature": "build123d.Shape.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Shape.to_splines",
                    "signature": "build123d.Shape.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Shape.to_vtk_poly_data",
                    "signature": "build123d.Shape.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Shape.transform_geometry",
                    "signature": "build123d.Shape.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Shape.transform_shape",
                    "signature": "build123d.Shape.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Shape.transformed",
                    "signature": "build123d.Shape.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Shape.translate",
                    "signature": "build123d.Shape.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Shape.vertex",
                    "signature": "build123d.Shape.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Shape.vertices",
                    "signature": "build123d.Shape.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Shape.wire",
                    "signature": "build123d.Shape.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Shape.wires",
                    "signature": "build123d.Shape.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size"
            ],
            "docstring": "Shape\n\nBase class for all CAD objects such as Edge, Face, Solid, etc.\n\nArgs:\n    obj (TopoDS_Shape, optional): OCCT object. Defaults to None.\n    label (str, optional): Defaults to ''.\n    color (Color, optional): Defaults to None.\n    parent (Compound, optional): assembly parent. Defaults to None.\n\nAttributes:\n    wrapped (TopoDS_Shape): the OCP object\n    label (str): user assigned label\n    color (Color): object color\n    joints (dict[str:Joint]): dictionary of joints bound to this object (Solid only)\n    children (Shape): list of assembly children of this object (Compound only)\n    topo_parent (Shape): assembly parent of this object"
        },
        {
            "name": "build123d.ShapeList",
            "signature": "build123d.ShapeList()",
            "methods": [
                {
                    "name": "build123d.ShapeList.append",
                    "signature": "build123d.ShapeList.append(self, object, /)",
                    "docstring": "Append object to the end of the list."
                },
                {
                    "name": "build123d.ShapeList.clear",
                    "signature": "build123d.ShapeList.clear(self, /)",
                    "docstring": "Remove all items from list."
                },
                {
                    "name": "build123d.ShapeList.compound",
                    "signature": "build123d.ShapeList.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.ShapeList.compounds",
                    "signature": "build123d.ShapeList.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this ShapeList"
                },
                {
                    "name": "build123d.ShapeList.copy",
                    "signature": "build123d.ShapeList.copy(self, /)",
                    "docstring": "Return a shallow copy of the list."
                },
                {
                    "name": "build123d.ShapeList.count",
                    "signature": "build123d.ShapeList.count(self, value, /)",
                    "docstring": "Return number of occurrences of value."
                },
                {
                    "name": "build123d.ShapeList.edge",
                    "signature": "build123d.ShapeList.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.ShapeList.edges",
                    "signature": "build123d.ShapeList.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this ShapeList"
                },
                {
                    "name": "build123d.ShapeList.extend",
                    "signature": "build123d.ShapeList.extend(self, iterable, /)",
                    "docstring": "Extend list by appending elements from the iterable."
                },
                {
                    "name": "build123d.ShapeList.face",
                    "signature": "build123d.ShapeList.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.ShapeList.faces",
                    "signature": "build123d.ShapeList.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this ShapeList"
                },
                {
                    "name": "build123d.ShapeList.filter_by",
                    "signature": "build123d.ShapeList.filter_by(self, filter_by: 'Union[ShapePredicate, Axis, Plane, GeomType]', reverse: 'bool' = False, tolerance: 'float' = 1e-05) -> 'ShapeList[T]'",
                    "docstring": "filter by Axis, Plane, or GeomType\n\nEither:\n- filter objects of type planar Face or linear Edge by their normal or tangent\n(respectively) and sort the results by the given axis, or\n- filter the objects by the provided type. Note that not all types apply to all\nobjects.\n\nArgs:\n    filter_by (Union[Axis,Plane,GeomType]): axis, plane, or geom type to filter\n        and possibly sort by. Filtering by a plane returns faces/edges parallel\n        to that plane.\n    reverse (bool, optional): invert the geom type filter. Defaults to False.\n    tolerance (float, optional): maximum deviation from axis. Defaults to 1e-5.\n\nRaises:\n    ValueError: Invalid filter_by type\n\nReturns:\n    ShapeList: filtered list of objects"
                },
                {
                    "name": "build123d.ShapeList.filter_by_position",
                    "signature": "build123d.ShapeList.filter_by_position(self, axis: 'Axis', minimum: 'float', maximum: 'float', inclusive: 'tuple[bool, bool]' = (True, True)) -> 'ShapeList[T]'",
                    "docstring": "filter by position\n\nFilter and sort objects by the position of their centers along given axis.\nmin and max values can be inclusive or exclusive depending on the inclusive tuple.\n\nArgs:\n    axis (Axis): axis to sort by\n    minimum (float): minimum value\n    maximum (float): maximum value\n    inclusive (tuple[bool, bool], optional): include min,max values.\n        Defaults to (True, True).\n\nReturns:\n    ShapeList: filtered object list"
                },
                {
                    "name": "build123d.ShapeList.group_by",
                    "signature": "build123d.ShapeList.group_by(self, group_by: 'Union[Callable[[Shape], K], Axis, Edge, Wire, SortBy]' = ((0.0, 0.0, 0.0),(0.0, 0.0, 1.0)), reverse=False, tol_digits=6) -> 'GroupBy[T, K]'",
                    "docstring": "group by\n\nGroup objects by provided criteria and then sort the groups according to the criteria.\nNote that not all group_by criteria apply to all objects.\n\nArgs:\n    group_by (SortBy, optional): group and sort criteria. Defaults to Axis.Z.\n    reverse (bool, optional): flip order of sort. Defaults to False.\n    tol_digits (int, optional): Tolerance for building the group keys by\n        round(key, tol_digits)\n\nReturns:\n    GroupBy[K, ShapeList]: sorted list of ShapeLists"
                },
                {
                    "name": "build123d.ShapeList.index",
                    "signature": "build123d.ShapeList.index(self, value, start=0, stop=9223372036854775807, /)",
                    "docstring": "Return first index of value.\n\nRaises ValueError if the value is not present."
                },
                {
                    "name": "build123d.ShapeList.insert",
                    "signature": "build123d.ShapeList.insert(self, index, object, /)",
                    "docstring": "Insert object before index."
                },
                {
                    "name": "build123d.ShapeList.pop",
                    "signature": "build123d.ShapeList.pop(self, index=-1, /)",
                    "docstring": "Remove and return item at index (default last).\n\nRaises IndexError if list is empty or index is out of range."
                },
                {
                    "name": "build123d.ShapeList.remove",
                    "signature": "build123d.ShapeList.remove(self, value, /)",
                    "docstring": "Remove first occurrence of value.\n\nRaises ValueError if the value is not present."
                },
                {
                    "name": "build123d.ShapeList.reverse",
                    "signature": "build123d.ShapeList.reverse(self, /)",
                    "docstring": "Reverse *IN PLACE*."
                },
                {
                    "name": "build123d.ShapeList.shell",
                    "signature": "build123d.ShapeList.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.ShapeList.shells",
                    "signature": "build123d.ShapeList.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this ShapeList"
                },
                {
                    "name": "build123d.ShapeList.solid",
                    "signature": "build123d.ShapeList.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.ShapeList.solids",
                    "signature": "build123d.ShapeList.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this ShapeList"
                },
                {
                    "name": "build123d.ShapeList.sort",
                    "signature": "build123d.ShapeList.sort(self, /, *, key=None, reverse=False)",
                    "docstring": "Sort the list in ascending order and return None.\n\nThe sort is in-place (i.e. the list itself is modified) and stable (i.e. the\norder of two equal elements is maintained).\n\nIf a key function is given, apply it once to each list item and sort them,\nascending or descending, according to their function values.\n\nThe reverse flag can be set to sort in descending order."
                },
                {
                    "name": "build123d.ShapeList.sort_by",
                    "signature": "build123d.ShapeList.sort_by(self, sort_by: 'Union[Axis, Edge, Wire, SortBy]' = ((0.0, 0.0, 0.0),(0.0, 0.0, 1.0)), reverse: 'bool' = False) -> 'ShapeList[T]'",
                    "docstring": "sort by\n\nSort objects by provided criteria. Note that not all sort_by criteria apply to all\nobjects.\n\nArgs:\n    sort_by (SortBy, optional): sort criteria. Defaults to SortBy.Z.\n    reverse (bool, optional): flip order of sort. Defaults to False.\n\nReturns:\n    ShapeList: sorted list of objects"
                },
                {
                    "name": "build123d.ShapeList.sort_by_distance",
                    "signature": "build123d.ShapeList.sort_by_distance(self, other: 'Union[Shape, VectorLike]', reverse: 'bool' = False) -> 'ShapeList[T]'",
                    "docstring": "Sort by distance\n\nSort by minimal distance between objects and other\n\nArgs:\n    other (Union[Shape,VectorLike]): reference object\n    reverse (bool, optional): flip order of sort. Defaults to False.\n\nReturns:\n    ShapeList: Sorted shapes"
                },
                {
                    "name": "build123d.ShapeList.vertex",
                    "signature": "build123d.ShapeList.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.ShapeList.vertices",
                    "signature": "build123d.ShapeList.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this ShapeList"
                },
                {
                    "name": "build123d.ShapeList.wire",
                    "signature": "build123d.ShapeList.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.ShapeList.wires",
                    "signature": "build123d.ShapeList.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this ShapeList"
                }
            ],
            "variables": [
                "first",
                "last"
            ],
            "docstring": "Subclass of list with custom filter and sort methods appropriate to CAD"
        },
        {
            "name": "build123d.ShapePredicate",
            "signature": "build123d.ShapePredicate(*args, **kwargs)",
            "methods": [],
            "variables": [],
            "docstring": "Predicate for shape filters"
        },
        {
            "name": "build123d.Shell",
            "signature": "build123d.Shell(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Shell.bounding_box",
                    "signature": "build123d.Shell.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Shell.cast",
                    "signature": "build123d.Shell.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Shell.center",
                    "signature": "build123d.Shell.center(self) -> 'Vector'",
                    "docstring": "Center of mass of the shell"
                },
                {
                    "name": "build123d.Shell.clean",
                    "signature": "build123d.Shell.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Shell.closest_points",
                    "signature": "build123d.Shell.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Shell.combined_center",
                    "signature": "build123d.Shell.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Shell.compound",
                    "signature": "build123d.Shell.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Shell.compounds",
                    "signature": "build123d.Shell.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Shell.compute_mass",
                    "signature": "build123d.Shell.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.copy",
                    "signature": "build123d.Shell.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Shell.copy_attributes_to",
                    "signature": "build123d.Shell.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Shell.cut",
                    "signature": "build123d.Shell.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.distance",
                    "signature": "build123d.Shell.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.distance_to",
                    "signature": "build123d.Shell.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Shell.distance_to_with_closest_points",
                    "signature": "build123d.Shell.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Shell.distances",
                    "signature": "build123d.Shell.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.edge",
                    "signature": "build123d.Shell.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Shell.edges",
                    "signature": "build123d.Shell.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Shell.export_brep",
                    "signature": "build123d.Shell.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.export_step",
                    "signature": "build123d.Shell.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Shell.export_stl",
                    "signature": "build123d.Shell.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Shell.extrude",
                    "signature": "build123d.Shell.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Shell.face",
                    "signature": "build123d.Shell.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Shell.faces",
                    "signature": "build123d.Shell.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Shell.faces_intersected_by_axis",
                    "signature": "build123d.Shell.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Shell.find_intersection",
                    "signature": "build123d.Shell.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Shell.find_intersection_points",
                    "signature": "build123d.Shell.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Shell.fix",
                    "signature": "build123d.Shell.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Shell.fuse",
                    "signature": "build123d.Shell.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Shell.hash_code",
                    "signature": "build123d.Shell.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.intersect",
                    "signature": "build123d.Shell.intersect(self, *to_intersect: 'Union[Shape, Axis, Plane]') -> 'Shape'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Shell.is_equal",
                    "signature": "build123d.Shell.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.is_null",
                    "signature": "build123d.Shell.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.is_same",
                    "signature": "build123d.Shell.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.is_valid",
                    "signature": "build123d.Shell.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.iter_path_reverse",
                    "signature": "build123d.Shell.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Shell.locate",
                    "signature": "build123d.Shell.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.located",
                    "signature": "build123d.Shell.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Shell.make_loft",
                    "signature": "build123d.Shell.make_loft(objs: 'Iterable[Union[Vertex, Wire]]', ruled: 'bool' = False) -> 'Shell'",
                    "docstring": "make loft\n\nMakes a loft from a list of wires and vertices.\nVertices can appear only at the beginning or end of the list, but cannot appear consecutively within the list\nnor between wires.\nWires may be closed or opened.\n\nArgs:\n    objs (list[Vertex, Wire]): wire perimeters or vertices\n    ruled (bool, optional): stepped or smooth. Defaults to False (smooth).\n\nRaises:\n    ValueError: Too few wires\n\nReturns:\n    Shell: Lofted object"
                },
                {
                    "name": "build123d.Shell.make_shell",
                    "signature": "build123d.Shell.make_shell(faces: 'Iterable[Face]') -> 'Shell'",
                    "docstring": "Create a Shell from provided faces"
                },
                {
                    "name": "build123d.Shell.mesh",
                    "signature": "build123d.Shell.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.mirror",
                    "signature": "build123d.Shell.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Shell.move",
                    "signature": "build123d.Shell.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.moved",
                    "signature": "build123d.Shell.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Shell.project_faces",
                    "signature": "build123d.Shell.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Shell.project_to_viewport",
                    "signature": "build123d.Shell.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Shell.relocate",
                    "signature": "build123d.Shell.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Shell.rotate",
                    "signature": "build123d.Shell.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Shell.scale",
                    "signature": "build123d.Shell.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.shape_type",
                    "signature": "build123d.Shell.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Shell.shell",
                    "signature": "build123d.Shell.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Shell.shells",
                    "signature": "build123d.Shell.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Shell.show_topology",
                    "signature": "build123d.Shell.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Shell.solid",
                    "signature": "build123d.Shell.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Shell.solids",
                    "signature": "build123d.Shell.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Shell.split",
                    "signature": "build123d.Shell.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Shell.split_by_perimeter",
                    "signature": "build123d.Shell.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Shell.sweep",
                    "signature": "build123d.Shell.sweep(profile: 'Union[Curve, Edge, Wire]', path: 'Union[Curve, Edge, Wire]', transition=<Transition.TRANSFORMED>) -> 'Shell'",
                    "docstring": "sweep\n\nSweep a 1D profile along a 1D path\n\nArgs:\n    profile (Union[Curve, Edge, Wire]): the object to sweep\n    path (Union[Curve, Edge, Wire]): the path to follow when sweeping\n    transition (Transition, optional): handling of profile orientation at C1 path\n        discontinuities. Defaults to Transition.TRANSFORMED.\n\nReturns:\n    Shell: resulting Shell, may be non-planar"
                },
                {
                    "name": "build123d.Shell.tessellate",
                    "signature": "build123d.Shell.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Shell.thicken",
                    "signature": "build123d.Shell.thicken(self, depth: 'float') -> 'Solid'",
                    "docstring": "Thicken Shell\n\nCreate a solid from a shell by thickening along the normals.\n\nArgs:\n    depth (float): Amount to thicken face(s), can be positive or negative.\n\nRaises:\n    RuntimeError: Opencascade internal failures\n\nReturns:\n    Solid: The resulting Solid object"
                },
                {
                    "name": "build123d.Shell.to_arcs",
                    "signature": "build123d.Shell.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Shell.to_splines",
                    "signature": "build123d.Shell.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Shell.to_vtk_poly_data",
                    "signature": "build123d.Shell.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Shell.transform_geometry",
                    "signature": "build123d.Shell.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Shell.transform_shape",
                    "signature": "build123d.Shell.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Shell.transformed",
                    "signature": "build123d.Shell.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Shell.translate",
                    "signature": "build123d.Shell.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Shell.vertex",
                    "signature": "build123d.Shell.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Shell.vertices",
                    "signature": "build123d.Shell.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Shell.wire",
                    "signature": "build123d.Shell.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Shell.wires",
                    "signature": "build123d.Shell.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "A Shell is a fundamental component in build123d's topological data structure\nrepresenting a connected set of faces forming a closed surface in 3D space. As\npart of a geometric model, it defines a watertight enclosure, commonly encountered\nin solid modeling. Shells group faces in a coherent manner, playing a crucial role\nin representing complex shapes with voids and surfaces. This hierarchical structure\nallows for efficient handling of surfaces within a model, supporting various\noperations and analyses."
        },
        {
            "name": "build123d.Side",
            "signature": "build123d.Side()",
            "methods": [],
            "variables": [
                "BOTH",
                "LEFT",
                "RIGHT",
                "name",
                "value"
            ],
            "docstring": "2D Offset types"
        },
        {
            "name": "build123d.Sketch",
            "signature": "build123d.Sketch()",
            "methods": [
                {
                    "name": "build123d.Sketch.bounding_box",
                    "signature": "build123d.Sketch.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Sketch.cast",
                    "signature": "build123d.Sketch.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Sketch.center",
                    "signature": "build123d.Sketch.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Sketch.chamfer",
                    "signature": "build123d.Sketch.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Sketch.clean",
                    "signature": "build123d.Sketch.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Sketch.closest_points",
                    "signature": "build123d.Sketch.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Sketch.combined_center",
                    "signature": "build123d.Sketch.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Sketch.compound",
                    "signature": "build123d.Sketch.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Sketch.compounds",
                    "signature": "build123d.Sketch.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Sketch.compute_mass",
                    "signature": "build123d.Sketch.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.copy",
                    "signature": "build123d.Sketch.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Sketch.copy_attributes_to",
                    "signature": "build123d.Sketch.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Sketch.cut",
                    "signature": "build123d.Sketch.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.distance",
                    "signature": "build123d.Sketch.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.distance_to",
                    "signature": "build123d.Sketch.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Sketch.distance_to_with_closest_points",
                    "signature": "build123d.Sketch.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Sketch.distances",
                    "signature": "build123d.Sketch.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.do_children_intersect",
                    "signature": "build123d.Sketch.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Sketch.dprism",
                    "signature": "build123d.Sketch.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Sketch.edge",
                    "signature": "build123d.Sketch.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Sketch.edges",
                    "signature": "build123d.Sketch.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Sketch.export_brep",
                    "signature": "build123d.Sketch.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.export_step",
                    "signature": "build123d.Sketch.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Sketch.export_stl",
                    "signature": "build123d.Sketch.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Sketch.extrude",
                    "signature": "build123d.Sketch.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Sketch.face",
                    "signature": "build123d.Sketch.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Sketch.faces",
                    "signature": "build123d.Sketch.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Sketch.faces_intersected_by_axis",
                    "signature": "build123d.Sketch.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Sketch.fillet",
                    "signature": "build123d.Sketch.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Sketch.find_intersection",
                    "signature": "build123d.Sketch.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Sketch.find_intersection_points",
                    "signature": "build123d.Sketch.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Sketch.first_level_shapes",
                    "signature": "build123d.Sketch.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Sketch.fix",
                    "signature": "build123d.Sketch.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Sketch.fuse",
                    "signature": "build123d.Sketch.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.get_type",
                    "signature": "build123d.Sketch.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Sketch.hash_code",
                    "signature": "build123d.Sketch.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.hollow",
                    "signature": "build123d.Sketch.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Sketch.intersect",
                    "signature": "build123d.Sketch.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.is_equal",
                    "signature": "build123d.Sketch.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.is_inside",
                    "signature": "build123d.Sketch.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Sketch.is_null",
                    "signature": "build123d.Sketch.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.is_same",
                    "signature": "build123d.Sketch.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.is_valid",
                    "signature": "build123d.Sketch.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.iter_path_reverse",
                    "signature": "build123d.Sketch.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Sketch.locate",
                    "signature": "build123d.Sketch.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.located",
                    "signature": "build123d.Sketch.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Sketch.make_compound",
                    "signature": "build123d.Sketch.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Sketch.make_text",
                    "signature": "build123d.Sketch.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Sketch.make_triad",
                    "signature": "build123d.Sketch.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Sketch.max_fillet",
                    "signature": "build123d.Sketch.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Sketch.mesh",
                    "signature": "build123d.Sketch.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.mirror",
                    "signature": "build123d.Sketch.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Sketch.move",
                    "signature": "build123d.Sketch.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.moved",
                    "signature": "build123d.Sketch.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Sketch.offset_3d",
                    "signature": "build123d.Sketch.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Sketch.project_faces",
                    "signature": "build123d.Sketch.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Sketch.project_to_viewport",
                    "signature": "build123d.Sketch.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Sketch.relocate",
                    "signature": "build123d.Sketch.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Sketch.rotate",
                    "signature": "build123d.Sketch.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Sketch.scale",
                    "signature": "build123d.Sketch.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.shape_type",
                    "signature": "build123d.Sketch.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Sketch.shell",
                    "signature": "build123d.Sketch.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Sketch.shells",
                    "signature": "build123d.Sketch.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Sketch.show_topology",
                    "signature": "build123d.Sketch.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Sketch.solid",
                    "signature": "build123d.Sketch.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Sketch.solids",
                    "signature": "build123d.Sketch.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Sketch.split",
                    "signature": "build123d.Sketch.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Sketch.split_by_perimeter",
                    "signature": "build123d.Sketch.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Sketch.tessellate",
                    "signature": "build123d.Sketch.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Sketch.to_arcs",
                    "signature": "build123d.Sketch.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Sketch.to_splines",
                    "signature": "build123d.Sketch.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Sketch.to_vtk_poly_data",
                    "signature": "build123d.Sketch.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Sketch.transform_geometry",
                    "signature": "build123d.Sketch.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Sketch.transform_shape",
                    "signature": "build123d.Sketch.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Sketch.transformed",
                    "signature": "build123d.Sketch.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Sketch.translate",
                    "signature": "build123d.Sketch.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Sketch.unwrap",
                    "signature": "build123d.Sketch.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Sketch.vertex",
                    "signature": "build123d.Sketch.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Sketch.vertices",
                    "signature": "build123d.Sketch.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Sketch.wire",
                    "signature": "build123d.Sketch.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Sketch.wires",
                    "signature": "build123d.Sketch.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "A Compound containing 2D objects - aka Faces"
        },
        {
            "name": "build123d.SkipClean",
            "signature": "build123d.SkipClean()",
            "methods": [],
            "variables": [
                "clean"
            ],
            "docstring": "Skip clean context for use in operator driven code where clean=False wouldn't work"
        },
        {
            "name": "build123d.SlotArc",
            "signature": "build123d.SlotArc(arc: 'Union[Edge, Wire]', height: 'float', rotation: 'float' = 0, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.SlotArc.bounding_box",
                    "signature": "build123d.SlotArc.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.SlotArc.cast",
                    "signature": "build123d.SlotArc.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.SlotArc.center",
                    "signature": "build123d.SlotArc.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.SlotArc.chamfer",
                    "signature": "build123d.SlotArc.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.SlotArc.clean",
                    "signature": "build123d.SlotArc.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.SlotArc.closest_points",
                    "signature": "build123d.SlotArc.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.SlotArc.combined_center",
                    "signature": "build123d.SlotArc.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.SlotArc.compound",
                    "signature": "build123d.SlotArc.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.SlotArc.compounds",
                    "signature": "build123d.SlotArc.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.SlotArc.compute_mass",
                    "signature": "build123d.SlotArc.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.copy",
                    "signature": "build123d.SlotArc.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.SlotArc.copy_attributes_to",
                    "signature": "build123d.SlotArc.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.SlotArc.cut",
                    "signature": "build123d.SlotArc.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.distance",
                    "signature": "build123d.SlotArc.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.distance_to",
                    "signature": "build123d.SlotArc.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.SlotArc.distance_to_with_closest_points",
                    "signature": "build123d.SlotArc.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.SlotArc.distances",
                    "signature": "build123d.SlotArc.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.do_children_intersect",
                    "signature": "build123d.SlotArc.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.SlotArc.dprism",
                    "signature": "build123d.SlotArc.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.SlotArc.edge",
                    "signature": "build123d.SlotArc.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.SlotArc.edges",
                    "signature": "build123d.SlotArc.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.SlotArc.export_brep",
                    "signature": "build123d.SlotArc.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.export_step",
                    "signature": "build123d.SlotArc.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.SlotArc.export_stl",
                    "signature": "build123d.SlotArc.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.SlotArc.extrude",
                    "signature": "build123d.SlotArc.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.SlotArc.face",
                    "signature": "build123d.SlotArc.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.SlotArc.faces",
                    "signature": "build123d.SlotArc.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.SlotArc.faces_intersected_by_axis",
                    "signature": "build123d.SlotArc.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.SlotArc.fillet",
                    "signature": "build123d.SlotArc.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.SlotArc.find_intersection",
                    "signature": "build123d.SlotArc.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.SlotArc.find_intersection_points",
                    "signature": "build123d.SlotArc.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.SlotArc.first_level_shapes",
                    "signature": "build123d.SlotArc.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.SlotArc.fix",
                    "signature": "build123d.SlotArc.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.SlotArc.fuse",
                    "signature": "build123d.SlotArc.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.get_type",
                    "signature": "build123d.SlotArc.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.SlotArc.hash_code",
                    "signature": "build123d.SlotArc.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.hollow",
                    "signature": "build123d.SlotArc.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.SlotArc.intersect",
                    "signature": "build123d.SlotArc.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.is_equal",
                    "signature": "build123d.SlotArc.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.is_inside",
                    "signature": "build123d.SlotArc.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.SlotArc.is_null",
                    "signature": "build123d.SlotArc.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.is_same",
                    "signature": "build123d.SlotArc.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.is_valid",
                    "signature": "build123d.SlotArc.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.iter_path_reverse",
                    "signature": "build123d.SlotArc.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.SlotArc.locate",
                    "signature": "build123d.SlotArc.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.located",
                    "signature": "build123d.SlotArc.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.SlotArc.make_compound",
                    "signature": "build123d.SlotArc.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.make_text",
                    "signature": "build123d.SlotArc.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.SlotArc.make_triad",
                    "signature": "build123d.SlotArc.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.SlotArc.max_fillet",
                    "signature": "build123d.SlotArc.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.SlotArc.mesh",
                    "signature": "build123d.SlotArc.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.mirror",
                    "signature": "build123d.SlotArc.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.SlotArc.move",
                    "signature": "build123d.SlotArc.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.moved",
                    "signature": "build123d.SlotArc.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.SlotArc.offset_3d",
                    "signature": "build123d.SlotArc.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.SlotArc.project_faces",
                    "signature": "build123d.SlotArc.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.SlotArc.project_to_viewport",
                    "signature": "build123d.SlotArc.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.SlotArc.relocate",
                    "signature": "build123d.SlotArc.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.SlotArc.rotate",
                    "signature": "build123d.SlotArc.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.SlotArc.scale",
                    "signature": "build123d.SlotArc.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.shape_type",
                    "signature": "build123d.SlotArc.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.SlotArc.shell",
                    "signature": "build123d.SlotArc.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.SlotArc.shells",
                    "signature": "build123d.SlotArc.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.SlotArc.show_topology",
                    "signature": "build123d.SlotArc.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.SlotArc.solid",
                    "signature": "build123d.SlotArc.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.SlotArc.solids",
                    "signature": "build123d.SlotArc.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.SlotArc.split",
                    "signature": "build123d.SlotArc.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.SlotArc.split_by_perimeter",
                    "signature": "build123d.SlotArc.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.SlotArc.tessellate",
                    "signature": "build123d.SlotArc.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.SlotArc.to_arcs",
                    "signature": "build123d.SlotArc.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.SlotArc.to_splines",
                    "signature": "build123d.SlotArc.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.SlotArc.to_vtk_poly_data",
                    "signature": "build123d.SlotArc.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.SlotArc.transform_geometry",
                    "signature": "build123d.SlotArc.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.SlotArc.transform_shape",
                    "signature": "build123d.SlotArc.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.SlotArc.transformed",
                    "signature": "build123d.SlotArc.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.SlotArc.translate",
                    "signature": "build123d.SlotArc.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotArc.unwrap",
                    "signature": "build123d.SlotArc.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.SlotArc.vertex",
                    "signature": "build123d.SlotArc.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.SlotArc.vertices",
                    "signature": "build123d.SlotArc.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.SlotArc.wire",
                    "signature": "build123d.SlotArc.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.SlotArc.wires",
                    "signature": "build123d.SlotArc.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Arc Slot\n\nAdd slot(s) following an arc to sketch.\n\nArgs:\n    arc (Union[Edge, Wire]): center line of slot\n    height (float): diameter of end circles\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.SlotCenterPoint",
            "signature": "build123d.SlotCenterPoint(center: 'VectorLike', point: 'VectorLike', height: 'float', rotation: 'float' = 0, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.SlotCenterPoint.bounding_box",
                    "signature": "build123d.SlotCenterPoint.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.cast",
                    "signature": "build123d.SlotCenterPoint.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.SlotCenterPoint.center",
                    "signature": "build123d.SlotCenterPoint.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.SlotCenterPoint.chamfer",
                    "signature": "build123d.SlotCenterPoint.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.SlotCenterPoint.clean",
                    "signature": "build123d.SlotCenterPoint.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.SlotCenterPoint.closest_points",
                    "signature": "build123d.SlotCenterPoint.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.SlotCenterPoint.combined_center",
                    "signature": "build123d.SlotCenterPoint.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.SlotCenterPoint.compound",
                    "signature": "build123d.SlotCenterPoint.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.SlotCenterPoint.compounds",
                    "signature": "build123d.SlotCenterPoint.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.compute_mass",
                    "signature": "build123d.SlotCenterPoint.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.copy",
                    "signature": "build123d.SlotCenterPoint.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.SlotCenterPoint.copy_attributes_to",
                    "signature": "build123d.SlotCenterPoint.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.SlotCenterPoint.cut",
                    "signature": "build123d.SlotCenterPoint.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.distance",
                    "signature": "build123d.SlotCenterPoint.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.distance_to",
                    "signature": "build123d.SlotCenterPoint.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.SlotCenterPoint.distance_to_with_closest_points",
                    "signature": "build123d.SlotCenterPoint.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.distances",
                    "signature": "build123d.SlotCenterPoint.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.do_children_intersect",
                    "signature": "build123d.SlotCenterPoint.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.SlotCenterPoint.dprism",
                    "signature": "build123d.SlotCenterPoint.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.SlotCenterPoint.edge",
                    "signature": "build123d.SlotCenterPoint.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.SlotCenterPoint.edges",
                    "signature": "build123d.SlotCenterPoint.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.export_brep",
                    "signature": "build123d.SlotCenterPoint.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.export_step",
                    "signature": "build123d.SlotCenterPoint.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.SlotCenterPoint.export_stl",
                    "signature": "build123d.SlotCenterPoint.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.SlotCenterPoint.extrude",
                    "signature": "build123d.SlotCenterPoint.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.face",
                    "signature": "build123d.SlotCenterPoint.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.SlotCenterPoint.faces",
                    "signature": "build123d.SlotCenterPoint.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.faces_intersected_by_axis",
                    "signature": "build123d.SlotCenterPoint.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.SlotCenterPoint.fillet",
                    "signature": "build123d.SlotCenterPoint.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.SlotCenterPoint.find_intersection",
                    "signature": "build123d.SlotCenterPoint.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.SlotCenterPoint.find_intersection_points",
                    "signature": "build123d.SlotCenterPoint.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.SlotCenterPoint.first_level_shapes",
                    "signature": "build123d.SlotCenterPoint.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.SlotCenterPoint.fix",
                    "signature": "build123d.SlotCenterPoint.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.SlotCenterPoint.fuse",
                    "signature": "build123d.SlotCenterPoint.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.get_type",
                    "signature": "build123d.SlotCenterPoint.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.SlotCenterPoint.hash_code",
                    "signature": "build123d.SlotCenterPoint.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.hollow",
                    "signature": "build123d.SlotCenterPoint.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.SlotCenterPoint.intersect",
                    "signature": "build123d.SlotCenterPoint.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.is_equal",
                    "signature": "build123d.SlotCenterPoint.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.is_inside",
                    "signature": "build123d.SlotCenterPoint.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.SlotCenterPoint.is_null",
                    "signature": "build123d.SlotCenterPoint.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.is_same",
                    "signature": "build123d.SlotCenterPoint.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.is_valid",
                    "signature": "build123d.SlotCenterPoint.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.iter_path_reverse",
                    "signature": "build123d.SlotCenterPoint.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.SlotCenterPoint.locate",
                    "signature": "build123d.SlotCenterPoint.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.located",
                    "signature": "build123d.SlotCenterPoint.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.SlotCenterPoint.make_compound",
                    "signature": "build123d.SlotCenterPoint.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.make_text",
                    "signature": "build123d.SlotCenterPoint.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.SlotCenterPoint.make_triad",
                    "signature": "build123d.SlotCenterPoint.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.SlotCenterPoint.max_fillet",
                    "signature": "build123d.SlotCenterPoint.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.SlotCenterPoint.mesh",
                    "signature": "build123d.SlotCenterPoint.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.mirror",
                    "signature": "build123d.SlotCenterPoint.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.move",
                    "signature": "build123d.SlotCenterPoint.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.moved",
                    "signature": "build123d.SlotCenterPoint.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.SlotCenterPoint.offset_3d",
                    "signature": "build123d.SlotCenterPoint.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.SlotCenterPoint.project_faces",
                    "signature": "build123d.SlotCenterPoint.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.SlotCenterPoint.project_to_viewport",
                    "signature": "build123d.SlotCenterPoint.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.SlotCenterPoint.relocate",
                    "signature": "build123d.SlotCenterPoint.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.SlotCenterPoint.rotate",
                    "signature": "build123d.SlotCenterPoint.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.SlotCenterPoint.scale",
                    "signature": "build123d.SlotCenterPoint.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.shape_type",
                    "signature": "build123d.SlotCenterPoint.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.SlotCenterPoint.shell",
                    "signature": "build123d.SlotCenterPoint.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.SlotCenterPoint.shells",
                    "signature": "build123d.SlotCenterPoint.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.show_topology",
                    "signature": "build123d.SlotCenterPoint.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.SlotCenterPoint.solid",
                    "signature": "build123d.SlotCenterPoint.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.SlotCenterPoint.solids",
                    "signature": "build123d.SlotCenterPoint.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.split",
                    "signature": "build123d.SlotCenterPoint.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.SlotCenterPoint.split_by_perimeter",
                    "signature": "build123d.SlotCenterPoint.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.SlotCenterPoint.tessellate",
                    "signature": "build123d.SlotCenterPoint.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.SlotCenterPoint.to_arcs",
                    "signature": "build123d.SlotCenterPoint.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.SlotCenterPoint.to_splines",
                    "signature": "build123d.SlotCenterPoint.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.SlotCenterPoint.to_vtk_poly_data",
                    "signature": "build123d.SlotCenterPoint.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.SlotCenterPoint.transform_geometry",
                    "signature": "build123d.SlotCenterPoint.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.SlotCenterPoint.transform_shape",
                    "signature": "build123d.SlotCenterPoint.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.SlotCenterPoint.transformed",
                    "signature": "build123d.SlotCenterPoint.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.SlotCenterPoint.translate",
                    "signature": "build123d.SlotCenterPoint.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterPoint.unwrap",
                    "signature": "build123d.SlotCenterPoint.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.vertex",
                    "signature": "build123d.SlotCenterPoint.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.SlotCenterPoint.vertices",
                    "signature": "build123d.SlotCenterPoint.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.SlotCenterPoint.wire",
                    "signature": "build123d.SlotCenterPoint.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.SlotCenterPoint.wires",
                    "signature": "build123d.SlotCenterPoint.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Center Point Slot\n\nAdd a slot(s) defined by the center of the slot and the center of one of the\ncircular arcs at the end. The other end will be generated to create a symmetric\nslot.\n\nArgs:\n    center (VectorLike): slot center point\n    point (VectorLike): slot center of arc point\n    height (float): diameter of end circles\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.SlotCenterToCenter",
            "signature": "build123d.SlotCenterToCenter(center_separation: 'float', height: 'float', rotation: 'float' = 0, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.SlotCenterToCenter.bounding_box",
                    "signature": "build123d.SlotCenterToCenter.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.cast",
                    "signature": "build123d.SlotCenterToCenter.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.SlotCenterToCenter.center",
                    "signature": "build123d.SlotCenterToCenter.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.SlotCenterToCenter.chamfer",
                    "signature": "build123d.SlotCenterToCenter.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.SlotCenterToCenter.clean",
                    "signature": "build123d.SlotCenterToCenter.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.SlotCenterToCenter.closest_points",
                    "signature": "build123d.SlotCenterToCenter.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.SlotCenterToCenter.combined_center",
                    "signature": "build123d.SlotCenterToCenter.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.SlotCenterToCenter.compound",
                    "signature": "build123d.SlotCenterToCenter.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.SlotCenterToCenter.compounds",
                    "signature": "build123d.SlotCenterToCenter.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.compute_mass",
                    "signature": "build123d.SlotCenterToCenter.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.copy",
                    "signature": "build123d.SlotCenterToCenter.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.SlotCenterToCenter.copy_attributes_to",
                    "signature": "build123d.SlotCenterToCenter.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.SlotCenterToCenter.cut",
                    "signature": "build123d.SlotCenterToCenter.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.distance",
                    "signature": "build123d.SlotCenterToCenter.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.distance_to",
                    "signature": "build123d.SlotCenterToCenter.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.SlotCenterToCenter.distance_to_with_closest_points",
                    "signature": "build123d.SlotCenterToCenter.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.distances",
                    "signature": "build123d.SlotCenterToCenter.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.do_children_intersect",
                    "signature": "build123d.SlotCenterToCenter.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.SlotCenterToCenter.dprism",
                    "signature": "build123d.SlotCenterToCenter.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.SlotCenterToCenter.edge",
                    "signature": "build123d.SlotCenterToCenter.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.SlotCenterToCenter.edges",
                    "signature": "build123d.SlotCenterToCenter.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.export_brep",
                    "signature": "build123d.SlotCenterToCenter.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.export_step",
                    "signature": "build123d.SlotCenterToCenter.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.SlotCenterToCenter.export_stl",
                    "signature": "build123d.SlotCenterToCenter.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.SlotCenterToCenter.extrude",
                    "signature": "build123d.SlotCenterToCenter.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.face",
                    "signature": "build123d.SlotCenterToCenter.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.SlotCenterToCenter.faces",
                    "signature": "build123d.SlotCenterToCenter.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.faces_intersected_by_axis",
                    "signature": "build123d.SlotCenterToCenter.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.SlotCenterToCenter.fillet",
                    "signature": "build123d.SlotCenterToCenter.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.SlotCenterToCenter.find_intersection",
                    "signature": "build123d.SlotCenterToCenter.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.SlotCenterToCenter.find_intersection_points",
                    "signature": "build123d.SlotCenterToCenter.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.SlotCenterToCenter.first_level_shapes",
                    "signature": "build123d.SlotCenterToCenter.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.SlotCenterToCenter.fix",
                    "signature": "build123d.SlotCenterToCenter.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.SlotCenterToCenter.fuse",
                    "signature": "build123d.SlotCenterToCenter.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.get_type",
                    "signature": "build123d.SlotCenterToCenter.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.SlotCenterToCenter.hash_code",
                    "signature": "build123d.SlotCenterToCenter.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.hollow",
                    "signature": "build123d.SlotCenterToCenter.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.SlotCenterToCenter.intersect",
                    "signature": "build123d.SlotCenterToCenter.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.is_equal",
                    "signature": "build123d.SlotCenterToCenter.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.is_inside",
                    "signature": "build123d.SlotCenterToCenter.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.SlotCenterToCenter.is_null",
                    "signature": "build123d.SlotCenterToCenter.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.is_same",
                    "signature": "build123d.SlotCenterToCenter.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.is_valid",
                    "signature": "build123d.SlotCenterToCenter.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.iter_path_reverse",
                    "signature": "build123d.SlotCenterToCenter.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.SlotCenterToCenter.locate",
                    "signature": "build123d.SlotCenterToCenter.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.located",
                    "signature": "build123d.SlotCenterToCenter.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.SlotCenterToCenter.make_compound",
                    "signature": "build123d.SlotCenterToCenter.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.make_text",
                    "signature": "build123d.SlotCenterToCenter.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.SlotCenterToCenter.make_triad",
                    "signature": "build123d.SlotCenterToCenter.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.SlotCenterToCenter.max_fillet",
                    "signature": "build123d.SlotCenterToCenter.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.SlotCenterToCenter.mesh",
                    "signature": "build123d.SlotCenterToCenter.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.mirror",
                    "signature": "build123d.SlotCenterToCenter.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.move",
                    "signature": "build123d.SlotCenterToCenter.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.moved",
                    "signature": "build123d.SlotCenterToCenter.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.SlotCenterToCenter.offset_3d",
                    "signature": "build123d.SlotCenterToCenter.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.SlotCenterToCenter.project_faces",
                    "signature": "build123d.SlotCenterToCenter.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.SlotCenterToCenter.project_to_viewport",
                    "signature": "build123d.SlotCenterToCenter.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.SlotCenterToCenter.relocate",
                    "signature": "build123d.SlotCenterToCenter.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.SlotCenterToCenter.rotate",
                    "signature": "build123d.SlotCenterToCenter.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.SlotCenterToCenter.scale",
                    "signature": "build123d.SlotCenterToCenter.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.shape_type",
                    "signature": "build123d.SlotCenterToCenter.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.SlotCenterToCenter.shell",
                    "signature": "build123d.SlotCenterToCenter.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.SlotCenterToCenter.shells",
                    "signature": "build123d.SlotCenterToCenter.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.show_topology",
                    "signature": "build123d.SlotCenterToCenter.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.SlotCenterToCenter.solid",
                    "signature": "build123d.SlotCenterToCenter.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.SlotCenterToCenter.solids",
                    "signature": "build123d.SlotCenterToCenter.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.split",
                    "signature": "build123d.SlotCenterToCenter.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.SlotCenterToCenter.split_by_perimeter",
                    "signature": "build123d.SlotCenterToCenter.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.SlotCenterToCenter.tessellate",
                    "signature": "build123d.SlotCenterToCenter.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.SlotCenterToCenter.to_arcs",
                    "signature": "build123d.SlotCenterToCenter.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.SlotCenterToCenter.to_splines",
                    "signature": "build123d.SlotCenterToCenter.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.SlotCenterToCenter.to_vtk_poly_data",
                    "signature": "build123d.SlotCenterToCenter.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.SlotCenterToCenter.transform_geometry",
                    "signature": "build123d.SlotCenterToCenter.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.SlotCenterToCenter.transform_shape",
                    "signature": "build123d.SlotCenterToCenter.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.SlotCenterToCenter.transformed",
                    "signature": "build123d.SlotCenterToCenter.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.SlotCenterToCenter.translate",
                    "signature": "build123d.SlotCenterToCenter.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotCenterToCenter.unwrap",
                    "signature": "build123d.SlotCenterToCenter.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.vertex",
                    "signature": "build123d.SlotCenterToCenter.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.SlotCenterToCenter.vertices",
                    "signature": "build123d.SlotCenterToCenter.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.SlotCenterToCenter.wire",
                    "signature": "build123d.SlotCenterToCenter.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.SlotCenterToCenter.wires",
                    "signature": "build123d.SlotCenterToCenter.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Center to Center points Slot\n\nAdd slot(s) defined by the distance between the center of the two\nend arcs.\n\nArgs:\n    center_separation (float): distance between two arc centers\n    height (float): diameter of end circles\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.SlotOverall",
            "signature": "build123d.SlotOverall(width: 'float', height: 'float', rotation: 'float' = 0, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.SlotOverall.bounding_box",
                    "signature": "build123d.SlotOverall.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.SlotOverall.cast",
                    "signature": "build123d.SlotOverall.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.SlotOverall.center",
                    "signature": "build123d.SlotOverall.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.SlotOverall.chamfer",
                    "signature": "build123d.SlotOverall.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.SlotOverall.clean",
                    "signature": "build123d.SlotOverall.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.SlotOverall.closest_points",
                    "signature": "build123d.SlotOverall.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.SlotOverall.combined_center",
                    "signature": "build123d.SlotOverall.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.SlotOverall.compound",
                    "signature": "build123d.SlotOverall.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.SlotOverall.compounds",
                    "signature": "build123d.SlotOverall.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.SlotOverall.compute_mass",
                    "signature": "build123d.SlotOverall.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.copy",
                    "signature": "build123d.SlotOverall.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.SlotOverall.copy_attributes_to",
                    "signature": "build123d.SlotOverall.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.SlotOverall.cut",
                    "signature": "build123d.SlotOverall.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.distance",
                    "signature": "build123d.SlotOverall.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.distance_to",
                    "signature": "build123d.SlotOverall.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.SlotOverall.distance_to_with_closest_points",
                    "signature": "build123d.SlotOverall.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.SlotOverall.distances",
                    "signature": "build123d.SlotOverall.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.do_children_intersect",
                    "signature": "build123d.SlotOverall.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.SlotOverall.dprism",
                    "signature": "build123d.SlotOverall.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.SlotOverall.edge",
                    "signature": "build123d.SlotOverall.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.SlotOverall.edges",
                    "signature": "build123d.SlotOverall.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.SlotOverall.export_brep",
                    "signature": "build123d.SlotOverall.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.export_step",
                    "signature": "build123d.SlotOverall.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.SlotOverall.export_stl",
                    "signature": "build123d.SlotOverall.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.SlotOverall.extrude",
                    "signature": "build123d.SlotOverall.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.SlotOverall.face",
                    "signature": "build123d.SlotOverall.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.SlotOverall.faces",
                    "signature": "build123d.SlotOverall.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.SlotOverall.faces_intersected_by_axis",
                    "signature": "build123d.SlotOverall.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.SlotOverall.fillet",
                    "signature": "build123d.SlotOverall.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.SlotOverall.find_intersection",
                    "signature": "build123d.SlotOverall.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.SlotOverall.find_intersection_points",
                    "signature": "build123d.SlotOverall.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.SlotOverall.first_level_shapes",
                    "signature": "build123d.SlotOverall.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.SlotOverall.fix",
                    "signature": "build123d.SlotOverall.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.SlotOverall.fuse",
                    "signature": "build123d.SlotOverall.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.get_type",
                    "signature": "build123d.SlotOverall.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.SlotOverall.hash_code",
                    "signature": "build123d.SlotOverall.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.hollow",
                    "signature": "build123d.SlotOverall.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.SlotOverall.intersect",
                    "signature": "build123d.SlotOverall.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.is_equal",
                    "signature": "build123d.SlotOverall.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.is_inside",
                    "signature": "build123d.SlotOverall.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.SlotOverall.is_null",
                    "signature": "build123d.SlotOverall.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.is_same",
                    "signature": "build123d.SlotOverall.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.is_valid",
                    "signature": "build123d.SlotOverall.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.iter_path_reverse",
                    "signature": "build123d.SlotOverall.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.SlotOverall.locate",
                    "signature": "build123d.SlotOverall.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.located",
                    "signature": "build123d.SlotOverall.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.SlotOverall.make_compound",
                    "signature": "build123d.SlotOverall.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.make_text",
                    "signature": "build123d.SlotOverall.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.SlotOverall.make_triad",
                    "signature": "build123d.SlotOverall.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.SlotOverall.max_fillet",
                    "signature": "build123d.SlotOverall.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.SlotOverall.mesh",
                    "signature": "build123d.SlotOverall.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.mirror",
                    "signature": "build123d.SlotOverall.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.SlotOverall.move",
                    "signature": "build123d.SlotOverall.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.moved",
                    "signature": "build123d.SlotOverall.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.SlotOverall.offset_3d",
                    "signature": "build123d.SlotOverall.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.SlotOverall.project_faces",
                    "signature": "build123d.SlotOverall.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.SlotOverall.project_to_viewport",
                    "signature": "build123d.SlotOverall.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.SlotOverall.relocate",
                    "signature": "build123d.SlotOverall.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.SlotOverall.rotate",
                    "signature": "build123d.SlotOverall.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.SlotOverall.scale",
                    "signature": "build123d.SlotOverall.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.shape_type",
                    "signature": "build123d.SlotOverall.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.SlotOverall.shell",
                    "signature": "build123d.SlotOverall.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.SlotOverall.shells",
                    "signature": "build123d.SlotOverall.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.SlotOverall.show_topology",
                    "signature": "build123d.SlotOverall.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.SlotOverall.solid",
                    "signature": "build123d.SlotOverall.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.SlotOverall.solids",
                    "signature": "build123d.SlotOverall.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.SlotOverall.split",
                    "signature": "build123d.SlotOverall.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.SlotOverall.split_by_perimeter",
                    "signature": "build123d.SlotOverall.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.SlotOverall.tessellate",
                    "signature": "build123d.SlotOverall.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.SlotOverall.to_arcs",
                    "signature": "build123d.SlotOverall.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.SlotOverall.to_splines",
                    "signature": "build123d.SlotOverall.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.SlotOverall.to_vtk_poly_data",
                    "signature": "build123d.SlotOverall.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.SlotOverall.transform_geometry",
                    "signature": "build123d.SlotOverall.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.SlotOverall.transform_shape",
                    "signature": "build123d.SlotOverall.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.SlotOverall.transformed",
                    "signature": "build123d.SlotOverall.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.SlotOverall.translate",
                    "signature": "build123d.SlotOverall.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.SlotOverall.unwrap",
                    "signature": "build123d.SlotOverall.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.SlotOverall.vertex",
                    "signature": "build123d.SlotOverall.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.SlotOverall.vertices",
                    "signature": "build123d.SlotOverall.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.SlotOverall.wire",
                    "signature": "build123d.SlotOverall.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.SlotOverall.wires",
                    "signature": "build123d.SlotOverall.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Center to Center points Slot\n\nAdd slot(s) defined by the overall with of the slot.\n\nArgs:\n    width (float): overall width of the slot\n    height (float): diameter of end circles\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Solid",
            "signature": "build123d.Solid(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Solid.bounding_box",
                    "signature": "build123d.Solid.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Solid.cast",
                    "signature": "build123d.Solid.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Solid.center",
                    "signature": "build123d.Solid.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Solid.chamfer",
                    "signature": "build123d.Solid.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Solid.clean",
                    "signature": "build123d.Solid.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Solid.closest_points",
                    "signature": "build123d.Solid.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Solid.combined_center",
                    "signature": "build123d.Solid.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Solid.compound",
                    "signature": "build123d.Solid.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Solid.compounds",
                    "signature": "build123d.Solid.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Solid.compute_mass",
                    "signature": "build123d.Solid.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.copy",
                    "signature": "build123d.Solid.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Solid.copy_attributes_to",
                    "signature": "build123d.Solid.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Solid.cut",
                    "signature": "build123d.Solid.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.distance",
                    "signature": "build123d.Solid.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.distance_to",
                    "signature": "build123d.Solid.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Solid.distance_to_with_closest_points",
                    "signature": "build123d.Solid.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Solid.distances",
                    "signature": "build123d.Solid.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.dprism",
                    "signature": "build123d.Solid.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Solid.edge",
                    "signature": "build123d.Solid.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Solid.edges",
                    "signature": "build123d.Solid.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Solid.export_brep",
                    "signature": "build123d.Solid.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.export_step",
                    "signature": "build123d.Solid.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Solid.export_stl",
                    "signature": "build123d.Solid.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Solid.extrude",
                    "signature": "build123d.Solid.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Solid.extrude_linear_with_rotation",
                    "signature": "build123d.Solid.extrude_linear_with_rotation(section: 'Union[Face, Wire]', center: 'VectorLike', normal: 'VectorLike', angle: 'float', inner_wires: 'list[Wire]' = None) -> 'Solid'",
                    "docstring": "Extrude with Rotation\n\nCreates a 'twisted prism' by extruding, while simultaneously rotating around the\nextrusion vector.\n\nArgs:\n    section (Union[Face,Wire]): cross section\n    vec_center (VectorLike): the center point about which to rotate\n    vec_normal (VectorLike): a vector along which to extrude the wires\n    angle (float): the angle to rotate through while extruding\n    inner_wires (list[Wire], optional): holes - only used if section is of type Wire.\n        Defaults to None.\n\nReturns:\n    Solid: extruded object"
                },
                {
                    "name": "build123d.Solid.extrude_taper",
                    "signature": "build123d.Solid.extrude_taper(profile: 'Face', direction: 'VectorLike', taper: 'float', flip_inner: 'bool' = True) -> 'Solid'",
                    "docstring": "Extrude a cross section with a taper\n\nExtrude a cross section into a prismatic solid in the provided direction.\n\nNote that two difference algorithms are used. If direction aligns with\nthe profile normal (which must be positive), the taper is positive and the profile\ncontains no holes the OCP LocOpe_DPrism algorithm is used as it generates the most\naccurate results. Otherwise, a loft is created between the profile and the profile\nwith a 2D offset set at the appropriate direction.\n\nArgs:\n    section (Face]): cross section\n    normal (VectorLike): a vector along which to extrude the wires. The length\n        of the vector controls the length of the extrusion.\n    taper (float): taper angle in degrees.\n    flip_inner (bool, optional): outer and inner geometry have opposite tapers to\n        allow for part extraction when injection molding.\n\nReturns:\n    Solid: extruded cross section"
                },
                {
                    "name": "build123d.Solid.extrude_until",
                    "signature": "build123d.Solid.extrude_until(section: 'Face', target_object: 'Union[Compound, Solid]', direction: 'VectorLike', until: 'Until' = <Until.NEXT>) -> 'Union[Compound, Solid]'",
                    "docstring": "extrude_until\n\nExtrude section in provided direction until it encounters either the\nNEXT or LAST surface of target_object. Note that the bounding surface\nmust be larger than the extruded face where they contact.\n\nArgs:\n    section (Face): Face to extrude\n    target_object (Union[Compound, Solid]): object to limit extrusion\n    direction (VectorLike): extrusion direction\n    until (Until, optional): surface to limit extrusion. Defaults to Until.NEXT.\n\nRaises:\n    ValueError: provided face does not intersect target_object\n\nReturns:\n    Union[Compound, Solid]: extruded Face"
                },
                {
                    "name": "build123d.Solid.face",
                    "signature": "build123d.Solid.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Solid.faces",
                    "signature": "build123d.Solid.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Solid.faces_intersected_by_axis",
                    "signature": "build123d.Solid.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Solid.fillet",
                    "signature": "build123d.Solid.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Solid.find_intersection",
                    "signature": "build123d.Solid.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Solid.find_intersection_points",
                    "signature": "build123d.Solid.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Solid.fix",
                    "signature": "build123d.Solid.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Solid.from_bounding_box",
                    "signature": "build123d.Solid.from_bounding_box(bbox: 'BoundBox') -> 'Solid'",
                    "docstring": "A box of the same dimensions and location"
                },
                {
                    "name": "build123d.Solid.fuse",
                    "signature": "build123d.Solid.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Solid.hash_code",
                    "signature": "build123d.Solid.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.hollow",
                    "signature": "build123d.Solid.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Solid.intersect",
                    "signature": "build123d.Solid.intersect(self, *to_intersect: 'Union[Shape, Axis, Plane]') -> 'Shape'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Solid.is_equal",
                    "signature": "build123d.Solid.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.is_inside",
                    "signature": "build123d.Solid.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Solid.is_null",
                    "signature": "build123d.Solid.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.is_same",
                    "signature": "build123d.Solid.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.is_valid",
                    "signature": "build123d.Solid.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.iter_path_reverse",
                    "signature": "build123d.Solid.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Solid.locate",
                    "signature": "build123d.Solid.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.located",
                    "signature": "build123d.Solid.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Solid.make_box",
                    "signature": "build123d.Solid.make_box(length: 'float', width: 'float', height: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Solid'",
                    "docstring": "make box\n\nMake a box at the origin of plane extending in positive direction of each axis.\n\nArgs:\n    length (float):\n    width (float):\n    height (float):\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n\nReturns:\n    Solid: Box"
                },
                {
                    "name": "build123d.Solid.make_cone",
                    "signature": "build123d.Solid.make_cone(base_radius: 'float', top_radius: 'float', height: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), angle: 'float' = 360) -> 'Solid'",
                    "docstring": "make cone\n\nMake a cone with given radii and height\n\nArgs:\n    base_radius (float):\n    top_radius (float):\n    height (float):\n    plane (Plane): base plane. Defaults to Plane.XY.\n    angle (float, optional): arc size. Defaults to 360.\n\nReturns:\n    Solid: Full or partial cone"
                },
                {
                    "name": "build123d.Solid.make_cylinder",
                    "signature": "build123d.Solid.make_cylinder(radius: 'float', height: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), angle: 'float' = 360) -> 'Solid'",
                    "docstring": "make cylinder\n\nMake a cylinder with a given radius and height with the base center on plane origin.\n\nArgs:\n    radius (float):\n    height (float):\n    plane (Plane): base plane. Defaults to Plane.XY.\n    angle (float, optional): arc size. Defaults to 360.\n\nReturns:\n    Solid: Full or partial cylinder"
                },
                {
                    "name": "build123d.Solid.make_loft",
                    "signature": "build123d.Solid.make_loft(objs: 'Iterable[Union[Vertex, Wire]]', ruled: 'bool' = False) -> 'Solid'",
                    "docstring": "make loft\n\nMakes a loft from a list of wires and vertices.\nVertices can appear only at the beginning or end of the list, but cannot appear consecutively within the list\nnor between wires.\n\nArgs:\n    objs (list[Vertex, Wire]): wire perimeters or vertices\n    ruled (bool, optional): stepped or smooth. Defaults to False (smooth).\n\nRaises:\n    ValueError: Too few wires\n\nReturns:\n    Solid: Lofted object"
                },
                {
                    "name": "build123d.Solid.make_solid",
                    "signature": "build123d.Solid.make_solid(shell: 'Shell') -> 'Solid'",
                    "docstring": "Create a Solid object from the surface shell"
                },
                {
                    "name": "build123d.Solid.make_sphere",
                    "signature": "build123d.Solid.make_sphere(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), angle1: 'float' = -90, angle2: 'float' = 90, angle3: 'float' = 360) -> 'Solid'",
                    "docstring": "Sphere\n\nMake a full or partial sphere - with a given radius center on the origin or plane.\n\nArgs:\n    radius (float):\n    plane (Plane): base plane. Defaults to Plane.XY.\n    angle1 (float, optional): Defaults to -90.\n    angle2 (float, optional): Defaults to 90.\n    angle3 (float, optional): Defaults to 360.\n\nReturns:\n    Solid: sphere"
                },
                {
                    "name": "build123d.Solid.make_torus",
                    "signature": "build123d.Solid.make_torus(major_radius: 'float', minor_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 0, end_angle: 'float' = 360, major_angle: 'float' = 360) -> 'Solid'",
                    "docstring": "make torus\n\nMake a torus with a given radii and angles\n\nArgs:\n    major_radius (float):\n    minor_radius (float):\n    plane (Plane): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start major arc. Defaults to 0.\n    end_angle (float, optional): end major arc. Defaults to 360.\n\nReturns:\n    Solid: Full or partial torus"
                },
                {
                    "name": "build123d.Solid.make_wedge",
                    "signature": "build123d.Solid.make_wedge(delta_x: 'float', delta_y: 'float', delta_z: 'float', min_x: 'float', min_z: 'float', max_x: 'float', max_z: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Solid'",
                    "docstring": "Make a wedge\n\nArgs:\n    delta_x (float):\n    delta_y (float):\n    delta_z (float):\n    min_x (float):\n    min_z (float):\n    max_x (float):\n    max_z (float):\n    plane (Plane): base plane. Defaults to Plane.XY.\n\nReturns:\n    Solid: wedge"
                },
                {
                    "name": "build123d.Solid.max_fillet",
                    "signature": "build123d.Solid.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Solid.mesh",
                    "signature": "build123d.Solid.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.mirror",
                    "signature": "build123d.Solid.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Solid.move",
                    "signature": "build123d.Solid.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.moved",
                    "signature": "build123d.Solid.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Solid.offset_3d",
                    "signature": "build123d.Solid.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Solid.project_faces",
                    "signature": "build123d.Solid.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Solid.project_to_viewport",
                    "signature": "build123d.Solid.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Solid.relocate",
                    "signature": "build123d.Solid.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Solid.revolve",
                    "signature": "build123d.Solid.revolve(section: 'Union[Face, Wire]', angle: 'float', axis: 'Axis', inner_wires: 'list[Wire]' = None) -> 'Solid'",
                    "docstring": "Revolve\n\nRevolve a cross section about the given Axis by the given angle.\n\nArgs:\n    section (Union[Face,Wire]): cross section\n    angle (float): the angle to revolve through\n    axis (Axis): rotation Axis\n    inner_wires (list[Wire], optional): holes - only used if section is of type Wire.\n        Defaults to [].\n\nReturns:\n    Solid: the revolved cross section"
                },
                {
                    "name": "build123d.Solid.rotate",
                    "signature": "build123d.Solid.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Solid.scale",
                    "signature": "build123d.Solid.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.shape_type",
                    "signature": "build123d.Solid.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Solid.shell",
                    "signature": "build123d.Solid.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Solid.shells",
                    "signature": "build123d.Solid.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Solid.show_topology",
                    "signature": "build123d.Solid.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Solid.solid",
                    "signature": "build123d.Solid.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Solid.solids",
                    "signature": "build123d.Solid.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Solid.split",
                    "signature": "build123d.Solid.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Solid.split_by_perimeter",
                    "signature": "build123d.Solid.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Solid.sweep",
                    "signature": "build123d.Solid.sweep(section: 'Union[Face, Wire]', path: 'Union[Wire, Edge]', inner_wires: 'list[Wire]' = None, make_solid: 'bool' = True, is_frenet: 'bool' = False, mode: 'Union[Vector, Wire, Edge, None]' = None, transition: 'Transition' = <Transition.TRANSFORMED>) -> 'Solid'",
                    "docstring": "Sweep\n\nSweep the given cross section into a prismatic solid along the provided path\n\nArgs:\n    section (Union[Face, Wire]): cross section to sweep\n    path (Union[Wire, Edge]): sweep path\n    inner_wires (list[Wire]): holes - only used if section is a wire\n    make_solid (bool, optional): return Solid or Shell. Defaults to True.\n    is_frenet (bool, optional): Frenet mode. Defaults to False.\n    mode (Union[Vector, Wire, Edge, None], optional): additional sweep\n        mode parameters. Defaults to None.\n    transition (Transition, optional): handling of profile orientation at C1 path\n        discontinuities. Defaults to Transition.TRANSFORMED.\n\nReturns:\n    Solid: the swept cross section"
                },
                {
                    "name": "build123d.Solid.sweep_multi",
                    "signature": "build123d.Solid.sweep_multi(profiles: 'Iterable[Union[Wire, Face]]', path: 'Union[Wire, Edge]', make_solid: 'bool' = True, is_frenet: 'bool' = False, mode: 'Union[Vector, Wire, Edge, None]' = None) -> 'Solid'",
                    "docstring": "Multi section sweep\n\nSweep through a sequence of profiles following a path.\n\nArgs:\n    profiles (Iterable[Union[Wire, Face]]): list of profiles\n    path (Union[Wire, Edge]): The wire to sweep the face resulting from the wires over\n    make_solid (bool, optional): Solid or Shell. Defaults to True.\n    is_frenet (bool, optional): Select frenet mode. Defaults to False.\n    mode (Union[Vector, Wire, Edge, None], optional): additional sweep mode parameters.\n        Defaults to None.\n\nReturns:\n    Solid: swept object"
                },
                {
                    "name": "build123d.Solid.tessellate",
                    "signature": "build123d.Solid.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Solid.to_arcs",
                    "signature": "build123d.Solid.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Solid.to_splines",
                    "signature": "build123d.Solid.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Solid.to_vtk_poly_data",
                    "signature": "build123d.Solid.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Solid.transform_geometry",
                    "signature": "build123d.Solid.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Solid.transform_shape",
                    "signature": "build123d.Solid.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Solid.transformed",
                    "signature": "build123d.Solid.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Solid.translate",
                    "signature": "build123d.Solid.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Solid.vertex",
                    "signature": "build123d.Solid.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Solid.vertices",
                    "signature": "build123d.Solid.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Solid.wire",
                    "signature": "build123d.Solid.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Solid.wires",
                    "signature": "build123d.Solid.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "A Solid in build123d represents a three-dimensional solid geometry\nin a topological structure. A solid is a closed and bounded volume, enclosing\na region in 3D space. It comprises faces, edges, and vertices connected in a\nwell-defined manner. Solid modeling operations, such as Boolean\noperations (union, intersection, and difference), are often performed on\nSolid objects to create or modify complex geometries."
        },
        {
            "name": "build123d.SortBy",
            "signature": "build123d.SortBy()",
            "methods": [],
            "variables": [
                "AREA",
                "DISTANCE",
                "LENGTH",
                "RADIUS",
                "VOLUME",
                "name",
                "value"
            ],
            "docstring": "Sorting criteria"
        },
        {
            "name": "build123d.Sphere",
            "signature": "build123d.Sphere(radius: 'float', arc_size1: 'float' = -90, arc_size2: 'float' = 90, arc_size3: 'float' = 360, rotation: 'RotationLike' = (0, 0, 0), align: 'Union[Align, tuple[Align, Align, Align]]' = (<Align.CENTER>, <Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Sphere.bounding_box",
                    "signature": "build123d.Sphere.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Sphere.cast",
                    "signature": "build123d.Sphere.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Sphere.center",
                    "signature": "build123d.Sphere.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Sphere.chamfer",
                    "signature": "build123d.Sphere.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Sphere.clean",
                    "signature": "build123d.Sphere.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Sphere.closest_points",
                    "signature": "build123d.Sphere.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Sphere.combined_center",
                    "signature": "build123d.Sphere.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Sphere.compound",
                    "signature": "build123d.Sphere.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Sphere.compounds",
                    "signature": "build123d.Sphere.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Sphere.compute_mass",
                    "signature": "build123d.Sphere.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.copy",
                    "signature": "build123d.Sphere.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Sphere.copy_attributes_to",
                    "signature": "build123d.Sphere.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Sphere.cut",
                    "signature": "build123d.Sphere.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.distance",
                    "signature": "build123d.Sphere.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.distance_to",
                    "signature": "build123d.Sphere.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Sphere.distance_to_with_closest_points",
                    "signature": "build123d.Sphere.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Sphere.distances",
                    "signature": "build123d.Sphere.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.do_children_intersect",
                    "signature": "build123d.Sphere.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Sphere.dprism",
                    "signature": "build123d.Sphere.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Sphere.edge",
                    "signature": "build123d.Sphere.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Sphere.edges",
                    "signature": "build123d.Sphere.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Sphere.export_brep",
                    "signature": "build123d.Sphere.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.export_step",
                    "signature": "build123d.Sphere.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Sphere.export_stl",
                    "signature": "build123d.Sphere.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Sphere.extrude",
                    "signature": "build123d.Sphere.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Sphere.face",
                    "signature": "build123d.Sphere.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Sphere.faces",
                    "signature": "build123d.Sphere.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Sphere.faces_intersected_by_axis",
                    "signature": "build123d.Sphere.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Sphere.fillet",
                    "signature": "build123d.Sphere.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Sphere.find_intersection",
                    "signature": "build123d.Sphere.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Sphere.find_intersection_points",
                    "signature": "build123d.Sphere.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Sphere.first_level_shapes",
                    "signature": "build123d.Sphere.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Sphere.fix",
                    "signature": "build123d.Sphere.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Sphere.fuse",
                    "signature": "build123d.Sphere.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.get_type",
                    "signature": "build123d.Sphere.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Sphere.hash_code",
                    "signature": "build123d.Sphere.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.hollow",
                    "signature": "build123d.Sphere.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Sphere.intersect",
                    "signature": "build123d.Sphere.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.is_equal",
                    "signature": "build123d.Sphere.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.is_inside",
                    "signature": "build123d.Sphere.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Sphere.is_null",
                    "signature": "build123d.Sphere.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.is_same",
                    "signature": "build123d.Sphere.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.is_valid",
                    "signature": "build123d.Sphere.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.iter_path_reverse",
                    "signature": "build123d.Sphere.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Sphere.locate",
                    "signature": "build123d.Sphere.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.located",
                    "signature": "build123d.Sphere.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Sphere.make_compound",
                    "signature": "build123d.Sphere.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Sphere.make_text",
                    "signature": "build123d.Sphere.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Sphere.make_triad",
                    "signature": "build123d.Sphere.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Sphere.max_fillet",
                    "signature": "build123d.Sphere.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Sphere.mesh",
                    "signature": "build123d.Sphere.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.mirror",
                    "signature": "build123d.Sphere.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Sphere.move",
                    "signature": "build123d.Sphere.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.moved",
                    "signature": "build123d.Sphere.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Sphere.offset_3d",
                    "signature": "build123d.Sphere.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Sphere.project_faces",
                    "signature": "build123d.Sphere.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Sphere.project_to_viewport",
                    "signature": "build123d.Sphere.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Sphere.relocate",
                    "signature": "build123d.Sphere.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Sphere.rotate",
                    "signature": "build123d.Sphere.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Sphere.scale",
                    "signature": "build123d.Sphere.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.shape_type",
                    "signature": "build123d.Sphere.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Sphere.shell",
                    "signature": "build123d.Sphere.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Sphere.shells",
                    "signature": "build123d.Sphere.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Sphere.show_topology",
                    "signature": "build123d.Sphere.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Sphere.solid",
                    "signature": "build123d.Sphere.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Sphere.solids",
                    "signature": "build123d.Sphere.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Sphere.split",
                    "signature": "build123d.Sphere.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Sphere.split_by_perimeter",
                    "signature": "build123d.Sphere.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Sphere.tessellate",
                    "signature": "build123d.Sphere.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Sphere.to_arcs",
                    "signature": "build123d.Sphere.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Sphere.to_splines",
                    "signature": "build123d.Sphere.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Sphere.to_vtk_poly_data",
                    "signature": "build123d.Sphere.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Sphere.transform_geometry",
                    "signature": "build123d.Sphere.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Sphere.transform_shape",
                    "signature": "build123d.Sphere.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Sphere.transformed",
                    "signature": "build123d.Sphere.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Sphere.translate",
                    "signature": "build123d.Sphere.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Sphere.unwrap",
                    "signature": "build123d.Sphere.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Sphere.vertex",
                    "signature": "build123d.Sphere.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Sphere.vertices",
                    "signature": "build123d.Sphere.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Sphere.wire",
                    "signature": "build123d.Sphere.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Sphere.wires",
                    "signature": "build123d.Sphere.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Part Object: Sphere\n\nCreate a sphere(s) and combine with part.\n\nArgs:\n    radius (float): sphere size\n    arc_size1 (float, optional): angular size of sphere. Defaults to -90.\n    arc_size2 (float, optional): angular size of sphere. Defaults to 90.\n    arc_size3 (float, optional): angular size of sphere. Defaults to 360.\n    rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).\n    align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,\n        or max of object. Defaults to (Align.CENTER, Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combine mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Spline",
            "signature": "build123d.Spline(*pts: 'Union[VectorLike, Iterable[VectorLike]]', tangents: 'Iterable[VectorLike]' = None, tangent_scalars: 'Iterable[float]' = None, periodic: 'bool' = False, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Spline.bounding_box",
                    "signature": "build123d.Spline.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Spline.cast",
                    "signature": "build123d.Spline.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Spline.center",
                    "signature": "build123d.Spline.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Spline.clean",
                    "signature": "build123d.Spline.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Spline.close",
                    "signature": "build123d.Spline.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.Spline.closest_points",
                    "signature": "build123d.Spline.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Spline.combined_center",
                    "signature": "build123d.Spline.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Spline.common_plane",
                    "signature": "build123d.Spline.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.Spline.compound",
                    "signature": "build123d.Spline.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Spline.compounds",
                    "signature": "build123d.Spline.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Spline.compute_mass",
                    "signature": "build123d.Spline.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.copy",
                    "signature": "build123d.Spline.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Spline.copy_attributes_to",
                    "signature": "build123d.Spline.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Spline.cut",
                    "signature": "build123d.Spline.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.distance",
                    "signature": "build123d.Spline.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.distance_to",
                    "signature": "build123d.Spline.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Spline.distance_to_with_closest_points",
                    "signature": "build123d.Spline.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Spline.distances",
                    "signature": "build123d.Spline.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.distribute_locations",
                    "signature": "build123d.Spline.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.Spline.edge",
                    "signature": "build123d.Spline.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Spline.edges",
                    "signature": "build123d.Spline.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Spline.end_point",
                    "signature": "build123d.Spline.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Spline.export_brep",
                    "signature": "build123d.Spline.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.export_step",
                    "signature": "build123d.Spline.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Spline.export_stl",
                    "signature": "build123d.Spline.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Spline.extrude",
                    "signature": "build123d.Spline.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Spline.face",
                    "signature": "build123d.Spline.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Spline.faces",
                    "signature": "build123d.Spline.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Spline.faces_intersected_by_axis",
                    "signature": "build123d.Spline.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Spline.find_intersection",
                    "signature": "build123d.Spline.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Spline.find_intersection_points",
                    "signature": "build123d.Spline.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.Spline.find_tangent",
                    "signature": "build123d.Spline.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.Spline.fix",
                    "signature": "build123d.Spline.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Spline.fuse",
                    "signature": "build123d.Spline.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Spline.hash_code",
                    "signature": "build123d.Spline.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.intersect",
                    "signature": "build123d.Spline.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Spline.is_equal",
                    "signature": "build123d.Spline.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.is_null",
                    "signature": "build123d.Spline.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.is_same",
                    "signature": "build123d.Spline.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.is_valid",
                    "signature": "build123d.Spline.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.iter_path_reverse",
                    "signature": "build123d.Spline.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Spline.locate",
                    "signature": "build123d.Spline.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.located",
                    "signature": "build123d.Spline.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Spline.location_at",
                    "signature": "build123d.Spline.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.Spline.locations",
                    "signature": "build123d.Spline.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.Spline.make_bezier",
                    "signature": "build123d.Spline.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.Spline.make_circle",
                    "signature": "build123d.Spline.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.Spline.make_ellipse",
                    "signature": "build123d.Spline.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.Spline.make_helix",
                    "signature": "build123d.Spline.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.Spline.make_line",
                    "signature": "build123d.Spline.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.Spline.make_mid_way",
                    "signature": "build123d.Spline.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.Spline.make_spline",
                    "signature": "build123d.Spline.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.Spline.make_spline_approx",
                    "signature": "build123d.Spline.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.Spline.make_tangent_arc",
                    "signature": "build123d.Spline.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.Spline.make_three_point_arc",
                    "signature": "build123d.Spline.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.Spline.mesh",
                    "signature": "build123d.Spline.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.mirror",
                    "signature": "build123d.Spline.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Spline.move",
                    "signature": "build123d.Spline.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.moved",
                    "signature": "build123d.Spline.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Spline.normal",
                    "signature": "build123d.Spline.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.offset_2d",
                    "signature": "build123d.Spline.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.Spline.param_at",
                    "signature": "build123d.Spline.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.Spline.param_at_point",
                    "signature": "build123d.Spline.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.Spline.perpendicular_line",
                    "signature": "build123d.Spline.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.Spline.position_at",
                    "signature": "build123d.Spline.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.Spline.positions",
                    "signature": "build123d.Spline.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.Spline.project",
                    "signature": "build123d.Spline.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.project_faces",
                    "signature": "build123d.Spline.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Spline.project_to_shape",
                    "signature": "build123d.Spline.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.Spline.project_to_viewport",
                    "signature": "build123d.Spline.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Spline.relocate",
                    "signature": "build123d.Spline.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Spline.reversed",
                    "signature": "build123d.Spline.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.Spline.rotate",
                    "signature": "build123d.Spline.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Spline.scale",
                    "signature": "build123d.Spline.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.shape_type",
                    "signature": "build123d.Spline.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Spline.shell",
                    "signature": "build123d.Spline.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Spline.shells",
                    "signature": "build123d.Spline.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Spline.show_topology",
                    "signature": "build123d.Spline.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Spline.solid",
                    "signature": "build123d.Spline.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Spline.solids",
                    "signature": "build123d.Spline.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Spline.split",
                    "signature": "build123d.Spline.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Spline.split_by_perimeter",
                    "signature": "build123d.Spline.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Spline.start_point",
                    "signature": "build123d.Spline.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Spline.tangent_angle_at",
                    "signature": "build123d.Spline.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.Spline.tangent_at",
                    "signature": "build123d.Spline.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.Spline.tessellate",
                    "signature": "build123d.Spline.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Spline.to_arcs",
                    "signature": "build123d.Spline.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Spline.to_axis",
                    "signature": "build123d.Spline.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.Spline.to_splines",
                    "signature": "build123d.Spline.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Spline.to_vtk_poly_data",
                    "signature": "build123d.Spline.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Spline.to_wire",
                    "signature": "build123d.Spline.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.Spline.transform_geometry",
                    "signature": "build123d.Spline.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Spline.transform_shape",
                    "signature": "build123d.Spline.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Spline.transformed",
                    "signature": "build123d.Spline.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Spline.translate",
                    "signature": "build123d.Spline.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Spline.trim",
                    "signature": "build123d.Spline.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.Spline.trim_to_length",
                    "signature": "build123d.Spline.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.Spline.vertex",
                    "signature": "build123d.Spline.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Spline.vertices",
                    "signature": "build123d.Spline.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Spline.wire",
                    "signature": "build123d.Spline.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Spline.wires",
                    "signature": "build123d.Spline.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Spline\n\nAdd a spline through the provided points optionally constrained by tangents.\n\nArgs:\n    pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two or more points\n    tangents (Iterable[VectorLike], optional): tangents at end points. Defaults to None.\n    tangent_scalars (Iterable[float], optional): change shape by amplifying tangent.\n        Defaults to None.\n    periodic (bool, optional): make the spline periodic. Defaults to False.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.TangentArc",
            "signature": "build123d.TangentArc(*pts: 'Union[VectorLike, Iterable[VectorLike]]', tangent: 'VectorLike', tangent_from_first: 'bool' = True, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.TangentArc.bounding_box",
                    "signature": "build123d.TangentArc.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.TangentArc.cast",
                    "signature": "build123d.TangentArc.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.TangentArc.center",
                    "signature": "build123d.TangentArc.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.TangentArc.clean",
                    "signature": "build123d.TangentArc.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.TangentArc.close",
                    "signature": "build123d.TangentArc.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.TangentArc.closest_points",
                    "signature": "build123d.TangentArc.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.TangentArc.combined_center",
                    "signature": "build123d.TangentArc.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.TangentArc.common_plane",
                    "signature": "build123d.TangentArc.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.TangentArc.compound",
                    "signature": "build123d.TangentArc.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.TangentArc.compounds",
                    "signature": "build123d.TangentArc.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.TangentArc.compute_mass",
                    "signature": "build123d.TangentArc.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.copy",
                    "signature": "build123d.TangentArc.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.TangentArc.copy_attributes_to",
                    "signature": "build123d.TangentArc.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.TangentArc.cut",
                    "signature": "build123d.TangentArc.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.distance",
                    "signature": "build123d.TangentArc.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.distance_to",
                    "signature": "build123d.TangentArc.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.TangentArc.distance_to_with_closest_points",
                    "signature": "build123d.TangentArc.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.TangentArc.distances",
                    "signature": "build123d.TangentArc.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.distribute_locations",
                    "signature": "build123d.TangentArc.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.TangentArc.edge",
                    "signature": "build123d.TangentArc.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.TangentArc.edges",
                    "signature": "build123d.TangentArc.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.TangentArc.end_point",
                    "signature": "build123d.TangentArc.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.TangentArc.export_brep",
                    "signature": "build123d.TangentArc.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.export_step",
                    "signature": "build123d.TangentArc.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.TangentArc.export_stl",
                    "signature": "build123d.TangentArc.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.TangentArc.extrude",
                    "signature": "build123d.TangentArc.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.TangentArc.face",
                    "signature": "build123d.TangentArc.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.TangentArc.faces",
                    "signature": "build123d.TangentArc.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.TangentArc.faces_intersected_by_axis",
                    "signature": "build123d.TangentArc.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.TangentArc.find_intersection",
                    "signature": "build123d.TangentArc.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.TangentArc.find_intersection_points",
                    "signature": "build123d.TangentArc.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.TangentArc.find_tangent",
                    "signature": "build123d.TangentArc.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.TangentArc.fix",
                    "signature": "build123d.TangentArc.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.TangentArc.fuse",
                    "signature": "build123d.TangentArc.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.TangentArc.hash_code",
                    "signature": "build123d.TangentArc.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.intersect",
                    "signature": "build123d.TangentArc.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.TangentArc.is_equal",
                    "signature": "build123d.TangentArc.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.is_null",
                    "signature": "build123d.TangentArc.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.is_same",
                    "signature": "build123d.TangentArc.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.is_valid",
                    "signature": "build123d.TangentArc.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.iter_path_reverse",
                    "signature": "build123d.TangentArc.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.TangentArc.locate",
                    "signature": "build123d.TangentArc.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.located",
                    "signature": "build123d.TangentArc.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.TangentArc.location_at",
                    "signature": "build123d.TangentArc.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.TangentArc.locations",
                    "signature": "build123d.TangentArc.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.TangentArc.make_bezier",
                    "signature": "build123d.TangentArc.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.TangentArc.make_circle",
                    "signature": "build123d.TangentArc.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.TangentArc.make_ellipse",
                    "signature": "build123d.TangentArc.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.TangentArc.make_helix",
                    "signature": "build123d.TangentArc.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.TangentArc.make_line",
                    "signature": "build123d.TangentArc.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.TangentArc.make_mid_way",
                    "signature": "build123d.TangentArc.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.TangentArc.make_spline",
                    "signature": "build123d.TangentArc.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.TangentArc.make_spline_approx",
                    "signature": "build123d.TangentArc.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.TangentArc.make_tangent_arc",
                    "signature": "build123d.TangentArc.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.TangentArc.make_three_point_arc",
                    "signature": "build123d.TangentArc.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.TangentArc.mesh",
                    "signature": "build123d.TangentArc.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.mirror",
                    "signature": "build123d.TangentArc.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.TangentArc.move",
                    "signature": "build123d.TangentArc.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.moved",
                    "signature": "build123d.TangentArc.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.TangentArc.normal",
                    "signature": "build123d.TangentArc.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.offset_2d",
                    "signature": "build123d.TangentArc.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.TangentArc.param_at",
                    "signature": "build123d.TangentArc.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.TangentArc.param_at_point",
                    "signature": "build123d.TangentArc.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.TangentArc.perpendicular_line",
                    "signature": "build123d.TangentArc.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.TangentArc.position_at",
                    "signature": "build123d.TangentArc.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.TangentArc.positions",
                    "signature": "build123d.TangentArc.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.TangentArc.project",
                    "signature": "build123d.TangentArc.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.project_faces",
                    "signature": "build123d.TangentArc.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.TangentArc.project_to_shape",
                    "signature": "build123d.TangentArc.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.TangentArc.project_to_viewport",
                    "signature": "build123d.TangentArc.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.TangentArc.relocate",
                    "signature": "build123d.TangentArc.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.TangentArc.reversed",
                    "signature": "build123d.TangentArc.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.TangentArc.rotate",
                    "signature": "build123d.TangentArc.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.TangentArc.scale",
                    "signature": "build123d.TangentArc.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.shape_type",
                    "signature": "build123d.TangentArc.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.TangentArc.shell",
                    "signature": "build123d.TangentArc.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.TangentArc.shells",
                    "signature": "build123d.TangentArc.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.TangentArc.show_topology",
                    "signature": "build123d.TangentArc.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.TangentArc.solid",
                    "signature": "build123d.TangentArc.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.TangentArc.solids",
                    "signature": "build123d.TangentArc.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.TangentArc.split",
                    "signature": "build123d.TangentArc.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.TangentArc.split_by_perimeter",
                    "signature": "build123d.TangentArc.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.TangentArc.start_point",
                    "signature": "build123d.TangentArc.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.TangentArc.tangent_angle_at",
                    "signature": "build123d.TangentArc.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.TangentArc.tangent_at",
                    "signature": "build123d.TangentArc.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.TangentArc.tessellate",
                    "signature": "build123d.TangentArc.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.TangentArc.to_arcs",
                    "signature": "build123d.TangentArc.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.TangentArc.to_axis",
                    "signature": "build123d.TangentArc.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.TangentArc.to_splines",
                    "signature": "build123d.TangentArc.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.TangentArc.to_vtk_poly_data",
                    "signature": "build123d.TangentArc.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.TangentArc.to_wire",
                    "signature": "build123d.TangentArc.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.TangentArc.transform_geometry",
                    "signature": "build123d.TangentArc.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.TangentArc.transform_shape",
                    "signature": "build123d.TangentArc.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.TangentArc.transformed",
                    "signature": "build123d.TangentArc.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.TangentArc.translate",
                    "signature": "build123d.TangentArc.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.TangentArc.trim",
                    "signature": "build123d.TangentArc.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.TangentArc.trim_to_length",
                    "signature": "build123d.TangentArc.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.TangentArc.vertex",
                    "signature": "build123d.TangentArc.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.TangentArc.vertices",
                    "signature": "build123d.TangentArc.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.TangentArc.wire",
                    "signature": "build123d.TangentArc.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.TangentArc.wires",
                    "signature": "build123d.TangentArc.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Tangent Arc\n\nAdd an arc defined by two points and a tangent.\n\nArgs:\n    pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two points\n    tangent (VectorLike): tangent to constrain arc\n    tangent_from_first (bool, optional): apply tangent to first point. Note, applying\n        tangent to end point will flip the orientation of the arc. Defaults to True.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: Two points are required"
        },
        {
            "name": "build123d.TechnicalDrawing",
            "signature": "build123d.TechnicalDrawing(designed_by: str = 'build123d', design_date: Optional[datetime.date] = None, page_size: build123d.build_enums.PageSize = <PageSize.A4>, title: str = 'Title', sub_title: str = 'Sub Title', drawing_number: str = 'B3D-1', sheet_number: int = None, drawing_scale: float = 1.0, nominal_text_size: float = 10.0, line_width: float = 0.5, mode: build123d.build_enums.Mode = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.TechnicalDrawing.bounding_box",
                    "signature": "build123d.TechnicalDrawing.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.cast",
                    "signature": "build123d.TechnicalDrawing.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.TechnicalDrawing.center",
                    "signature": "build123d.TechnicalDrawing.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.TechnicalDrawing.chamfer",
                    "signature": "build123d.TechnicalDrawing.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.TechnicalDrawing.clean",
                    "signature": "build123d.TechnicalDrawing.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.TechnicalDrawing.closest_points",
                    "signature": "build123d.TechnicalDrawing.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.TechnicalDrawing.combined_center",
                    "signature": "build123d.TechnicalDrawing.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.TechnicalDrawing.compound",
                    "signature": "build123d.TechnicalDrawing.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.TechnicalDrawing.compounds",
                    "signature": "build123d.TechnicalDrawing.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.compute_mass",
                    "signature": "build123d.TechnicalDrawing.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.copy",
                    "signature": "build123d.TechnicalDrawing.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.TechnicalDrawing.copy_attributes_to",
                    "signature": "build123d.TechnicalDrawing.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.TechnicalDrawing.cut",
                    "signature": "build123d.TechnicalDrawing.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.distance",
                    "signature": "build123d.TechnicalDrawing.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.distance_to",
                    "signature": "build123d.TechnicalDrawing.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.TechnicalDrawing.distance_to_with_closest_points",
                    "signature": "build123d.TechnicalDrawing.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.distances",
                    "signature": "build123d.TechnicalDrawing.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.do_children_intersect",
                    "signature": "build123d.TechnicalDrawing.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.TechnicalDrawing.dprism",
                    "signature": "build123d.TechnicalDrawing.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.TechnicalDrawing.edge",
                    "signature": "build123d.TechnicalDrawing.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.TechnicalDrawing.edges",
                    "signature": "build123d.TechnicalDrawing.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.export_brep",
                    "signature": "build123d.TechnicalDrawing.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.export_step",
                    "signature": "build123d.TechnicalDrawing.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.TechnicalDrawing.export_stl",
                    "signature": "build123d.TechnicalDrawing.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.TechnicalDrawing.extrude",
                    "signature": "build123d.TechnicalDrawing.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.face",
                    "signature": "build123d.TechnicalDrawing.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.TechnicalDrawing.faces",
                    "signature": "build123d.TechnicalDrawing.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.faces_intersected_by_axis",
                    "signature": "build123d.TechnicalDrawing.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.TechnicalDrawing.fillet",
                    "signature": "build123d.TechnicalDrawing.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.TechnicalDrawing.find_intersection",
                    "signature": "build123d.TechnicalDrawing.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.TechnicalDrawing.find_intersection_points",
                    "signature": "build123d.TechnicalDrawing.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.TechnicalDrawing.first_level_shapes",
                    "signature": "build123d.TechnicalDrawing.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.TechnicalDrawing.fix",
                    "signature": "build123d.TechnicalDrawing.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.TechnicalDrawing.fuse",
                    "signature": "build123d.TechnicalDrawing.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.get_type",
                    "signature": "build123d.TechnicalDrawing.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.TechnicalDrawing.hash_code",
                    "signature": "build123d.TechnicalDrawing.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.hollow",
                    "signature": "build123d.TechnicalDrawing.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.TechnicalDrawing.intersect",
                    "signature": "build123d.TechnicalDrawing.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.is_equal",
                    "signature": "build123d.TechnicalDrawing.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.is_inside",
                    "signature": "build123d.TechnicalDrawing.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.TechnicalDrawing.is_null",
                    "signature": "build123d.TechnicalDrawing.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.is_same",
                    "signature": "build123d.TechnicalDrawing.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.is_valid",
                    "signature": "build123d.TechnicalDrawing.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.iter_path_reverse",
                    "signature": "build123d.TechnicalDrawing.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.TechnicalDrawing.locate",
                    "signature": "build123d.TechnicalDrawing.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.located",
                    "signature": "build123d.TechnicalDrawing.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.TechnicalDrawing.make_compound",
                    "signature": "build123d.TechnicalDrawing.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.make_text",
                    "signature": "build123d.TechnicalDrawing.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.TechnicalDrawing.make_triad",
                    "signature": "build123d.TechnicalDrawing.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.TechnicalDrawing.max_fillet",
                    "signature": "build123d.TechnicalDrawing.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.TechnicalDrawing.mesh",
                    "signature": "build123d.TechnicalDrawing.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.mirror",
                    "signature": "build123d.TechnicalDrawing.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.move",
                    "signature": "build123d.TechnicalDrawing.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.moved",
                    "signature": "build123d.TechnicalDrawing.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.TechnicalDrawing.offset_3d",
                    "signature": "build123d.TechnicalDrawing.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.TechnicalDrawing.project_faces",
                    "signature": "build123d.TechnicalDrawing.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.TechnicalDrawing.project_to_viewport",
                    "signature": "build123d.TechnicalDrawing.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.TechnicalDrawing.relocate",
                    "signature": "build123d.TechnicalDrawing.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.TechnicalDrawing.rotate",
                    "signature": "build123d.TechnicalDrawing.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.TechnicalDrawing.scale",
                    "signature": "build123d.TechnicalDrawing.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.shape_type",
                    "signature": "build123d.TechnicalDrawing.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.TechnicalDrawing.shell",
                    "signature": "build123d.TechnicalDrawing.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.TechnicalDrawing.shells",
                    "signature": "build123d.TechnicalDrawing.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.show_topology",
                    "signature": "build123d.TechnicalDrawing.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.TechnicalDrawing.solid",
                    "signature": "build123d.TechnicalDrawing.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.TechnicalDrawing.solids",
                    "signature": "build123d.TechnicalDrawing.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.split",
                    "signature": "build123d.TechnicalDrawing.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.TechnicalDrawing.split_by_perimeter",
                    "signature": "build123d.TechnicalDrawing.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.TechnicalDrawing.tessellate",
                    "signature": "build123d.TechnicalDrawing.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.TechnicalDrawing.to_arcs",
                    "signature": "build123d.TechnicalDrawing.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.TechnicalDrawing.to_splines",
                    "signature": "build123d.TechnicalDrawing.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.TechnicalDrawing.to_vtk_poly_data",
                    "signature": "build123d.TechnicalDrawing.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.TechnicalDrawing.transform_geometry",
                    "signature": "build123d.TechnicalDrawing.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.TechnicalDrawing.transform_shape",
                    "signature": "build123d.TechnicalDrawing.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.TechnicalDrawing.transformed",
                    "signature": "build123d.TechnicalDrawing.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.TechnicalDrawing.translate",
                    "signature": "build123d.TechnicalDrawing.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.TechnicalDrawing.unwrap",
                    "signature": "build123d.TechnicalDrawing.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.vertex",
                    "signature": "build123d.TechnicalDrawing.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.TechnicalDrawing.vertices",
                    "signature": "build123d.TechnicalDrawing.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.TechnicalDrawing.wire",
                    "signature": "build123d.TechnicalDrawing.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.TechnicalDrawing.wires",
                    "signature": "build123d.TechnicalDrawing.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "margin",
                "orientation",
                "page_sizes",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: TechnicalDrawing\n\nThe border of a technical drawing with external frame and text box.\n\nArgs:\n    designed_by (str, optional): Defaults to \"build123d\".\n    design_date (date, optional): Defaults to date.today().\n    page_size (PageSize, optional): Defaults to PageSize.A4.\n    title (str, optional): drawing title. Defaults to \"Title\".\n    sub_title (str, optional): drawing sub title. Defaults to \"Sub Title\".\n    drawing_number (str, optional): Defaults to \"B3D-1\".\n    sheet_number (int, optional): Defaults to None.\n    drawing_scale (float, optional): displays as 1:value. Defaults to 1.0.\n    nominal_text_size (float, optional): size of title text. Defaults to 10.0.\n    line_width (float, optional): Defaults to 0.5.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Text",
            "signature": "build123d.Text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'str' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), path: 'Union[Edge, Wire]' = None, position_on_path: 'float' = 0.0, rotation: 'float' = 0, mode: 'Mode' = <Mode.ADD>) -> 'Compound'",
            "methods": [
                {
                    "name": "build123d.Text.bounding_box",
                    "signature": "build123d.Text.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Text.cast",
                    "signature": "build123d.Text.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Text.center",
                    "signature": "build123d.Text.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Text.chamfer",
                    "signature": "build123d.Text.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Text.clean",
                    "signature": "build123d.Text.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Text.closest_points",
                    "signature": "build123d.Text.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Text.combined_center",
                    "signature": "build123d.Text.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Text.compound",
                    "signature": "build123d.Text.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Text.compounds",
                    "signature": "build123d.Text.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Text.compute_mass",
                    "signature": "build123d.Text.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.copy",
                    "signature": "build123d.Text.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Text.copy_attributes_to",
                    "signature": "build123d.Text.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Text.cut",
                    "signature": "build123d.Text.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.distance",
                    "signature": "build123d.Text.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.distance_to",
                    "signature": "build123d.Text.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Text.distance_to_with_closest_points",
                    "signature": "build123d.Text.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Text.distances",
                    "signature": "build123d.Text.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.do_children_intersect",
                    "signature": "build123d.Text.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Text.dprism",
                    "signature": "build123d.Text.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Text.edge",
                    "signature": "build123d.Text.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Text.edges",
                    "signature": "build123d.Text.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Text.export_brep",
                    "signature": "build123d.Text.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.export_step",
                    "signature": "build123d.Text.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Text.export_stl",
                    "signature": "build123d.Text.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Text.extrude",
                    "signature": "build123d.Text.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Text.face",
                    "signature": "build123d.Text.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Text.faces",
                    "signature": "build123d.Text.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Text.faces_intersected_by_axis",
                    "signature": "build123d.Text.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Text.fillet",
                    "signature": "build123d.Text.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Text.find_intersection",
                    "signature": "build123d.Text.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Text.find_intersection_points",
                    "signature": "build123d.Text.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Text.first_level_shapes",
                    "signature": "build123d.Text.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Text.fix",
                    "signature": "build123d.Text.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Text.fuse",
                    "signature": "build123d.Text.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Text.get_type",
                    "signature": "build123d.Text.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Text.hash_code",
                    "signature": "build123d.Text.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.hollow",
                    "signature": "build123d.Text.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Text.intersect",
                    "signature": "build123d.Text.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.is_equal",
                    "signature": "build123d.Text.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.is_inside",
                    "signature": "build123d.Text.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Text.is_null",
                    "signature": "build123d.Text.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.is_same",
                    "signature": "build123d.Text.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.is_valid",
                    "signature": "build123d.Text.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.iter_path_reverse",
                    "signature": "build123d.Text.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Text.locate",
                    "signature": "build123d.Text.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.located",
                    "signature": "build123d.Text.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Text.make_compound",
                    "signature": "build123d.Text.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Text.make_text",
                    "signature": "build123d.Text.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Text.make_triad",
                    "signature": "build123d.Text.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Text.max_fillet",
                    "signature": "build123d.Text.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Text.mesh",
                    "signature": "build123d.Text.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Text.mirror",
                    "signature": "build123d.Text.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Text.move",
                    "signature": "build123d.Text.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.moved",
                    "signature": "build123d.Text.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Text.offset_3d",
                    "signature": "build123d.Text.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Text.project_faces",
                    "signature": "build123d.Text.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Text.project_to_viewport",
                    "signature": "build123d.Text.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Text.relocate",
                    "signature": "build123d.Text.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Text.rotate",
                    "signature": "build123d.Text.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Text.scale",
                    "signature": "build123d.Text.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.shape_type",
                    "signature": "build123d.Text.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Text.shell",
                    "signature": "build123d.Text.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Text.shells",
                    "signature": "build123d.Text.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Text.show_topology",
                    "signature": "build123d.Text.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Text.solid",
                    "signature": "build123d.Text.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Text.solids",
                    "signature": "build123d.Text.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Text.split",
                    "signature": "build123d.Text.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Text.split_by_perimeter",
                    "signature": "build123d.Text.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Text.tessellate",
                    "signature": "build123d.Text.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Text.to_arcs",
                    "signature": "build123d.Text.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Text.to_splines",
                    "signature": "build123d.Text.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Text.to_vtk_poly_data",
                    "signature": "build123d.Text.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Text.transform_geometry",
                    "signature": "build123d.Text.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Text.transform_shape",
                    "signature": "build123d.Text.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Text.transformed",
                    "signature": "build123d.Text.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Text.translate",
                    "signature": "build123d.Text.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Text.unwrap",
                    "signature": "build123d.Text.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Text.vertex",
                    "signature": "build123d.Text.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Text.vertices",
                    "signature": "build123d.Text.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Text.wire",
                    "signature": "build123d.Text.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Text.wires",
                    "signature": "build123d.Text.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Text\n\nAdd text(s) to the sketch.\n\nArgs:\n    txt (str): text to be rendered\n    font_size (float): size of the font in model units\n    font (str, optional): font name. Defaults to \"Arial\".\n    font_path (str, optional): system path to font library. Defaults to None.\n    font_style (Font_Style, optional): style. Defaults to Font_Style.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n    path (Union[Edge, Wire], optional): path for text to follow. Defaults to None.\n    position_on_path (float, optional): the relative location on path to position the\n        text, values must be between 0.0 and 1.0. Defaults to 0.0.\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.ThreePointArc",
            "signature": "build123d.ThreePointArc(*pts: 'Union[VectorLike, Iterable[VectorLike]]', mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.ThreePointArc.bounding_box",
                    "signature": "build123d.ThreePointArc.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.ThreePointArc.cast",
                    "signature": "build123d.ThreePointArc.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.ThreePointArc.center",
                    "signature": "build123d.ThreePointArc.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.ThreePointArc.clean",
                    "signature": "build123d.ThreePointArc.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.ThreePointArc.close",
                    "signature": "build123d.ThreePointArc.close(self) -> 'Union[Edge, Wire]'",
                    "docstring": "Close an Edge"
                },
                {
                    "name": "build123d.ThreePointArc.closest_points",
                    "signature": "build123d.ThreePointArc.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.ThreePointArc.combined_center",
                    "signature": "build123d.ThreePointArc.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.ThreePointArc.common_plane",
                    "signature": "build123d.ThreePointArc.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.ThreePointArc.compound",
                    "signature": "build123d.ThreePointArc.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.ThreePointArc.compounds",
                    "signature": "build123d.ThreePointArc.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.ThreePointArc.compute_mass",
                    "signature": "build123d.ThreePointArc.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.copy",
                    "signature": "build123d.ThreePointArc.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.ThreePointArc.copy_attributes_to",
                    "signature": "build123d.ThreePointArc.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.ThreePointArc.cut",
                    "signature": "build123d.ThreePointArc.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.distance",
                    "signature": "build123d.ThreePointArc.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.distance_to",
                    "signature": "build123d.ThreePointArc.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.ThreePointArc.distance_to_with_closest_points",
                    "signature": "build123d.ThreePointArc.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.ThreePointArc.distances",
                    "signature": "build123d.ThreePointArc.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.distribute_locations",
                    "signature": "build123d.ThreePointArc.distribute_locations(self: 'Union[Wire, Edge]', count: 'int', start: 'float' = 0.0, stop: 'float' = 1.0, positions_only: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Distribute Locations\n\nDistribute locations along edge or wire.\n\nArgs:\n  self: Union[Wire:Edge]:\n  count(int): Number of locations to generate\n  start(float): position along Edge|Wire to start. Defaults to 0.0.\n  stop(float): position along Edge|Wire to end. Defaults to 1.0.\n  positions_only(bool): only generate position not orientation. Defaults to False.\n\nReturns:\n  list[Location]: locations distributed along Edge|Wire\n\nRaises:\n  ValueError: count must be two or greater"
                },
                {
                    "name": "build123d.ThreePointArc.edge",
                    "signature": "build123d.ThreePointArc.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.ThreePointArc.edges",
                    "signature": "build123d.ThreePointArc.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.ThreePointArc.end_point",
                    "signature": "build123d.ThreePointArc.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.ThreePointArc.export_brep",
                    "signature": "build123d.ThreePointArc.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.export_step",
                    "signature": "build123d.ThreePointArc.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.ThreePointArc.export_stl",
                    "signature": "build123d.ThreePointArc.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.ThreePointArc.extrude",
                    "signature": "build123d.ThreePointArc.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.ThreePointArc.face",
                    "signature": "build123d.ThreePointArc.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.ThreePointArc.faces",
                    "signature": "build123d.ThreePointArc.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.ThreePointArc.faces_intersected_by_axis",
                    "signature": "build123d.ThreePointArc.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.ThreePointArc.find_intersection",
                    "signature": "build123d.ThreePointArc.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.ThreePointArc.find_intersection_points",
                    "signature": "build123d.ThreePointArc.find_intersection_points(self, edge: 'Union[Axis, Edge]' = None, tolerance: 'float' = 1e-06) -> 'ShapeList[Vector]'",
                    "docstring": "find_intersection_points\n\nDetermine the points where a 2D edge crosses itself or another 2D edge\n\nArgs:\n    edge (Union[Axis, Edge]): curve to compare with\n    tolerance (float, optional): the precision of computing the intersection points.\n         Defaults to TOLERANCE.\n\nReturns:\n    ShapeList[Vector]: list of intersection points"
                },
                {
                    "name": "build123d.ThreePointArc.find_tangent",
                    "signature": "build123d.ThreePointArc.find_tangent(self, angle: 'float') -> 'list[float]'",
                    "docstring": "find_tangent\n\nFind the parameter values of self where the tangent is equal to angle.\n\nArgs:\n    angle (float): target angle in degrees\n\nReturns:\n    list[float]: u values between 0.0 and 1.0"
                },
                {
                    "name": "build123d.ThreePointArc.fix",
                    "signature": "build123d.ThreePointArc.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.ThreePointArc.fuse",
                    "signature": "build123d.ThreePointArc.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.ThreePointArc.hash_code",
                    "signature": "build123d.ThreePointArc.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.intersect",
                    "signature": "build123d.ThreePointArc.intersect(self, other: 'Union[Edge, Axis]') -> 'Union[Shape, None]'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.ThreePointArc.is_equal",
                    "signature": "build123d.ThreePointArc.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.is_null",
                    "signature": "build123d.ThreePointArc.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.is_same",
                    "signature": "build123d.ThreePointArc.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.is_valid",
                    "signature": "build123d.ThreePointArc.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.iter_path_reverse",
                    "signature": "build123d.ThreePointArc.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.ThreePointArc.locate",
                    "signature": "build123d.ThreePointArc.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.located",
                    "signature": "build123d.ThreePointArc.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.ThreePointArc.location_at",
                    "signature": "build123d.ThreePointArc.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.ThreePointArc.locations",
                    "signature": "build123d.ThreePointArc.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.ThreePointArc.make_bezier",
                    "signature": "build123d.ThreePointArc.make_bezier(*cntl_pnts: 'VectorLike', weights: 'list[float]' = None) -> 'Edge'",
                    "docstring": "make_bezier\n\nCreate a rational (with weights) or non-rational bezier curve.  The first and last\ncontrol points represent the start and end of the curve respectively.  If weights\nare provided, there must be one provided for each control point.\n\nArgs:\n    cntl_pnts (sequence[VectorLike]): points defining the curve\n    weights (list[float], optional): control point weights list. Defaults to None.\n\nRaises:\n    ValueError: Too few control points\n    ValueError: Too many control points\n    ValueError: A weight is required for each control point\n\nReturns:\n    Edge: bezier curve"
                },
                {
                    "name": "build123d.ThreePointArc.make_circle",
                    "signature": "build123d.ThreePointArc.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make circle\n\nCreate a circle centered on the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): start of arc angle. Defaults to 360.0.\n    end_angle (float, optional): end of arc angle. Defaults to 360.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial circle"
                },
                {
                    "name": "build123d.ThreePointArc.make_ellipse",
                    "signature": "build123d.ThreePointArc.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>) -> 'Edge'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): Defaults to 360.0.\n    end_angle (float, optional): Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n\nReturns:\n    Edge: full or partial ellipse"
                },
                {
                    "name": "build123d.ThreePointArc.make_helix",
                    "signature": "build123d.ThreePointArc.make_helix(pitch: 'float', height: 'float', radius: 'float', center: 'VectorLike' = (0, 0, 0), normal: 'VectorLike' = (0, 0, 1), angle: 'float' = 0.0, lefthand: 'bool' = False) -> 'Wire'",
                    "docstring": "make_helix\n\nMake a helix with a given pitch, height and radius. By default a cylindrical surface is\nused to create the helix. If the :angle: is set (the apex given in degree) a conical\nsurface is used instead.\n\nArgs:\n    pitch (float): distance per revolution along normal\n    height (float): total height\n    radius (float):\n    center (VectorLike, optional): Defaults to (0, 0, 0).\n    normal (VectorLike, optional): Defaults to (0, 0, 1).\n    angle (float, optional): conical angle. Defaults to 0.0.\n    lefthand (bool, optional): Defaults to False.\n\nReturns:\n    Wire: helix"
                },
                {
                    "name": "build123d.ThreePointArc.make_line",
                    "signature": "build123d.ThreePointArc.make_line(point1: 'VectorLike', point2: 'VectorLike') -> 'Edge'",
                    "docstring": "Create a line between two points\n\nArgs:\n  point1: VectorLike: that represents the first point\n  point2: VectorLike: that represents the second point\n\nReturns:\n  A linear edge between the two provided points"
                },
                {
                    "name": "build123d.ThreePointArc.make_mid_way",
                    "signature": "build123d.ThreePointArc.make_mid_way(first: 'Edge', second: 'Edge', middle: 'float' = 0.5) -> 'Edge'",
                    "docstring": "make line between edges\n\nCreate a new linear Edge between the two provided Edges. If the Edges are parallel\nbut in the opposite directions one Edge is flipped such that the mid way Edge isn't\ntruncated.\n\nArgs:\n    first (Edge): first reference Edge\n    second (Edge): second reference Edge\n    middle (float, optional): factional distance between Edges. Defaults to 0.5.\n\nReturns:\n    Edge: linear Edge between two Edges"
                },
                {
                    "name": "build123d.ThreePointArc.make_spline",
                    "signature": "build123d.ThreePointArc.make_spline(points: 'list[VectorLike]', tangents: 'list[VectorLike]' = None, periodic: 'bool' = False, parameters: 'list[float]' = None, scale: 'bool' = True, tol: 'float' = 1e-06) -> 'Edge'",
                    "docstring": "Spline\n\nInterpolate a spline through the provided points.\n\nArgs:\n    points (list[VectorLike]):  the points defining the spline\n    tangents (list[VectorLike], optional): start and finish tangent.\n        Defaults to None.\n    periodic (bool, optional): creation of periodic curves. Defaults to False.\n    parameters (list[float], optional): the value of the parameter at each\n        interpolation point. (The interpolated curve is represented as a vector-valued\n        function of a scalar parameter.) If periodic == True, then len(parameters)\n        must be len(interpolation points) + 1, otherwise len(parameters)\n        must be equal to len(interpolation points). Defaults to None.\n    scale (bool, optional): whether to scale the specified tangent vectors before\n        interpolating. Each tangent is scaled, so it's length is equal to the derivative\n        of the Lagrange interpolated curve. I.e., set this to True, if you want to use\n        only the direction of the tangent vectors specified by `tangents` , but not\n        their magnitude. Defaults to True.\n    tol (float, optional): tolerance of the algorithm (consult OCC documentation).\n        Used to check that the specified points are not too close to each other, and\n        that tangent vectors are not too short. (In either case interpolation may fail.).\n        Defaults to 1e-6.\n\nRaises:\n    ValueError: Parameter for each interpolation point\n    ValueError: Tangent for each interpolation point\n    ValueError: B-spline interpolation failed\n\nReturns:\n    Edge: the spline"
                },
                {
                    "name": "build123d.ThreePointArc.make_spline_approx",
                    "signature": "build123d.ThreePointArc.make_spline_approx(points: 'list[VectorLike]', tol: 'float' = 0.001, smoothing: 'Tuple[float, float, float]' = None, min_deg: 'int' = 1, max_deg: 'int' = 6) -> 'Edge'",
                    "docstring": "make_spline_approx\n\nApproximate a spline through the provided points.\n\nArgs:\n    points (list[Vector]):\n    tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.\n    smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights\n        use for variational smoothing. Defaults to None.\n    min_deg (int, optional): minimum spline degree. Enforced only when smoothing\n        is None. Defaults to 1.\n    max_deg (int, optional): maximum spline degree. Defaults to 6.\n\nRaises:\n    ValueError: B-spline approximation failed\n\nReturns:\n    Edge: spline"
                },
                {
                    "name": "build123d.ThreePointArc.make_tangent_arc",
                    "signature": "build123d.ThreePointArc.make_tangent_arc(start: 'VectorLike', tangent: 'VectorLike', end: 'VectorLike') -> 'Edge'",
                    "docstring": "Tangent Arc\n\nMakes a tangent arc from point start, in the direction of tangent and ends at end.\n\nArgs:\n    start (VectorLike): start point\n    tangent (VectorLike): start tangent\n    end (VectorLike): end point\n\nReturns:\n    Edge: circular arc"
                },
                {
                    "name": "build123d.ThreePointArc.make_three_point_arc",
                    "signature": "build123d.ThreePointArc.make_three_point_arc(point1: 'VectorLike', point2: 'VectorLike', point3: 'VectorLike') -> 'Edge'",
                    "docstring": "Three Point Arc\n\nMakes a three point arc through the provided points\n\nArgs:\n    point1 (VectorLike): start point\n    point2 (VectorLike): middle point\n    point3 (VectorLike): end point\n\nReturns:\n    Edge: a circular arc through the three points"
                },
                {
                    "name": "build123d.ThreePointArc.mesh",
                    "signature": "build123d.ThreePointArc.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.mirror",
                    "signature": "build123d.ThreePointArc.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.ThreePointArc.move",
                    "signature": "build123d.ThreePointArc.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.moved",
                    "signature": "build123d.ThreePointArc.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.ThreePointArc.normal",
                    "signature": "build123d.ThreePointArc.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.offset_2d",
                    "signature": "build123d.ThreePointArc.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.ThreePointArc.param_at",
                    "signature": "build123d.ThreePointArc.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.ThreePointArc.param_at_point",
                    "signature": "build123d.ThreePointArc.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Normalized parameter at point along Edge"
                },
                {
                    "name": "build123d.ThreePointArc.perpendicular_line",
                    "signature": "build123d.ThreePointArc.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.ThreePointArc.position_at",
                    "signature": "build123d.ThreePointArc.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.ThreePointArc.positions",
                    "signature": "build123d.ThreePointArc.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.ThreePointArc.project",
                    "signature": "build123d.ThreePointArc.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.project_faces",
                    "signature": "build123d.ThreePointArc.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.ThreePointArc.project_to_shape",
                    "signature": "build123d.ThreePointArc.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Edge]'",
                    "docstring": "Project Edge\n\nProject an Edge onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected Edge(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.ThreePointArc.project_to_viewport",
                    "signature": "build123d.ThreePointArc.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.ThreePointArc.relocate",
                    "signature": "build123d.ThreePointArc.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.ThreePointArc.reversed",
                    "signature": "build123d.ThreePointArc.reversed(self) -> 'Edge'",
                    "docstring": "Return a copy of self with the opposite orientation"
                },
                {
                    "name": "build123d.ThreePointArc.rotate",
                    "signature": "build123d.ThreePointArc.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.ThreePointArc.scale",
                    "signature": "build123d.ThreePointArc.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.shape_type",
                    "signature": "build123d.ThreePointArc.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.ThreePointArc.shell",
                    "signature": "build123d.ThreePointArc.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.ThreePointArc.shells",
                    "signature": "build123d.ThreePointArc.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.ThreePointArc.show_topology",
                    "signature": "build123d.ThreePointArc.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.ThreePointArc.solid",
                    "signature": "build123d.ThreePointArc.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.ThreePointArc.solids",
                    "signature": "build123d.ThreePointArc.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.ThreePointArc.split",
                    "signature": "build123d.ThreePointArc.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.ThreePointArc.split_by_perimeter",
                    "signature": "build123d.ThreePointArc.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.ThreePointArc.start_point",
                    "signature": "build123d.ThreePointArc.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.ThreePointArc.tangent_angle_at",
                    "signature": "build123d.ThreePointArc.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.ThreePointArc.tangent_at",
                    "signature": "build123d.ThreePointArc.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.ThreePointArc.tessellate",
                    "signature": "build123d.ThreePointArc.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.ThreePointArc.to_arcs",
                    "signature": "build123d.ThreePointArc.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.ThreePointArc.to_axis",
                    "signature": "build123d.ThreePointArc.to_axis(self) -> 'Axis'",
                    "docstring": "Translate a linear Edge to an Axis"
                },
                {
                    "name": "build123d.ThreePointArc.to_splines",
                    "signature": "build123d.ThreePointArc.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.ThreePointArc.to_vtk_poly_data",
                    "signature": "build123d.ThreePointArc.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.ThreePointArc.to_wire",
                    "signature": "build123d.ThreePointArc.to_wire(self) -> 'Wire'",
                    "docstring": "Edge as Wire"
                },
                {
                    "name": "build123d.ThreePointArc.transform_geometry",
                    "signature": "build123d.ThreePointArc.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.ThreePointArc.transform_shape",
                    "signature": "build123d.ThreePointArc.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.ThreePointArc.transformed",
                    "signature": "build123d.ThreePointArc.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.ThreePointArc.translate",
                    "signature": "build123d.ThreePointArc.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.ThreePointArc.trim",
                    "signature": "build123d.ThreePointArc.trim(self, start: 'float', end: 'float') -> 'Edge'",
                    "docstring": "trim\n\nCreate a new edge by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.ThreePointArc.trim_to_length",
                    "signature": "build123d.ThreePointArc.trim_to_length(self, start: 'float', length: 'float') -> 'Edge'",
                    "docstring": "trim_to_length\n\nCreate a new edge starting at the given normalized parameter of a\ngiven length.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    length (float): target length\n\nReturns:\n    Edge: trimmed edge"
                },
                {
                    "name": "build123d.ThreePointArc.vertex",
                    "signature": "build123d.ThreePointArc.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.ThreePointArc.vertices",
                    "signature": "build123d.ThreePointArc.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.ThreePointArc.wire",
                    "signature": "build123d.ThreePointArc.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.ThreePointArc.wires",
                    "signature": "build123d.ThreePointArc.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "arc_center",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Line Object: Three Point Arc\n\nAdd an arc generated by three points.\n\nArgs:\n    pts (Union[VectorLike, Iterable[VectorLike]]): sequence of three points\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: Three points must be provided"
        },
        {
            "name": "build123d.Torus",
            "signature": "build123d.Torus(major_radius: 'float', minor_radius: 'float', minor_start_angle: 'float' = 0, minor_end_angle: 'float' = 360, major_angle: 'float' = 360, rotation: 'RotationLike' = (0, 0, 0), align: 'Union[Align, tuple[Align, Align, Align]]' = (<Align.CENTER>, <Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Torus.bounding_box",
                    "signature": "build123d.Torus.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Torus.cast",
                    "signature": "build123d.Torus.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Torus.center",
                    "signature": "build123d.Torus.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Torus.chamfer",
                    "signature": "build123d.Torus.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Torus.clean",
                    "signature": "build123d.Torus.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Torus.closest_points",
                    "signature": "build123d.Torus.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Torus.combined_center",
                    "signature": "build123d.Torus.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Torus.compound",
                    "signature": "build123d.Torus.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Torus.compounds",
                    "signature": "build123d.Torus.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Torus.compute_mass",
                    "signature": "build123d.Torus.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.copy",
                    "signature": "build123d.Torus.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Torus.copy_attributes_to",
                    "signature": "build123d.Torus.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Torus.cut",
                    "signature": "build123d.Torus.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.distance",
                    "signature": "build123d.Torus.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.distance_to",
                    "signature": "build123d.Torus.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Torus.distance_to_with_closest_points",
                    "signature": "build123d.Torus.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Torus.distances",
                    "signature": "build123d.Torus.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.do_children_intersect",
                    "signature": "build123d.Torus.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Torus.dprism",
                    "signature": "build123d.Torus.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Torus.edge",
                    "signature": "build123d.Torus.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Torus.edges",
                    "signature": "build123d.Torus.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Torus.export_brep",
                    "signature": "build123d.Torus.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.export_step",
                    "signature": "build123d.Torus.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Torus.export_stl",
                    "signature": "build123d.Torus.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Torus.extrude",
                    "signature": "build123d.Torus.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Torus.face",
                    "signature": "build123d.Torus.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Torus.faces",
                    "signature": "build123d.Torus.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Torus.faces_intersected_by_axis",
                    "signature": "build123d.Torus.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Torus.fillet",
                    "signature": "build123d.Torus.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Torus.find_intersection",
                    "signature": "build123d.Torus.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Torus.find_intersection_points",
                    "signature": "build123d.Torus.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Torus.first_level_shapes",
                    "signature": "build123d.Torus.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Torus.fix",
                    "signature": "build123d.Torus.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Torus.fuse",
                    "signature": "build123d.Torus.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.get_type",
                    "signature": "build123d.Torus.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Torus.hash_code",
                    "signature": "build123d.Torus.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.hollow",
                    "signature": "build123d.Torus.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Torus.intersect",
                    "signature": "build123d.Torus.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.is_equal",
                    "signature": "build123d.Torus.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.is_inside",
                    "signature": "build123d.Torus.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Torus.is_null",
                    "signature": "build123d.Torus.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.is_same",
                    "signature": "build123d.Torus.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.is_valid",
                    "signature": "build123d.Torus.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.iter_path_reverse",
                    "signature": "build123d.Torus.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Torus.locate",
                    "signature": "build123d.Torus.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.located",
                    "signature": "build123d.Torus.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Torus.make_compound",
                    "signature": "build123d.Torus.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Torus.make_text",
                    "signature": "build123d.Torus.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Torus.make_triad",
                    "signature": "build123d.Torus.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Torus.max_fillet",
                    "signature": "build123d.Torus.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Torus.mesh",
                    "signature": "build123d.Torus.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.mirror",
                    "signature": "build123d.Torus.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Torus.move",
                    "signature": "build123d.Torus.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.moved",
                    "signature": "build123d.Torus.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Torus.offset_3d",
                    "signature": "build123d.Torus.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Torus.project_faces",
                    "signature": "build123d.Torus.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Torus.project_to_viewport",
                    "signature": "build123d.Torus.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Torus.relocate",
                    "signature": "build123d.Torus.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Torus.rotate",
                    "signature": "build123d.Torus.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Torus.scale",
                    "signature": "build123d.Torus.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.shape_type",
                    "signature": "build123d.Torus.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Torus.shell",
                    "signature": "build123d.Torus.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Torus.shells",
                    "signature": "build123d.Torus.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Torus.show_topology",
                    "signature": "build123d.Torus.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Torus.solid",
                    "signature": "build123d.Torus.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Torus.solids",
                    "signature": "build123d.Torus.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Torus.split",
                    "signature": "build123d.Torus.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Torus.split_by_perimeter",
                    "signature": "build123d.Torus.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Torus.tessellate",
                    "signature": "build123d.Torus.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Torus.to_arcs",
                    "signature": "build123d.Torus.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Torus.to_splines",
                    "signature": "build123d.Torus.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Torus.to_vtk_poly_data",
                    "signature": "build123d.Torus.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Torus.transform_geometry",
                    "signature": "build123d.Torus.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Torus.transform_shape",
                    "signature": "build123d.Torus.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Torus.transformed",
                    "signature": "build123d.Torus.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Torus.translate",
                    "signature": "build123d.Torus.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Torus.unwrap",
                    "signature": "build123d.Torus.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Torus.vertex",
                    "signature": "build123d.Torus.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Torus.vertices",
                    "signature": "build123d.Torus.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Torus.wire",
                    "signature": "build123d.Torus.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Torus.wires",
                    "signature": "build123d.Torus.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Part Object: Torus\n\nCreate a torus(es) and combine with part.\n\n\nArgs:\n    major_radius (float): torus size\n    minor_radius (float): torus size\n    major_arc_size (float, optional): angular size of torus. Defaults to 0.\n    minor_arc_size (float, optional): angular size or torus. Defaults to 360.\n    rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).\n    align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,\n        or max of object. Defaults to (Align.CENTER, Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combine mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Transition",
            "signature": "build123d.Transition()",
            "methods": [],
            "variables": [
                "RIGHT",
                "ROUND",
                "TRANSFORMED",
                "name",
                "value"
            ],
            "docstring": "Sweep discontinuity handling option"
        },
        {
            "name": "build123d.Trapezoid",
            "signature": "build123d.Trapezoid(width: 'float', height: 'float', left_side_angle: 'float', right_side_angle: 'float' = None, rotation: 'float' = 0, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Trapezoid.bounding_box",
                    "signature": "build123d.Trapezoid.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Trapezoid.cast",
                    "signature": "build123d.Trapezoid.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Trapezoid.center",
                    "signature": "build123d.Trapezoid.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Trapezoid.chamfer",
                    "signature": "build123d.Trapezoid.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Trapezoid.clean",
                    "signature": "build123d.Trapezoid.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Trapezoid.closest_points",
                    "signature": "build123d.Trapezoid.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Trapezoid.combined_center",
                    "signature": "build123d.Trapezoid.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Trapezoid.compound",
                    "signature": "build123d.Trapezoid.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Trapezoid.compounds",
                    "signature": "build123d.Trapezoid.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Trapezoid.compute_mass",
                    "signature": "build123d.Trapezoid.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.copy",
                    "signature": "build123d.Trapezoid.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Trapezoid.copy_attributes_to",
                    "signature": "build123d.Trapezoid.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Trapezoid.cut",
                    "signature": "build123d.Trapezoid.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.distance",
                    "signature": "build123d.Trapezoid.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.distance_to",
                    "signature": "build123d.Trapezoid.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Trapezoid.distance_to_with_closest_points",
                    "signature": "build123d.Trapezoid.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Trapezoid.distances",
                    "signature": "build123d.Trapezoid.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.do_children_intersect",
                    "signature": "build123d.Trapezoid.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Trapezoid.dprism",
                    "signature": "build123d.Trapezoid.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Trapezoid.edge",
                    "signature": "build123d.Trapezoid.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Trapezoid.edges",
                    "signature": "build123d.Trapezoid.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Trapezoid.export_brep",
                    "signature": "build123d.Trapezoid.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.export_step",
                    "signature": "build123d.Trapezoid.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Trapezoid.export_stl",
                    "signature": "build123d.Trapezoid.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Trapezoid.extrude",
                    "signature": "build123d.Trapezoid.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Trapezoid.face",
                    "signature": "build123d.Trapezoid.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Trapezoid.faces",
                    "signature": "build123d.Trapezoid.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Trapezoid.faces_intersected_by_axis",
                    "signature": "build123d.Trapezoid.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Trapezoid.fillet",
                    "signature": "build123d.Trapezoid.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Trapezoid.find_intersection",
                    "signature": "build123d.Trapezoid.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Trapezoid.find_intersection_points",
                    "signature": "build123d.Trapezoid.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Trapezoid.first_level_shapes",
                    "signature": "build123d.Trapezoid.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Trapezoid.fix",
                    "signature": "build123d.Trapezoid.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Trapezoid.fuse",
                    "signature": "build123d.Trapezoid.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.get_type",
                    "signature": "build123d.Trapezoid.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Trapezoid.hash_code",
                    "signature": "build123d.Trapezoid.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.hollow",
                    "signature": "build123d.Trapezoid.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Trapezoid.intersect",
                    "signature": "build123d.Trapezoid.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.is_equal",
                    "signature": "build123d.Trapezoid.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.is_inside",
                    "signature": "build123d.Trapezoid.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Trapezoid.is_null",
                    "signature": "build123d.Trapezoid.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.is_same",
                    "signature": "build123d.Trapezoid.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.is_valid",
                    "signature": "build123d.Trapezoid.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.iter_path_reverse",
                    "signature": "build123d.Trapezoid.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Trapezoid.locate",
                    "signature": "build123d.Trapezoid.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.located",
                    "signature": "build123d.Trapezoid.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Trapezoid.make_compound",
                    "signature": "build123d.Trapezoid.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.make_text",
                    "signature": "build123d.Trapezoid.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Trapezoid.make_triad",
                    "signature": "build123d.Trapezoid.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Trapezoid.max_fillet",
                    "signature": "build123d.Trapezoid.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Trapezoid.mesh",
                    "signature": "build123d.Trapezoid.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.mirror",
                    "signature": "build123d.Trapezoid.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Trapezoid.move",
                    "signature": "build123d.Trapezoid.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.moved",
                    "signature": "build123d.Trapezoid.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Trapezoid.offset_3d",
                    "signature": "build123d.Trapezoid.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Trapezoid.project_faces",
                    "signature": "build123d.Trapezoid.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Trapezoid.project_to_viewport",
                    "signature": "build123d.Trapezoid.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Trapezoid.relocate",
                    "signature": "build123d.Trapezoid.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Trapezoid.rotate",
                    "signature": "build123d.Trapezoid.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Trapezoid.scale",
                    "signature": "build123d.Trapezoid.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.shape_type",
                    "signature": "build123d.Trapezoid.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Trapezoid.shell",
                    "signature": "build123d.Trapezoid.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Trapezoid.shells",
                    "signature": "build123d.Trapezoid.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Trapezoid.show_topology",
                    "signature": "build123d.Trapezoid.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Trapezoid.solid",
                    "signature": "build123d.Trapezoid.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Trapezoid.solids",
                    "signature": "build123d.Trapezoid.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Trapezoid.split",
                    "signature": "build123d.Trapezoid.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Trapezoid.split_by_perimeter",
                    "signature": "build123d.Trapezoid.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Trapezoid.tessellate",
                    "signature": "build123d.Trapezoid.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Trapezoid.to_arcs",
                    "signature": "build123d.Trapezoid.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Trapezoid.to_splines",
                    "signature": "build123d.Trapezoid.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Trapezoid.to_vtk_poly_data",
                    "signature": "build123d.Trapezoid.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Trapezoid.transform_geometry",
                    "signature": "build123d.Trapezoid.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Trapezoid.transform_shape",
                    "signature": "build123d.Trapezoid.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Trapezoid.transformed",
                    "signature": "build123d.Trapezoid.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Trapezoid.translate",
                    "signature": "build123d.Trapezoid.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Trapezoid.unwrap",
                    "signature": "build123d.Trapezoid.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Trapezoid.vertex",
                    "signature": "build123d.Trapezoid.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Trapezoid.vertices",
                    "signature": "build123d.Trapezoid.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Trapezoid.wire",
                    "signature": "build123d.Trapezoid.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Trapezoid.wires",
                    "signature": "build123d.Trapezoid.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Trapezoid\n\nAdd trapezoid(s) to the sketch.\n\nArgs:\n    width (float): horizontal width\n    height (float): vertical height\n    left_side_angle (float): bottom left interior angle\n    right_side_angle (float, optional): bottom right interior angle. If not provided,\n        the trapezoid will be symmetric. Defaults to None.\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to (Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: Give angles result in an invalid trapezoid"
        },
        {
            "name": "build123d.Triangle",
            "signature": "build123d.Triangle(*, a: 'float' = None, b: 'float' = None, c: 'float' = None, A: 'float' = None, B: 'float' = None, C: 'float' = None, align: 'Union[None, Align, tuple[Align, Align]]' = None, rotation: 'float' = 0, mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Triangle.bounding_box",
                    "signature": "build123d.Triangle.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Triangle.cast",
                    "signature": "build123d.Triangle.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Triangle.center",
                    "signature": "build123d.Triangle.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Triangle.chamfer",
                    "signature": "build123d.Triangle.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Triangle.clean",
                    "signature": "build123d.Triangle.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Triangle.closest_points",
                    "signature": "build123d.Triangle.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Triangle.combined_center",
                    "signature": "build123d.Triangle.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Triangle.compound",
                    "signature": "build123d.Triangle.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Triangle.compounds",
                    "signature": "build123d.Triangle.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Triangle.compute_mass",
                    "signature": "build123d.Triangle.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.copy",
                    "signature": "build123d.Triangle.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Triangle.copy_attributes_to",
                    "signature": "build123d.Triangle.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Triangle.cut",
                    "signature": "build123d.Triangle.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.distance",
                    "signature": "build123d.Triangle.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.distance_to",
                    "signature": "build123d.Triangle.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Triangle.distance_to_with_closest_points",
                    "signature": "build123d.Triangle.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Triangle.distances",
                    "signature": "build123d.Triangle.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.do_children_intersect",
                    "signature": "build123d.Triangle.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Triangle.dprism",
                    "signature": "build123d.Triangle.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Triangle.edge",
                    "signature": "build123d.Triangle.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Triangle.edges",
                    "signature": "build123d.Triangle.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Triangle.export_brep",
                    "signature": "build123d.Triangle.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.export_step",
                    "signature": "build123d.Triangle.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Triangle.export_stl",
                    "signature": "build123d.Triangle.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Triangle.extrude",
                    "signature": "build123d.Triangle.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Triangle.face",
                    "signature": "build123d.Triangle.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Triangle.faces",
                    "signature": "build123d.Triangle.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Triangle.faces_intersected_by_axis",
                    "signature": "build123d.Triangle.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Triangle.fillet",
                    "signature": "build123d.Triangle.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Triangle.find_intersection",
                    "signature": "build123d.Triangle.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Triangle.find_intersection_points",
                    "signature": "build123d.Triangle.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Triangle.first_level_shapes",
                    "signature": "build123d.Triangle.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Triangle.fix",
                    "signature": "build123d.Triangle.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Triangle.fuse",
                    "signature": "build123d.Triangle.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.get_type",
                    "signature": "build123d.Triangle.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Triangle.hash_code",
                    "signature": "build123d.Triangle.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.hollow",
                    "signature": "build123d.Triangle.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Triangle.intersect",
                    "signature": "build123d.Triangle.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.is_equal",
                    "signature": "build123d.Triangle.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.is_inside",
                    "signature": "build123d.Triangle.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Triangle.is_null",
                    "signature": "build123d.Triangle.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.is_same",
                    "signature": "build123d.Triangle.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.is_valid",
                    "signature": "build123d.Triangle.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.iter_path_reverse",
                    "signature": "build123d.Triangle.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Triangle.locate",
                    "signature": "build123d.Triangle.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.located",
                    "signature": "build123d.Triangle.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Triangle.make_compound",
                    "signature": "build123d.Triangle.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Triangle.make_text",
                    "signature": "build123d.Triangle.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Triangle.make_triad",
                    "signature": "build123d.Triangle.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Triangle.max_fillet",
                    "signature": "build123d.Triangle.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Triangle.mesh",
                    "signature": "build123d.Triangle.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.mirror",
                    "signature": "build123d.Triangle.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Triangle.move",
                    "signature": "build123d.Triangle.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.moved",
                    "signature": "build123d.Triangle.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Triangle.offset_3d",
                    "signature": "build123d.Triangle.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Triangle.project_faces",
                    "signature": "build123d.Triangle.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Triangle.project_to_viewport",
                    "signature": "build123d.Triangle.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Triangle.relocate",
                    "signature": "build123d.Triangle.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Triangle.rotate",
                    "signature": "build123d.Triangle.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Triangle.scale",
                    "signature": "build123d.Triangle.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.shape_type",
                    "signature": "build123d.Triangle.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Triangle.shell",
                    "signature": "build123d.Triangle.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Triangle.shells",
                    "signature": "build123d.Triangle.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Triangle.show_topology",
                    "signature": "build123d.Triangle.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Triangle.solid",
                    "signature": "build123d.Triangle.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Triangle.solids",
                    "signature": "build123d.Triangle.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Triangle.split",
                    "signature": "build123d.Triangle.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Triangle.split_by_perimeter",
                    "signature": "build123d.Triangle.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Triangle.tessellate",
                    "signature": "build123d.Triangle.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Triangle.to_arcs",
                    "signature": "build123d.Triangle.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Triangle.to_splines",
                    "signature": "build123d.Triangle.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Triangle.to_vtk_poly_data",
                    "signature": "build123d.Triangle.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Triangle.transform_geometry",
                    "signature": "build123d.Triangle.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Triangle.transform_shape",
                    "signature": "build123d.Triangle.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Triangle.transformed",
                    "signature": "build123d.Triangle.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Triangle.translate",
                    "signature": "build123d.Triangle.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Triangle.unwrap",
                    "signature": "build123d.Triangle.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Triangle.vertex",
                    "signature": "build123d.Triangle.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Triangle.vertices",
                    "signature": "build123d.Triangle.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Triangle.wire",
                    "signature": "build123d.Triangle.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Triangle.wires",
                    "signature": "build123d.Triangle.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Sketch Object: Triangle\n\nAdd any triangle to the sketch by specifying the length of any side and any\ntwo other side lengths or interior angles. Note that the interior angles are\nopposite the side with the same designation (i.e. side 'a' is opposite angle 'A').\n\nArgs:\n    a (float, optional): side 'a' length. Defaults to None.\n    b (float, optional): side 'b' length. Defaults to None.\n    c (float, optional): side 'c' length. Defaults to None.\n    A (float, optional): interior angle 'A' in degrees. Defaults to None.\n    B (float, optional): interior angle 'B' in degrees. Defaults to None.\n    C (float, optional): interior angle 'C' in degrees. Defaults to None.\n    rotation (float, optional): angles to rotate objects. Defaults to 0.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.\n        Defaults to None.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: One length and two other values were not provided"
        },
        {
            "name": "build123d.Unit",
            "signature": "build123d.Unit()",
            "methods": [],
            "variables": [
                "CM",
                "FT",
                "IN",
                "M",
                "MC",
                "MM",
                "name",
                "value"
            ],
            "docstring": "Standard Units"
        },
        {
            "name": "build123d.Until",
            "signature": "build123d.Until()",
            "methods": [],
            "variables": [
                "FIRST",
                "LAST",
                "NEXT",
                "PREVIOUS",
                "name",
                "value"
            ],
            "docstring": "Extrude limit"
        },
        {
            "name": "build123d.Vector",
            "signature": "build123d.Vector(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Vector.add",
                    "signature": "build123d.Vector.add(self: 'Vector', vec: 'VectorLike')",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Vector.center",
                    "signature": "build123d.Vector.center(self) -> 'Vector'",
                    "docstring": "center\n\nReturns:\n  The center of myself is myself.\n  Provided so that vectors, vertices, and other shapes all support a\n  common interface, when center() is requested for all objects on the\n  stack."
                },
                {
                    "name": "build123d.Vector.cross",
                    "signature": "build123d.Vector.cross(self, vec: 'Vector') -> 'Vector'",
                    "docstring": "Mathematical cross function"
                },
                {
                    "name": "build123d.Vector.distance_to_plane",
                    "signature": "build123d.Vector.distance_to_plane(self, plane: 'Plane') -> 'float'",
                    "docstring": "Minimum unsigned distance between vector and plane"
                },
                {
                    "name": "build123d.Vector.dot",
                    "signature": "build123d.Vector.dot(self, vec: 'Vector') -> 'float'",
                    "docstring": "Mathematical dot function"
                },
                {
                    "name": "build123d.Vector.get_angle",
                    "signature": "build123d.Vector.get_angle(self, vec: 'Vector') -> 'float'",
                    "docstring": "Unsigned angle between vectors"
                },
                {
                    "name": "build123d.Vector.get_signed_angle",
                    "signature": "build123d.Vector.get_signed_angle(self, vec: 'Vector', normal: 'Vector' = None) -> 'float'",
                    "docstring": "Signed Angle Between Vectors\n\nReturn the signed angle in degrees between two vectors with the given normal\nbased on this math: angle = atan2((Va \u00d7 Vb) \u22c5 Vn, Va \u22c5 Vb)\n\nArgs:\n    v (Vector): Second Vector\n    normal (Vector, optional): normal direction. Defaults to None.\n\nReturns:\n    float: Angle between vectors"
                },
                {
                    "name": "build123d.Vector.intersect",
                    "signature": "build123d.Vector.intersect(self, *args, **kwargs)",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Vector.multiply",
                    "signature": "build123d.Vector.multiply(self, scale: 'float') -> 'Vector'",
                    "docstring": "Mathematical multiply function"
                },
                {
                    "name": "build123d.Vector.normalized",
                    "signature": "build123d.Vector.normalized(self) -> 'Vector'",
                    "docstring": "Scale to length of 1"
                },
                {
                    "name": "build123d.Vector.project_to_line",
                    "signature": "build123d.Vector.project_to_line(self, line: 'Vector') -> 'Vector'",
                    "docstring": "Returns a new vector equal to the projection of this Vector onto the line\nrepresented by Vector <line>\n\nArgs:\n    line (Vector): project to this line\n\nReturns:\n    Vector: Returns the projected vector."
                },
                {
                    "name": "build123d.Vector.project_to_plane",
                    "signature": "build123d.Vector.project_to_plane(self, plane: 'Plane') -> 'Vector'",
                    "docstring": "Vector is projected onto the plane provided as input.\n\nArgs:\n  args: Plane object\n\nReturns the projected vector.\n  plane: Plane:\n\nReturns:"
                },
                {
                    "name": "build123d.Vector.reverse",
                    "signature": "build123d.Vector.reverse(self) -> 'Vector'",
                    "docstring": "Return a vector with the same magnitude but pointing in the opposite direction"
                },
                {
                    "name": "build123d.Vector.rotate",
                    "signature": "build123d.Vector.rotate(self, axis: 'Axis', angle: 'float') -> 'Vector'",
                    "docstring": "Rotate about axis\n\nRotate about the given Axis by an angle in degrees\n\nArgs:\n    axis (Axis): Axis of rotation\n    angle (float): angle in degrees\n\nReturns:\n    Vector: rotated vector"
                },
                {
                    "name": "build123d.Vector.signed_distance_from_plane",
                    "signature": "build123d.Vector.signed_distance_from_plane(self, plane: 'Plane') -> 'float'",
                    "docstring": "Signed distance from plane to point vector."
                },
                {
                    "name": "build123d.Vector.sub",
                    "signature": "build123d.Vector.sub(self: 'Vector', vec: 'VectorLike')",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Vector.to_dir",
                    "signature": "build123d.Vector.to_dir(self) -> 'gp_Dir'",
                    "docstring": "Convert to OCCT gp_Dir object"
                },
                {
                    "name": "build123d.Vector.to_pnt",
                    "signature": "build123d.Vector.to_pnt(self) -> 'gp_Pnt'",
                    "docstring": "Convert to OCCT gp_Pnt object"
                },
                {
                    "name": "build123d.Vector.to_tuple",
                    "signature": "build123d.Vector.to_tuple(self) -> 'tuple[float, float, float]'",
                    "docstring": "Return tuple equivalent"
                },
                {
                    "name": "build123d.Vector.transform",
                    "signature": "build123d.Vector.transform(self, affine_transform: 'Matrix', is_direction: 'bool' = False) -> 'Vector'",
                    "docstring": "Apply affine transformation\n\nArgs:\n    affine_transform (Matrix): affine transformation matrix\n    is_direction (bool, optional): Should self be transformed as a vector or direction?\n        Defaults to False (vector)\n\nReturns:\n    Vector: transformed vector"
                }
            ],
            "variables": [
                "X",
                "Y",
                "Z",
                "length",
                "wrapped"
            ],
            "docstring": "Create a 3-dimensional vector\n\nArgs:\n    x (float): x component\n    y (float): y component\n    z (float): z component\n    vec (Union[Vector, Sequence(float), gp_Vec, gp_Pnt, gp_Dir, gp_XYZ]): vector representations\n\nNote that if no z value is provided it's assumed to be zero. If no values are provided\nthe returned Vector has the value of 0, 0, 0.\n\nAttributes:\n    wrapped (gp_Vec): the OCP vector object"
        },
        {
            "name": "build123d.Vertex",
            "signature": "build123d.Vertex(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Vertex.bounding_box",
                    "signature": "build123d.Vertex.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Vertex.cast",
                    "signature": "build123d.Vertex.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Vertex.center",
                    "signature": "build123d.Vertex.center(self) -> 'Vector'",
                    "docstring": "The center of a vertex is itself!"
                },
                {
                    "name": "build123d.Vertex.clean",
                    "signature": "build123d.Vertex.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Vertex.closest_points",
                    "signature": "build123d.Vertex.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Vertex.combined_center",
                    "signature": "build123d.Vertex.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Vertex.compound",
                    "signature": "build123d.Vertex.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Vertex.compounds",
                    "signature": "build123d.Vertex.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Vertex.compute_mass",
                    "signature": "build123d.Vertex.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.copy",
                    "signature": "build123d.Vertex.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Vertex.copy_attributes_to",
                    "signature": "build123d.Vertex.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Vertex.cut",
                    "signature": "build123d.Vertex.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.distance",
                    "signature": "build123d.Vertex.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.distance_to",
                    "signature": "build123d.Vertex.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Vertex.distance_to_with_closest_points",
                    "signature": "build123d.Vertex.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Vertex.distances",
                    "signature": "build123d.Vertex.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.edge",
                    "signature": "build123d.Vertex.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Vertex.edges",
                    "signature": "build123d.Vertex.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Vertex.export_brep",
                    "signature": "build123d.Vertex.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.export_step",
                    "signature": "build123d.Vertex.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Vertex.export_stl",
                    "signature": "build123d.Vertex.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Vertex.extrude",
                    "signature": "build123d.Vertex.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Vertex.face",
                    "signature": "build123d.Vertex.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Vertex.faces",
                    "signature": "build123d.Vertex.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Vertex.faces_intersected_by_axis",
                    "signature": "build123d.Vertex.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Vertex.find_intersection",
                    "signature": "build123d.Vertex.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Vertex.find_intersection_points",
                    "signature": "build123d.Vertex.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Vertex.fix",
                    "signature": "build123d.Vertex.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Vertex.fuse",
                    "signature": "build123d.Vertex.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Vertex.hash_code",
                    "signature": "build123d.Vertex.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.intersect",
                    "signature": "build123d.Vertex.intersect(self, *to_intersect: 'Union[Shape, Axis, Plane]') -> 'Shape'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Vertex.is_equal",
                    "signature": "build123d.Vertex.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.is_null",
                    "signature": "build123d.Vertex.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.is_same",
                    "signature": "build123d.Vertex.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.is_valid",
                    "signature": "build123d.Vertex.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.iter_path_reverse",
                    "signature": "build123d.Vertex.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Vertex.locate",
                    "signature": "build123d.Vertex.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.located",
                    "signature": "build123d.Vertex.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Vertex.mesh",
                    "signature": "build123d.Vertex.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.mirror",
                    "signature": "build123d.Vertex.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Vertex.move",
                    "signature": "build123d.Vertex.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.moved",
                    "signature": "build123d.Vertex.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Vertex.project_faces",
                    "signature": "build123d.Vertex.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Vertex.project_to_viewport",
                    "signature": "build123d.Vertex.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Vertex.relocate",
                    "signature": "build123d.Vertex.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Vertex.rotate",
                    "signature": "build123d.Vertex.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Vertex.scale",
                    "signature": "build123d.Vertex.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.shape_type",
                    "signature": "build123d.Vertex.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Vertex.shell",
                    "signature": "build123d.Vertex.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Vertex.shells",
                    "signature": "build123d.Vertex.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Vertex.show_topology",
                    "signature": "build123d.Vertex.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Vertex.solid",
                    "signature": "build123d.Vertex.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Vertex.solids",
                    "signature": "build123d.Vertex.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Vertex.split",
                    "signature": "build123d.Vertex.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Vertex.split_by_perimeter",
                    "signature": "build123d.Vertex.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Vertex.tessellate",
                    "signature": "build123d.Vertex.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Vertex.to_arcs",
                    "signature": "build123d.Vertex.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Vertex.to_splines",
                    "signature": "build123d.Vertex.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Vertex.to_tuple",
                    "signature": "build123d.Vertex.to_tuple(self) -> 'tuple[float, float, float]'",
                    "docstring": "Return vertex as three tuple of floats"
                },
                {
                    "name": "build123d.Vertex.to_vtk_poly_data",
                    "signature": "build123d.Vertex.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Vertex.transform_geometry",
                    "signature": "build123d.Vertex.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Vertex.transform_shape",
                    "signature": "build123d.Vertex.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Vertex.transformed",
                    "signature": "build123d.Vertex.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Vertex.translate",
                    "signature": "build123d.Vertex.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Vertex.vertex",
                    "signature": "build123d.Vertex.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Vertex.vertices",
                    "signature": "build123d.Vertex.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Vertex.wire",
                    "signature": "build123d.Vertex.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Vertex.wires",
                    "signature": "build123d.Vertex.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "A Vertex in build123d represents a zero-dimensional point in the topological\ndata structure. It marks the endpoints of edges within a 3D model, defining precise\nlocations in space. Vertices play a crucial role in defining the geometry of objects\nand the connectivity between edges, facilitating accurate representation and\nmanipulation of 3D shapes. They hold coordinate information and are essential\nfor constructing complex structures like wires, faces, and solids."
        },
        {
            "name": "build123d.Wedge",
            "signature": "build123d.Wedge(xsize: 'float', ysize: 'float', zsize: 'float', xmin: 'float', zmin: 'float', xmax: 'float', zmax: 'float', rotation: 'RotationLike' = (0, 0, 0), align: 'Union[Align, tuple[Align, Align, Align]]' = (<Align.CENTER>, <Align.CENTER>, <Align.CENTER>), mode: 'Mode' = <Mode.ADD>)",
            "methods": [
                {
                    "name": "build123d.Wedge.bounding_box",
                    "signature": "build123d.Wedge.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Wedge.cast",
                    "signature": "build123d.Wedge.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Wedge.center",
                    "signature": "build123d.Wedge.center(self, center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "Return center of object\n\nFind center of object\n\nArgs:\n    center_of (CenterOf, optional): center option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: Center of GEOMETRY is not supported for this object\n    NotImplementedError: Unable to calculate center of mass of this object\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Wedge.chamfer",
                    "signature": "build123d.Wedge.chamfer(self, length: 'float', length2: 'Optional[float]', edge_list: 'Iterable[Edge]', face: 'Face' = None) -> 'Self'",
                    "docstring": "Chamfer\n\nChamfers the specified edges of this solid.\n\nArgs:\n    length (float): length > 0, the length (length) of the chamfer\n    length2 (Optional[float]): length2 > 0, optional parameter for asymmetrical\n        chamfer. Should be `None` if not required.\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to\n        this solid\n    face (Face): identifies the side where length is measured. The edge(s) must be\n        part of the face\n\nReturns:\n    Self:  Chamfered solid"
                },
                {
                    "name": "build123d.Wedge.clean",
                    "signature": "build123d.Wedge.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Wedge.closest_points",
                    "signature": "build123d.Wedge.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Wedge.combined_center",
                    "signature": "build123d.Wedge.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Wedge.compound",
                    "signature": "build123d.Wedge.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Wedge.compounds",
                    "signature": "build123d.Wedge.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Wedge.compute_mass",
                    "signature": "build123d.Wedge.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.copy",
                    "signature": "build123d.Wedge.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Wedge.copy_attributes_to",
                    "signature": "build123d.Wedge.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Wedge.cut",
                    "signature": "build123d.Wedge.cut(self, *to_cut: 'Shape') -> 'Compound'",
                    "docstring": "Remove a shape from another one\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.distance",
                    "signature": "build123d.Wedge.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.distance_to",
                    "signature": "build123d.Wedge.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Wedge.distance_to_with_closest_points",
                    "signature": "build123d.Wedge.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Wedge.distances",
                    "signature": "build123d.Wedge.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.do_children_intersect",
                    "signature": "build123d.Wedge.do_children_intersect(self, include_parent: 'bool' = False, tolerance: 'float' = 1e-05) -> 'tuple[bool, tuple[Shape, Shape], float]'",
                    "docstring": "Do Children Intersect\n\nDetermine if any of the child objects within a Compound/assembly intersect by\nintersecting each of the shapes with each other and checking for\na common volume.\n\nArgs:\n    include_parent (bool, optional): check parent for intersections. Defaults to False.\n    tolerance (float, optional): maximum allowable volume difference. Defaults to 1e-5.\n\nReturns:\n    tuple[bool, tuple[Shape, Shape], float]:\n        do the object intersect, intersecting objects, volume of intersection"
                },
                {
                    "name": "build123d.Wedge.dprism",
                    "signature": "build123d.Wedge.dprism(self, basis: 'Optional[Face]', bounds: 'list[Union[Face, Wire]]', depth: 'float' = None, taper: 'float' = 0, up_to_face: 'Face' = None, thru_all: 'bool' = True, additive: 'bool' = True) -> 'Solid'",
                    "docstring": "dprism\n\nMake a prismatic feature (additive or subtractive)\n\nArgs:\n    basis (Optional[Face]): face to perform the operation on\n    bounds (list[Union[Face,Wire]]): list of profiles\n    depth (float, optional): depth of the cut or extrusion. Defaults to None.\n    taper (float, optional): in degrees. Defaults to 0.\n    up_to_face (Face, optional): a face to extrude until. Defaults to None.\n    thru_all (bool, optional): cut thru_all. Defaults to True.\n    additive (bool, optional): Defaults to True.\n\nReturns:\n    Solid: prismatic feature"
                },
                {
                    "name": "build123d.Wedge.edge",
                    "signature": "build123d.Wedge.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Wedge.edges",
                    "signature": "build123d.Wedge.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Wedge.export_brep",
                    "signature": "build123d.Wedge.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.export_step",
                    "signature": "build123d.Wedge.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Wedge.export_stl",
                    "signature": "build123d.Wedge.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Wedge.extrude",
                    "signature": "build123d.Wedge.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Wedge.face",
                    "signature": "build123d.Wedge.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Wedge.faces",
                    "signature": "build123d.Wedge.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Wedge.faces_intersected_by_axis",
                    "signature": "build123d.Wedge.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Wedge.fillet",
                    "signature": "build123d.Wedge.fillet(self, radius: 'float', edge_list: 'Iterable[Edge]') -> 'Self'",
                    "docstring": "Fillet\n\nFillets the specified edges of this solid.\n\nArgs:\n    radius (float): float > 0, the radius of the fillet\n    edge_list (Iterable[Edge]): a list of Edge objects, which must belong to this solid\n\nReturns:\n    Any: Filleted solid"
                },
                {
                    "name": "build123d.Wedge.find_intersection",
                    "signature": "build123d.Wedge.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Wedge.find_intersection_points",
                    "signature": "build123d.Wedge.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Wedge.first_level_shapes",
                    "signature": "build123d.Wedge.first_level_shapes(self, _shapes: 'list[TopoDS_Shape]' = None) -> 'ShapeList[Shape]'",
                    "docstring": "first_level_shapes\n\nThis method iterates through the immediate children of the compound and\ncollects all non-compound shapes (e.g., vertices, edges, faces, solids).\nIf a child shape is itself a compound, the method recursively explores it,\nretrieving all first-level shapes within any nested compounds.\n\nNote: the _shapes parameter is not to be assigned by the user.\n\nReturns:\n    ShapeList[Shape]: Shapes contained within the Compound"
                },
                {
                    "name": "build123d.Wedge.fix",
                    "signature": "build123d.Wedge.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Wedge.fuse",
                    "signature": "build123d.Wedge.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Compound'",
                    "docstring": "Fuse shapes together\n\nArgs:\n  *to_fuse: Shape:\n  glue: bool:  (Default value = False)\n  tol: float:  (Default value = None)\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.get_type",
                    "signature": "build123d.Wedge.get_type(self, obj_type: 'Union[Type[Vertex], Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]]') -> 'list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]'",
                    "docstring": "get_type\n\nExtract the objects of the given type from a Compound. Note that this\nisn't the same as Faces() etc. which will extract Faces from Solids.\n\nArgs:\n    obj_type (Union[Vertex, Edge, Face, Shell, Solid, Wire]): Object types to extract\n\nReturns:\n    list[Union[Vertex, Edge, Face, Shell, Solid, Wire]]: Extracted objects"
                },
                {
                    "name": "build123d.Wedge.hash_code",
                    "signature": "build123d.Wedge.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.hollow",
                    "signature": "build123d.Wedge.hollow(self, faces: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Hollow\n\nReturn the outer shelled solid of self.\n\nArgs:\n    faces (Optional[Iterable[Face]]): faces to be removed,\n    which must be part of the solid. Can be an empty list.\n    thickness (float): shell thickness - positive shells outwards, negative\n        shells inwards.\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A hollow solid."
                },
                {
                    "name": "build123d.Wedge.intersect",
                    "signature": "build123d.Wedge.intersect(self, *to_intersect: 'Shape') -> 'Compound'",
                    "docstring": "Construct shape intersection\n\nArgs:\n  *to_intersect: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.is_equal",
                    "signature": "build123d.Wedge.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.is_inside",
                    "signature": "build123d.Wedge.is_inside(self, point: 'VectorLike', tolerance: 'float' = 1e-06) -> 'bool'",
                    "docstring": "Returns whether or not the point is inside a solid or compound\nobject within the specified tolerance.\n\nArgs:\n  point: tuple or Vector representing 3D point to be tested\n  tolerance: tolerance for inside determination, default=1.0e-6\n  point: VectorLike:\n  tolerance: float:  (Default value = 1.0e-6)\n\nReturns:\n  bool indicating whether or not point is within solid"
                },
                {
                    "name": "build123d.Wedge.is_null",
                    "signature": "build123d.Wedge.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.is_same",
                    "signature": "build123d.Wedge.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.is_valid",
                    "signature": "build123d.Wedge.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.iter_path_reverse",
                    "signature": "build123d.Wedge.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Wedge.locate",
                    "signature": "build123d.Wedge.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.located",
                    "signature": "build123d.Wedge.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Wedge.make_compound",
                    "signature": "build123d.Wedge.make_compound(shapes: 'Iterable[Shape]') -> 'Compound'",
                    "docstring": "Create a compound out of a list of shapes\nArgs:\n  shapes: Iterable[Shape]:\nReturns:"
                },
                {
                    "name": "build123d.Wedge.make_text",
                    "signature": "build123d.Wedge.make_text(txt: 'str', font_size: 'float', font: 'str' = 'Arial', font_path: 'Optional[str]' = None, font_style: 'FontStyle' = <FontStyle.REGULAR>, align: 'Union[Align, tuple[Align, Align]]' = (<Align.CENTER>, <Align.CENTER>), position_on_path: 'float' = 0.0, text_path: 'Union[Edge, Wire]' = None) -> \"'Compound'\"",
                    "docstring": "2D Text that optionally follows a path.\n\nThe text that is created can be combined as with other sketch features by specifying\na mode or rotated by the given angle.  In addition, edges have been previously created\nwith arc or segment, the text will follow the path defined by these edges. The start\nparameter can be used to shift the text along the path to achieve precise positioning.\n\nArgs:\n    txt: text to be rendered\n    font_size: size of the font in model units\n    font: font name\n    font_path: path to font file\n    font_style: text style. Defaults to FontStyle.REGULAR.\n    align (Union[Align, tuple[Align, Align]], optional): align min, center, or max\n        of object. Defaults to (Align.CENTER, Align.CENTER).\n    position_on_path: the relative location on path to position the text,\n        between 0.0 and 1.0. Defaults to 0.0.\n    text_path: a path for the text to follows. Defaults to None - linear text.\n\nReturns:\n    a Compound object containing multiple Faces representing the text\n\nExamples::\n\n    fox = Compound.make_text(\n        txt=\"The quick brown fox jumped over the lazy dog\",\n        font_size=10,\n        position_on_path=0.1,\n        text_path=jump_edge,\n    )"
                },
                {
                    "name": "build123d.Wedge.make_triad",
                    "signature": "build123d.Wedge.make_triad(axes_scale: 'float') -> 'Compound'",
                    "docstring": "The coordinate system triad (X, Y, Z axes)"
                },
                {
                    "name": "build123d.Wedge.max_fillet",
                    "signature": "build123d.Wedge.max_fillet(self, edge_list: 'Iterable[Edge]', tolerance=0.1, max_iterations: 'int' = 10) -> 'float'",
                    "docstring": "Find Maximum Fillet Size\n\nFind the largest fillet radius for the given Shape and edges with a\nrecursive binary search.\n\nExample:\n\n      max_fillet_radius = my_shape.max_fillet(shape_edges)\n      max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)\n\n\nArgs:\n    edge_list (Iterable[Edge]): a sequence of Edge objects, which must belong to this solid\n    tolerance (float, optional): maximum error from actual value. Defaults to 0.1.\n    max_iterations (int, optional): maximum number of recursive iterations. Defaults to 10.\n\nRaises:\n    RuntimeError: failed to find the max value\n    ValueError: the provided Shape is invalid\n\nReturns:\n    float: maximum fillet radius"
                },
                {
                    "name": "build123d.Wedge.mesh",
                    "signature": "build123d.Wedge.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.mirror",
                    "signature": "build123d.Wedge.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Wedge.move",
                    "signature": "build123d.Wedge.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.moved",
                    "signature": "build123d.Wedge.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Wedge.offset_3d",
                    "signature": "build123d.Wedge.offset_3d(self, openings: 'Optional[Iterable[Face]]', thickness: 'float', tolerance: 'float' = 0.0001, kind: 'Kind' = <Kind.ARC>) -> 'Solid'",
                    "docstring": "Shell\n\nMake an offset solid of self.\n\nArgs:\n    openings (Optional[Iterable[Face]]): faces to be removed,\n        which must be part of the solid. Can be an empty list.\n    thickness (float): offset amount - positive offset outwards, negative inwards\n    tolerance (float, optional): modelling tolerance of the method. Defaults to 0.0001.\n    kind (Kind, optional): intersection type. Defaults to Kind.ARC.\n\nRaises:\n    ValueError: Kind.TANGENT not supported\n\nReturns:\n    Solid: A shelled solid."
                },
                {
                    "name": "build123d.Wedge.project_faces",
                    "signature": "build123d.Wedge.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Wedge.project_to_viewport",
                    "signature": "build123d.Wedge.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Wedge.relocate",
                    "signature": "build123d.Wedge.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Wedge.rotate",
                    "signature": "build123d.Wedge.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Wedge.scale",
                    "signature": "build123d.Wedge.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.shape_type",
                    "signature": "build123d.Wedge.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Wedge.shell",
                    "signature": "build123d.Wedge.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Wedge.shells",
                    "signature": "build123d.Wedge.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Wedge.show_topology",
                    "signature": "build123d.Wedge.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Wedge.solid",
                    "signature": "build123d.Wedge.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Wedge.solids",
                    "signature": "build123d.Wedge.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Wedge.split",
                    "signature": "build123d.Wedge.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Wedge.split_by_perimeter",
                    "signature": "build123d.Wedge.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Wedge.tessellate",
                    "signature": "build123d.Wedge.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Wedge.to_arcs",
                    "signature": "build123d.Wedge.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Wedge.to_splines",
                    "signature": "build123d.Wedge.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Wedge.to_vtk_poly_data",
                    "signature": "build123d.Wedge.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Wedge.transform_geometry",
                    "signature": "build123d.Wedge.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Wedge.transform_shape",
                    "signature": "build123d.Wedge.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Wedge.transformed",
                    "signature": "build123d.Wedge.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Wedge.translate",
                    "signature": "build123d.Wedge.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Wedge.unwrap",
                    "signature": "build123d.Wedge.unwrap(self, fully: 'bool' = True) -> 'Union[Self, Shape]'",
                    "docstring": "Strip unnecessary Compound wrappers\n\nArgs:\n    fully (bool, optional): return base shape without any Compound\n        wrappers (otherwise one Compound is left). Defaults to True.\n\nReturns:\n    Union[Self, Shape]: base shape"
                },
                {
                    "name": "build123d.Wedge.vertex",
                    "signature": "build123d.Wedge.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Wedge.vertices",
                    "signature": "build123d.Wedge.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Wedge.wire",
                    "signature": "build123d.Wedge.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Wedge.wires",
                    "signature": "build123d.Wedge.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "Part Object: Wedge\n\nCreate a wedge(s) and combine with part.\n\nArgs:\n    xsize (float): distance along the X axis\n    ysize (float): distance along the Y axis\n    zsize (float): distance along the Z axis\n    xmin (float): minimum X location\n    zmin (float): minimum Z location\n    xmax (float): maximum X location\n    zmax (float): maximum Z location\n    rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).\n    align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,\n        or max of object. Defaults to (Align.CENTER, Align.CENTER, Align.CENTER).\n    mode (Mode, optional): combine mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.Wire",
            "signature": "build123d.Wire(*args, **kwargs)",
            "methods": [
                {
                    "name": "build123d.Wire.bounding_box",
                    "signature": "build123d.Wire.bounding_box(self, tolerance: 'float' = None, optimal: 'bool' = True) -> 'BoundBox'",
                    "docstring": "Create a bounding box for this Shape.\n\nArgs:\n    tolerance (float, optional): Defaults to None.\n\nReturns:\n    BoundBox: A box sized to contain this Shape"
                },
                {
                    "name": "build123d.Wire.cast",
                    "signature": "build123d.Wire.cast(obj: 'TopoDS_Shape', for_construction: 'bool' = False) -> 'Self'",
                    "docstring": "Returns the right type of wrapper, given a OCCT object"
                },
                {
                    "name": "build123d.Wire.center",
                    "signature": "build123d.Wire.center(self, center_of: 'CenterOf' = <CenterOf.GEOMETRY>) -> 'Vector'",
                    "docstring": "Center of object\n\nReturn the center based on center_of\n\nArgs:\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.\n\nReturns:\n    Vector: center"
                },
                {
                    "name": "build123d.Wire.chamfer_2d",
                    "signature": "build123d.Wire.chamfer_2d(self, distance: 'float', distance2: 'float', vertices: 'Iterable[Vertex]', edge: 'Edge' = None) -> 'Wire'",
                    "docstring": "chamfer_2d\n\nApply 2D chamfer to a wire\n\nArgs:\n    distance (float): chamfer length\n    distance2 (float): chamfer length\n    vertices (Iterable[Vertex]): vertices to chamfer\n    edge (Edge): identifies the side where length is measured. The vertices must be\n        part of the edge\n\nReturns:\n    Wire: chamfered wire"
                },
                {
                    "name": "build123d.Wire.clean",
                    "signature": "build123d.Wire.clean(self) -> 'Self'",
                    "docstring": "clean\n\nRemove internal edges\n\nReturns:\n    Shape: Original object with extraneous internal edges removed"
                },
                {
                    "name": "build123d.Wire.close",
                    "signature": "build123d.Wire.close(self) -> 'Wire'",
                    "docstring": "Close a Wire"
                },
                {
                    "name": "build123d.Wire.closest_points",
                    "signature": "build123d.Wire.closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[Vector, Vector]'",
                    "docstring": "Points on two shapes where the distance between them is minimal"
                },
                {
                    "name": "build123d.Wire.combine",
                    "signature": "build123d.Wire.combine(wires: 'Iterable[Union[Wire, Edge]]', tol: 'float' = 1e-09) -> 'ShapeList[Wire]'",
                    "docstring": "combine\n\nCombine a list of wires and edges into a list of Wires.\n\nArgs:\n    wires (Iterable[Union[Wire, Edge]]): unsorted\n    tol (float, optional): tolerance. Defaults to 1e-9.\n\nReturns:\n    ShapeList[Wire]: Wires"
                },
                {
                    "name": "build123d.Wire.combined_center",
                    "signature": "build123d.Wire.combined_center(objects: 'Iterable[Shape]', center_of: 'CenterOf' = <CenterOf.MASS>) -> 'Vector'",
                    "docstring": "combined center\n\nCalculates the center of a multiple objects.\n\nArgs:\n    objects (Iterable[Shape]): list of objects\n    center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.\n\nRaises:\n    ValueError: CenterOf.GEOMETRY not implemented\n\nReturns:\n    Vector: center of multiple objects"
                },
                {
                    "name": "build123d.Wire.common_plane",
                    "signature": "build123d.Wire.common_plane(self, *lines: 'Union[Edge, Wire]') -> 'Union[None, Plane]'",
                    "docstring": "common_plane\n\nFind the plane containing all the edges/wires (including self). If there\nis no common plane return None. If the edges are coaxial, select one\nof the infinite number of valid planes.\n\nArgs:\n    lines (sequence of Union[Edge,Wire]): edges in common with self\n\nReturns:\n    Union[None, Plane]: Either the common plane or None"
                },
                {
                    "name": "build123d.Wire.compound",
                    "signature": "build123d.Wire.compound(self) -> 'Compound'",
                    "docstring": "Return the Compound"
                },
                {
                    "name": "build123d.Wire.compounds",
                    "signature": "build123d.Wire.compounds(self) -> 'ShapeList[Compound]'",
                    "docstring": "compounds - all the compounds in this Shape"
                },
                {
                    "name": "build123d.Wire.compute_mass",
                    "signature": "build123d.Wire.compute_mass(obj: 'Shape') -> 'float'",
                    "docstring": "Calculates the 'mass' of an object.\n\nArgs:\n  obj: Compute the mass of this object\n  obj: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.copy",
                    "signature": "build123d.Wire.copy(self) -> 'Self'",
                    "docstring": "Here for backwards compatibility with cq-editor"
                },
                {
                    "name": "build123d.Wire.copy_attributes_to",
                    "signature": "build123d.Wire.copy_attributes_to(self, target: 'Shape', exceptions: 'Iterable[str]' = None)",
                    "docstring": "Copy common object attributes to target\n\nNote that preset attributes of target will not be overridden.\n\nArgs:\n    target (Shape): object to gain attributes\n    exceptions (Iterable[str], optional): attributes not to copy\n\nRaises:\n    ValueError: invalid attribute"
                },
                {
                    "name": "build123d.Wire.cut",
                    "signature": "build123d.Wire.cut(self, *to_cut: 'Shape') -> 'Self'",
                    "docstring": "Remove the positional arguments from this Shape.\n\nArgs:\n  *to_cut: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.distance",
                    "signature": "build123d.Wire.distance(self, other: 'Shape') -> 'float'",
                    "docstring": "Minimal distance between two shapes\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.distance_to",
                    "signature": "build123d.Wire.distance_to(self, other: 'Union[Shape, VectorLike]') -> 'float'",
                    "docstring": "Minimal distance between two shapes"
                },
                {
                    "name": "build123d.Wire.distance_to_with_closest_points",
                    "signature": "build123d.Wire.distance_to_with_closest_points(self, other: 'Union[Shape, VectorLike]') -> 'tuple[float, Vector, Vector]'",
                    "docstring": "Minimal distance between two shapes and the points on each shape"
                },
                {
                    "name": "build123d.Wire.distances",
                    "signature": "build123d.Wire.distances(self, *others: 'Shape') -> 'Iterator[float]'",
                    "docstring": "Minimal distances to between self and other shapes\n\nArgs:\n  *others: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.edge",
                    "signature": "build123d.Wire.edge(self) -> 'Edge'",
                    "docstring": "Return the Edge"
                },
                {
                    "name": "build123d.Wire.edges",
                    "signature": "build123d.Wire.edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "edges - all the edges in this Shape"
                },
                {
                    "name": "build123d.Wire.end_point",
                    "signature": "build123d.Wire.end_point(self) -> 'Vector'",
                    "docstring": "The end point of this edge.\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Wire.export_brep",
                    "signature": "build123d.Wire.export_brep(self, file: 'Union[str, BytesIO]') -> 'bool'",
                    "docstring": "Export this shape to a BREP file\n\nArgs:\n    file: Union[str, BytesIO]:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.export_step",
                    "signature": "build123d.Wire.export_step(self, file_name: 'str', **kwargs) -> 'IFSelect_ReturnStatus'",
                    "docstring": "Export this shape to a STEP file.\n\nkwargs is used to provide optional keyword arguments to configure the exporter.\n\nArgs:\n    file_name (str): Path and filename for writing.\n    kwargs: used to provide optional keyword arguments to configure the exporter.\n\nReturns:\n    IFSelect_ReturnStatus: OCCT return status"
                },
                {
                    "name": "build123d.Wire.export_stl",
                    "signature": "build123d.Wire.export_stl(self, file_name: 'str', tolerance: 'float' = 0.001, angular_tolerance: 'float' = 0.1, ascii_format: 'bool' = False) -> 'bool'",
                    "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    file_name (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
                },
                {
                    "name": "build123d.Wire.extrude",
                    "signature": "build123d.Wire.extrude(obj: 'Union[Vertex, Edge, Wire, Face, Shell]', direction: 'VectorLike') -> 'Self'",
                    "docstring": "extrude\n\nExtrude a Shape in the provided direction.\n* Vertices generate Edges\n* Edges generate Faces\n* Wires generate Shells\n* Faces generate Solids\n* Shells generate Compounds\n\nArgs:\n    direction (VectorLike): direction and magnitude of extrusion\n\nRaises:\n    ValueError: Unsupported class\n    RuntimeError: Generated invalid result\n\nReturns:\n    Union[Edge, Face, Shell, Solid, Compound]: extruded shape"
                },
                {
                    "name": "build123d.Wire.face",
                    "signature": "build123d.Wire.face(self) -> 'Face'",
                    "docstring": "Return the Face"
                },
                {
                    "name": "build123d.Wire.faces",
                    "signature": "build123d.Wire.faces(self) -> 'ShapeList[Face]'",
                    "docstring": "faces - all the faces in this Shape"
                },
                {
                    "name": "build123d.Wire.faces_intersected_by_axis",
                    "signature": "build123d.Wire.faces_intersected_by_axis(self, axis: 'Axis', tol: 'float' = 0.0001) -> 'ShapeList[Face]'",
                    "docstring": "Line Intersection\n\nComputes the intersections between the provided axis and the faces of this Shape\n\nArgs:\n    axis (Axis): Axis on which the intersection line rests\n    tol (float, optional): Intersection tolerance. Defaults to 1e-4.\n\nReturns:\n    list[Face]: A list of intersected faces sorted by distance from axis.position"
                },
                {
                    "name": "build123d.Wire.fillet_2d",
                    "signature": "build123d.Wire.fillet_2d(self, radius: 'float', vertices: 'Iterable[Vertex]') -> 'Wire'",
                    "docstring": "fillet_2d\n\nApply 2D fillet to a wire\n\nArgs:\n    radius (float):\n    vertices (Iterable[Vertex]): vertices to fillet\n\nReturns:\n    Wire: filleted wire"
                },
                {
                    "name": "build123d.Wire.find_intersection",
                    "signature": "build123d.Wire.find_intersection(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "No docstring available."
                },
                {
                    "name": "build123d.Wire.find_intersection_points",
                    "signature": "build123d.Wire.find_intersection_points(self, axis: 'Axis') -> 'list[tuple[Vector, Vector]]'",
                    "docstring": "Find point and normal at intersection\n\nReturn both the point(s) and normal(s) of the intersection of the axis and the shape\n\nArgs:\n    axis (Axis): axis defining the intersection line\n\nReturns:\n    list[tuple[Vector, Vector]]: Point and normal of intersection"
                },
                {
                    "name": "build123d.Wire.fix",
                    "signature": "build123d.Wire.fix(self) -> 'Self'",
                    "docstring": "fix - try to fix shape if not valid"
                },
                {
                    "name": "build123d.Wire.fix_degenerate_edges",
                    "signature": "build123d.Wire.fix_degenerate_edges(self, precision: 'float') -> 'Wire'",
                    "docstring": "fix_degenerate_edges\n\nFix a Wire that contains degenerate (very small) edges\n\nArgs:\n    precision (float): minimum value edge length\n\nReturns:\n    Wire: fixed wire"
                },
                {
                    "name": "build123d.Wire.fuse",
                    "signature": "build123d.Wire.fuse(self, *to_fuse: 'Shape', glue: 'bool' = False, tol: 'float' = None) -> 'Self'",
                    "docstring": "fuse\n\nFuse a sequence of shapes into a single shape.\n\nArgs:\n    to_fuse (sequence Shape): shapes to fuse\n    glue (bool, optional): performance improvement for some shapes. Defaults to False.\n    tol (float, optional): tolerance. Defaults to None.\n\nReturns:\n    Shape: fused shape"
                },
                {
                    "name": "build123d.Wire.hash_code",
                    "signature": "build123d.Wire.hash_code(self) -> 'int'",
                    "docstring": "Returns a hashed value denoting this shape. It is computed from the\nTShape and the Location. The Orientation is not used.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.intersect",
                    "signature": "build123d.Wire.intersect(self, *to_intersect: 'Union[Shape, Axis, Plane]') -> 'Shape'",
                    "docstring": "Intersection of the arguments and this shape\n\nArgs:\n    to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to\n        intersect with\n\nReturns:\n    Shape: Resulting object may be of a different class than self"
                },
                {
                    "name": "build123d.Wire.is_equal",
                    "signature": "build123d.Wire.is_equal(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if two shapes are equal, i.e. if they share the same\nTShape with the same Locations and Orientations. Also see\n:py:meth:`is_same`.\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.is_null",
                    "signature": "build123d.Wire.is_null(self) -> 'bool'",
                    "docstring": "Returns true if this shape is null. In other words, it references no\nunderlying shape with the potential to be given a location and an\norientation.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.is_same",
                    "signature": "build123d.Wire.is_same(self, other: 'Shape') -> 'bool'",
                    "docstring": "Returns True if other and this shape are same, i.e. if they share the\nsame TShape with the same Locations. Orientations may differ. Also see\n:py:meth:`is_equal`\n\nArgs:\n  other: Shape:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.is_valid",
                    "signature": "build123d.Wire.is_valid(self) -> 'bool'",
                    "docstring": "Returns True if no defect is detected on the shape S or any of its\nsubshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full\ndescription of what is checked.\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.iter_path_reverse",
                    "signature": "build123d.Wire.iter_path_reverse(self)",
                    "docstring": "Iterate up the tree from the current node to the root node.\n\n>>> from anytree import Node\n>>> udo = Node(\"Udo\")\n>>> marc = Node(\"Marc\", parent=udo)\n>>> lian = Node(\"Lian\", parent=marc)\n>>> for node in udo.iter_path_reverse():\n...     print(node)\nNode('/Udo')\n>>> for node in marc.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc')\nNode('/Udo')\n>>> for node in lian.iter_path_reverse():\n...     print(node)\nNode('/Udo/Marc/Lian')\nNode('/Udo/Marc')\nNode('/Udo')"
                },
                {
                    "name": "build123d.Wire.locate",
                    "signature": "build123d.Wire.locate(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in absolute sense to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.located",
                    "signature": "build123d.Wire.located(self, loc: 'Location') -> 'Self'",
                    "docstring": "located\n\nApply a location in absolute sense to a copy of self\n\nArgs:\n    loc (Location): new absolute location\n\nReturns:\n    Shape: copy of Shape at location"
                },
                {
                    "name": "build123d.Wire.location_at",
                    "signature": "build123d.Wire.location_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'Location'",
                    "docstring": "Locations along curve\n\nGenerate a location along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    Location: A Location object representing local coordinate system\n        at the specified distance."
                },
                {
                    "name": "build123d.Wire.locations",
                    "signature": "build123d.Wire.locations(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>, frame_method: 'FrameMethod' = <FrameMethod.FRENET>, planar: 'bool' = False) -> 'list[Location]'",
                    "docstring": "Locations along curve\n\nGenerate location along the curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    frame_method (FrameMethod, optional): moving frame calculation method.\n        Defaults to FrameMethod.FRENET.\n    planar (bool, optional): planar mode. Defaults to False.\n\nReturns:\n    list[Location]: A list of Location objects representing local coordinate\n        systems at the specified distances."
                },
                {
                    "name": "build123d.Wire.make_circle",
                    "signature": "build123d.Wire.make_circle(radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Wire'",
                    "docstring": "make_circle\n\nMakes a circle centered at the origin of plane\n\nArgs:\n    radius (float): circle radius\n    plane (Plane): base plane. Defaults to Plane.XY\n\nReturns:\n    Wire: a circle"
                },
                {
                    "name": "build123d.Wire.make_convex_hull",
                    "signature": "build123d.Wire.make_convex_hull(edges: 'Iterable[Edge]', tolerance: 'float' = 0.001) -> 'Wire'",
                    "docstring": "make_convex_hull\n\nCreate a wire of minimum length enclosing all of the provided edges.\n\nNote that edges can't overlap each other.\n\nArgs:\n    edges (Iterable[Edge]): edges defining the convex hull\n    tolerance (float): allowable error as a fraction of each edge length.\n        Defaults to 1e-3.\n\nRaises:\n    ValueError: edges overlap\n\nReturns:\n    Wire: convex hull perimeter"
                },
                {
                    "name": "build123d.Wire.make_ellipse",
                    "signature": "build123d.Wire.make_ellipse(x_radius: 'float', y_radius: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00)), start_angle: 'float' = 360.0, end_angle: 'float' = 360.0, angular_direction: 'AngularDirection' = <AngularDirection.COUNTER_CLOCKWISE>, closed: 'bool' = True) -> 'Wire'",
                    "docstring": "make ellipse\n\nMakes an ellipse centered at the origin of plane.\n\nArgs:\n    x_radius (float): x radius of the ellipse (along the x-axis of plane)\n    y_radius (float): y radius of the ellipse (along the y-axis of plane)\n    plane (Plane, optional): base plane. Defaults to Plane.XY.\n    start_angle (float, optional): _description_. Defaults to 360.0.\n    end_angle (float, optional): _description_. Defaults to 360.0.\n    angular_direction (AngularDirection, optional): arc direction.\n        Defaults to AngularDirection.COUNTER_CLOCKWISE.\n    closed (bool, optional): close the arc. Defaults to True.\n\nReturns:\n    Wire: an ellipse"
                },
                {
                    "name": "build123d.Wire.make_polygon",
                    "signature": "build123d.Wire.make_polygon(vertices: 'Iterable[VectorLike]', close: 'bool' = True) -> 'Wire'",
                    "docstring": "make_polygon\n\nCreate an irregular polygon by defining vertices\n\nArgs:\n    vertices (Iterable[VectorLike]):\n    close (bool, optional): close the polygon. Defaults to True.\n\nReturns:\n    Wire: an irregular polygon"
                },
                {
                    "name": "build123d.Wire.make_rect",
                    "signature": "build123d.Wire.make_rect(width: 'float', height: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Wire'",
                    "docstring": "Make Rectangle\n\nMake a Rectangle centered on center with the given normal\n\nArgs:\n    width (float): width (local x)\n    height (float): height (local y)\n    plane (Plane, optional): plane containing rectangle. Defaults to Plane.XY.\n\nReturns:\n    Wire: The centered rectangle"
                },
                {
                    "name": "build123d.Wire.make_wire",
                    "signature": "build123d.Wire.make_wire(edges: 'Iterable[Edge]', sequenced: 'bool' = False) -> 'Wire'",
                    "docstring": "make_wire\n\nBuild a Wire from the provided unsorted Edges. If sequenced is True the\nEdges are placed in such that the end of the nth Edge is coincident with\nthe n+1th Edge forming an unbroken sequence. Note that sequencing a list\nis relatively slow.\n\nArgs:\n    edges (Iterable[Edge]): Edges to assemble\n    sequenced (bool, optional): arrange in order. Defaults to False.\n\nRaises:\n    ValueError: Edges are disconnected and can't be sequenced.\n    RuntimeError: Wire is empty\n\nReturns:\n    Wire: assembled edges"
                },
                {
                    "name": "build123d.Wire.mesh",
                    "signature": "build123d.Wire.mesh(self, tolerance: 'float', angular_tolerance: 'float' = 0.1)",
                    "docstring": "Generate triangulation if none exists.\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.mirror",
                    "signature": "build123d.Wire.mirror(self, mirror_plane: 'Plane' = None) -> 'Self'",
                    "docstring": "Applies a mirror transform to this Shape. Does not duplicate objects\nabout the plane.\n\nArgs:\n  mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY\nReturns:\n  The mirrored shape"
                },
                {
                    "name": "build123d.Wire.move",
                    "signature": "build123d.Wire.move(self, loc: 'Location') -> 'Self'",
                    "docstring": "Apply a location in relative sense (i.e. update current location) to self\n\nArgs:\n  loc: Location:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.moved",
                    "signature": "build123d.Wire.moved(self, loc: 'Location') -> 'Self'",
                    "docstring": "moved\n\nApply a location in relative sense (i.e. update current location) to a copy of self\n\nArgs:\n    loc (Location): new location relative to current location\n\nReturns:\n    Shape: copy of Shape moved to relative location"
                },
                {
                    "name": "build123d.Wire.normal",
                    "signature": "build123d.Wire.normal(self) -> 'Vector'",
                    "docstring": "Calculate the normal Vector. Only possible for planar curves.\n\n:return: normal vector\n\nArgs:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.offset_2d",
                    "signature": "build123d.Wire.offset_2d(self, distance: 'float', kind: 'Kind' = <Kind.ARC>, side: 'Side' = <Side.BOTH>, closed: 'bool' = True) -> 'Union[Edge, Wire]'",
                    "docstring": "2d Offset\n\nOffsets a planar edge/wire\n\nArgs:\n    distance (float): distance from edge/wire to offset\n    kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\nRaises:\n    RuntimeError: Multiple Wires generated\n    RuntimeError: Unexpected result type\n\nReturns:\n    Wire: offset wire"
                },
                {
                    "name": "build123d.Wire.order_edges",
                    "signature": "build123d.Wire.order_edges(self) -> 'ShapeList[Edge]'",
                    "docstring": "Return the edges in self ordered by wire direction and orientation"
                },
                {
                    "name": "build123d.Wire.param_at",
                    "signature": "build123d.Wire.param_at(self, distance: 'float') -> 'float'",
                    "docstring": "Parameter along a curve\n\nCompute parameter value at the specified normalized distance.\n\nArgs:\n    d (float): normalized distance (0.0 >= d >= 1.0)\n\nReturns:\n    float: parameter value"
                },
                {
                    "name": "build123d.Wire.param_at_point",
                    "signature": "build123d.Wire.param_at_point(self, point: 'VectorLike') -> 'float'",
                    "docstring": "Parameter at point on Wire"
                },
                {
                    "name": "build123d.Wire.perpendicular_line",
                    "signature": "build123d.Wire.perpendicular_line(self, length: 'float', u_value: 'float', plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'Edge'",
                    "docstring": "perpendicular_line\n\nCreate a line on the given plane perpendicular to and centered on beginning of self\n\nArgs:\n    length (float): line length\n    u_value (float): position along line between 0.0 and 1.0\n    plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.\n\nReturns:\n    Edge: perpendicular line"
                },
                {
                    "name": "build123d.Wire.position_at",
                    "signature": "build123d.Wire.position_at(self, distance: 'float', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "Position At\n\nGenerate a position along the underlying curve.\n\nArgs:\n    distance (float): distance or parameter value\n    position_mode (PositionMode, optional): position calculation mode. Defaults to\n        PositionMode.PARAMETER.\n\nReturns:\n    Vector: position on the underlying curve"
                },
                {
                    "name": "build123d.Wire.positions",
                    "signature": "build123d.Wire.positions(self, distances: 'Iterable[float]', position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'list[Vector]'",
                    "docstring": "Positions along curve\n\nGenerate positions along the underlying curve\n\nArgs:\n    distances (Iterable[float]): distance or parameter values\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nReturns:\n    list[Vector]: positions along curve"
                },
                {
                    "name": "build123d.Wire.project",
                    "signature": "build123d.Wire.project(self, face: 'Face', direction: 'VectorLike', closest: 'bool' = True) -> 'Union[Mixin1D, list[Mixin1D]]'",
                    "docstring": "Project onto a face along the specified direction\n\nArgs:\n  face: Face:\n  direction: VectorLike:\n  closest: bool:  (Default value = True)\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.project_faces",
                    "signature": "build123d.Wire.project_faces(self, faces: 'Union[list[Face], Compound]', path: 'Union[Wire, Edge]', start: 'float' = 0) -> 'Compound'",
                    "docstring": "Projected Faces following the given path on Shape\n\nProject by positioning each face of to the shape along the path and\nprojecting onto the surface.\n\nNote that projection may result in distortion depending on\nthe shape at a position along the path.\n\n.. image:: projectText.png\n\nArgs:\n    faces (Union[list[Face], Compound]): faces to project\n    path: Path on the Shape to follow\n    start: Relative location on path to start the faces. Defaults to 0.\n\nReturns:\n    The projected faces"
                },
                {
                    "name": "build123d.Wire.project_to_shape",
                    "signature": "build123d.Wire.project_to_shape(self, target_object: 'Shape', direction: 'VectorLike' = None, center: 'VectorLike' = None) -> 'list[Wire]'",
                    "docstring": "Project Wire\n\nProject a Wire onto a Shape generating new wires on the surfaces of the object\none and only one of `direction` or `center` must be provided. Note that one or\nmore wires may be generated depending on the topology of the target object and\nlocation/direction of projection.\n\nTo avoid flipping the normal of a face built with the projected wire the orientation\nof the output wires are forced to be the same as self.\n\nArgs:\n  target_object: Object to project onto\n  direction: Parallel projection direction. Defaults to None.\n  center: Conical center of projection. Defaults to None.\n  target_object: Shape:\n  direction: VectorLike:  (Default value = None)\n  center: VectorLike:  (Default value = None)\n\nReturns:\n  : Projected wire(s)\n\nRaises:\n  ValueError: Only one of direction or center must be provided"
                },
                {
                    "name": "build123d.Wire.project_to_viewport",
                    "signature": "build123d.Wire.project_to_viewport(self, viewport_origin: 'VectorLike', viewport_up: 'VectorLike' = (0, 0, 1), look_at: 'VectorLike' = None) -> 'tuple[ShapeList[Edge], ShapeList[Edge]]'",
                    "docstring": "project_to_viewport\n\nProject a shape onto a viewport returning visible and hidden Edges.\n\nArgs:\n    viewport_origin (VectorLike): location of viewport\n    viewport_up (VectorLike, optional): direction of the viewport y axis.\n        Defaults to (0, 0, 1).\n    look_at (VectorLike, optional): point to look at.\n        Defaults to None (center of shape).\n\nReturns:\n    tuple[ShapeList[Edge],ShapeList[Edge]]: visible & hidden Edges"
                },
                {
                    "name": "build123d.Wire.relocate",
                    "signature": "build123d.Wire.relocate(self, loc: 'Location')",
                    "docstring": "Change the location of self while keeping it geometrically similar\n\nArgs:\n    loc (Location): new location to set for self"
                },
                {
                    "name": "build123d.Wire.rotate",
                    "signature": "build123d.Wire.rotate(self, axis: 'Axis', angle: 'float') -> 'Self'",
                    "docstring": "rotate a copy\n\nRotates a shape around an axis.\n\nArgs:\n    axis (Axis): rotation Axis\n    angle (float): angle to rotate, in degrees\n\nReturns:\n    a copy of the shape, rotated"
                },
                {
                    "name": "build123d.Wire.scale",
                    "signature": "build123d.Wire.scale(self, factor: 'float') -> 'Self'",
                    "docstring": "Scales this shape through a transformation.\n\nArgs:\n  factor: float:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.shape_type",
                    "signature": "build123d.Wire.shape_type(self) -> 'Shapes'",
                    "docstring": "Return the shape type string for this class"
                },
                {
                    "name": "build123d.Wire.shell",
                    "signature": "build123d.Wire.shell(self) -> 'Shell'",
                    "docstring": "Return the Shell"
                },
                {
                    "name": "build123d.Wire.shells",
                    "signature": "build123d.Wire.shells(self) -> 'ShapeList[Shell]'",
                    "docstring": "shells - all the shells in this Shape"
                },
                {
                    "name": "build123d.Wire.show_topology",
                    "signature": "build123d.Wire.show_topology(self, limit_class: \"Literal['Compound', 'Edge', 'Face', 'Shell', 'Solid', 'Vertex', 'Wire']\" = 'Vertex', show_center: 'bool' = None) -> 'str'",
                    "docstring": "Display internal topology\n\nDisplay the internal structure of a Compound 'assembly' or Shape. Example:\n\n.. code::\n\n    >>> c1.show_topology()\n\n    c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))\n    \u251c\u2500\u2500                    Solid    at 0x7f4a4cafafd0, Location(...))\n    \u251c\u2500\u2500 c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))\n    \u2502   \u251c\u2500\u2500                Solid    at 0x7f4a4cafad00, Location(...))\n    \u2502   \u2514\u2500\u2500                Solid    at 0x7f4a11a52790, Location(...))\n    \u2514\u2500\u2500 c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))\n        \u251c\u2500\u2500                Solid    at 0x7f4a11a52700, Location(...))\n        \u2514\u2500\u2500                Solid    at 0x7f4a11a58550, Location(...))\n\nArgs:\n    limit_class: type of displayed leaf node. Defaults to 'Vertex'.\n    show_center (bool, optional): If None, shows the Location of Compound 'assemblies'\n        and the bounding box center of Shapes. True or False forces the display.\n        Defaults to None.\n\nReturns:\n    str: tree representation of internal structure"
                },
                {
                    "name": "build123d.Wire.solid",
                    "signature": "build123d.Wire.solid(self) -> 'Solid'",
                    "docstring": "Return the Solid"
                },
                {
                    "name": "build123d.Wire.solids",
                    "signature": "build123d.Wire.solids(self) -> 'ShapeList[Solid]'",
                    "docstring": "solids - all the solids in this Shape"
                },
                {
                    "name": "build123d.Wire.split",
                    "signature": "build123d.Wire.split(self, tool: 'TrimmingTool', keep: 'Keep' = <Keep.TOP>) -> 'Self'",
                    "docstring": "split\n\nSplit this shape by the provided plane or face.\n\nArgs:\n    surface (Union[Plane,Face]): surface to segment shape\n    keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.\n\nReturns:\n    Shape: result of split"
                },
                {
                    "name": "build123d.Wire.split_by_perimeter",
                    "signature": "build123d.Wire.split_by_perimeter(self, perimeter: 'Union[Edge, Wire]', keep: 'Keep' = <Keep.INSIDE>)",
                    "docstring": "split_by_perimeter\n\nDivide the faces of this object into those within the perimeter\nand those outside the perimeter.\n\nNote: this method may fail if the perimeter intersects shape edges.\n\nArgs:\n    perimeter (Union[Edge,Wire]): closed perimeter\n    keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.\n\nRaises:\n    ValueError: perimeter must be closed\n    ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH\n\nReturns:\n    Union[Optional[Shell], Optional[Face],\n    Tuple[Optional[Shell], Optional[Face]]]: The result of the split operation.\n\n    - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`\n      if no inside part is found.\n    - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`\n      if no outside part is found.\n    - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is\n      either a `Shell`, `Face`, or `None` if no corresponding part is found."
                },
                {
                    "name": "build123d.Wire.start_point",
                    "signature": "build123d.Wire.start_point(self) -> 'Vector'",
                    "docstring": "The start point of this edge\n\nNote that circles may have identical start and end points."
                },
                {
                    "name": "build123d.Wire.stitch",
                    "signature": "build123d.Wire.stitch(self, other: 'Wire') -> 'Wire'",
                    "docstring": "Attempt to stich wires\n\nArgs:\n  other: Wire:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.tangent_angle_at",
                    "signature": "build123d.Wire.tangent_angle_at(self, location_param: 'float' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>, plane: 'Plane' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, 0.00, 1.00))) -> 'float'",
                    "docstring": "tangent_angle_at\n\nCompute the tangent angle at the specified location\n\nArgs:\n    location_param (float, optional): distance or parameter value. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n    plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.\n\nReturns:\n    float: angle in degrees between 0 and 360"
                },
                {
                    "name": "build123d.Wire.tangent_at",
                    "signature": "build123d.Wire.tangent_at(self, position: 'Union[float, VectorLike]' = 0.5, position_mode: 'PositionMode' = <PositionMode.PARAMETER>) -> 'Vector'",
                    "docstring": "tangent_at\n\nFind the tangent at a given position on the 1D shape where the position\nis either a float (or int) parameter or a point that lies on the shape.\n\nArgs:\n    position (Union[float, VectorLike]): distance, parameter value, or\n        point on shape. Defaults to 0.5.\n    position_mode (PositionMode, optional): position calculation mode.\n        Defaults to PositionMode.PARAMETER.\n\nRaises:\n    ValueError: invalid position\n\nReturns:\n    Vector: tangent value"
                },
                {
                    "name": "build123d.Wire.tessellate",
                    "signature": "build123d.Wire.tessellate(self, tolerance: 'float', angular_tolerance: 'float' = 0.1) -> 'Tuple[list[Vector], list[Tuple[int, int, int]]]'",
                    "docstring": "General triangulated approximation"
                },
                {
                    "name": "build123d.Wire.to_arcs",
                    "signature": "build123d.Wire.to_arcs(self, tolerance: 'float' = 0.001) -> 'Face'",
                    "docstring": "to_arcs\n\nApproximate planar face with arcs and straight line segments.\n\nArgs:\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n\nReturns:\n    Face: approximated face"
                },
                {
                    "name": "build123d.Wire.to_splines",
                    "signature": "build123d.Wire.to_splines(self, degree: 'int' = 3, tolerance: 'float' = 0.001, nurbs: 'bool' = False) -> 'T'",
                    "docstring": "to_splines\n\nApproximate shape with b-splines of the specified degree.\n\nArgs:\n    degree (int, optional): Maximum degree. Defaults to 3.\n    tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.\n    nurbs (bool, optional): Use rational splines. Defaults to False.\n\nReturns:\n    T: _description_"
                },
                {
                    "name": "build123d.Wire.to_vtk_poly_data",
                    "signature": "build123d.Wire.to_vtk_poly_data(self, tolerance: 'float' = None, angular_tolerance: 'float' = None, normals: 'bool' = False) -> 'vtkPolyData'",
                    "docstring": "Convert shape to vtkPolyData\n\nArgs:\n  tolerance: float:\n  angular_tolerance: float:  (Default value = 0.1)\n  normals: bool:  (Default value = True)\n\nReturns: data object in VTK consisting of points, vertices, lines, and polygons"
                },
                {
                    "name": "build123d.Wire.to_wire",
                    "signature": "build123d.Wire.to_wire(self) -> 'Wire'",
                    "docstring": "Return Wire - used as a pair with Edge.to_wire when self is Wire | Edge"
                },
                {
                    "name": "build123d.Wire.transform_geometry",
                    "signature": "build123d.Wire.transform_geometry(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform\n\nWARNING: transform_geometry will sometimes convert lines and circles to\nsplines, but it also has the ability to handle skew and stretching\ntransformations.\n\nIf your transformation is only translation and rotation, it is safer to\nuse :py:meth:`transform_shape`, which doesn't change the underlying type\nof the geometry, but cannot handle skew transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: a copy of the object, but with geometry transformed"
                },
                {
                    "name": "build123d.Wire.transform_shape",
                    "signature": "build123d.Wire.transform_shape(self, t_matrix: 'Matrix') -> 'Self'",
                    "docstring": "Apply affine transform without changing type\n\nTransforms a copy of this Shape by the provided 3D affine transformation matrix.\nNote that not all transformation are supported - primarily designed for translation\nand rotation.  See :transform_geometry: for more comprehensive transformations.\n\nArgs:\n    t_matrix (Matrix): affine transformation matrix\n\nReturns:\n    Shape: copy of transformed shape with all objects keeping their type"
                },
                {
                    "name": "build123d.Wire.transformed",
                    "signature": "build123d.Wire.transformed(self, rotate: 'VectorLike' = (0, 0, 0), offset: 'VectorLike' = (0, 0, 0)) -> 'Self'",
                    "docstring": "Transform Shape\n\nRotate and translate the Shape by the three angles (in degrees) and offset.\n\nArgs:\n    rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.\n        Defaults to (0, 0, 0).\n    offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).\n\nReturns:\n    Shape: transformed object"
                },
                {
                    "name": "build123d.Wire.translate",
                    "signature": "build123d.Wire.translate(self, vector: 'VectorLike') -> 'Self'",
                    "docstring": "Translates this shape through a transformation.\n\nArgs:\n  vector: VectorLike:\n\nReturns:"
                },
                {
                    "name": "build123d.Wire.trim",
                    "signature": "build123d.Wire.trim(self: 'Wire', start: 'float', end: 'float') -> 'Wire'",
                    "docstring": "trim\n\nCreate a new wire by keeping only the section between start and end.\n\nArgs:\n    start (float): 0.0 <= start < 1.0\n    end (float): 0.0 < end <= 1.0\n\nRaises:\n    ValueError: start >= end\n\nReturns:\n    Wire: trimmed wire"
                },
                {
                    "name": "build123d.Wire.vertex",
                    "signature": "build123d.Wire.vertex(self) -> 'Vertex'",
                    "docstring": "Return the Vertex"
                },
                {
                    "name": "build123d.Wire.vertices",
                    "signature": "build123d.Wire.vertices(self) -> 'ShapeList[Vertex]'",
                    "docstring": "vertices - all the vertices in this Shape"
                },
                {
                    "name": "build123d.Wire.wire",
                    "signature": "build123d.Wire.wire(self) -> 'Wire'",
                    "docstring": "Return the Wire"
                },
                {
                    "name": "build123d.Wire.wires",
                    "signature": "build123d.Wire.wires(self) -> 'ShapeList[Wire]'",
                    "docstring": "wires - all the wires in this Shape"
                }
            ],
            "variables": [
                "ancestors",
                "anchestors",
                "area",
                "children",
                "color",
                "depth",
                "descendants",
                "geom_type",
                "height",
                "is_closed",
                "is_forward",
                "is_leaf",
                "is_manifold",
                "is_root",
                "leaves",
                "length",
                "location",
                "orientation",
                "parent",
                "path",
                "position",
                "radius",
                "root",
                "separator",
                "siblings",
                "size",
                "volume"
            ],
            "docstring": "A Wire in build123d is a topological entity representing a connected sequence\nof edges forming a continuous curve or path in 3D space. Wires are essential\ncomponents in modeling complex objects, defining boundaries for surfaces or\nsolids. They store information about the connectivity and order of edges,\nallowing precise definition of paths within a 3D model."
        },
        {
            "name": "build123d.WorkplaneList",
            "signature": "build123d.WorkplaneList(*workplanes: 'Union[Face, Plane, Location]')",
            "methods": [
                {
                    "name": "build123d.WorkplaneList.localize",
                    "signature": "build123d.WorkplaneList.localize(*points: 'VectorLike') -> 'Union[list[Vector], Vector]'",
                    "docstring": "Localize a sequence of points to the active workplane\n(only used by BuildLine where there is only one active workplane)\n\nThe return value is conditional:\n- 1 point -> Vector\n- >1 points -> list[Vector]"
                }
            ],
            "variables": [],
            "docstring": "Workplane Context\n\nA stateful context of active workplanes. At least one must be active\nat all time.\n\nArgs:\n    workplanes (sequence of Union[Face, Plane, Location]): objects to become planes\n\nAttributes:\n    workplanes (list[Plane]): list of workplanes"
        }
    ],
    "functions": [
        {
            "name": "build123d.add",
            "signature": "build123d.add(objects: Union[build123d.topology.Edge, build123d.topology.Wire, build123d.topology.Face, build123d.topology.Solid, build123d.topology.Compound, build123d.build_common.Builder, Iterable[Union[build123d.topology.Edge, build123d.topology.Wire, build123d.topology.Face, build123d.topology.Solid, build123d.topology.Compound, build123d.build_common.Builder]]], rotation: Union[float, tuple[float, float, float], build123d.geometry.Rotation] = None, clean: bool = True, mode: build123d.build_enums.Mode = <Mode.ADD>) -> build123d.topology.Compound",
            "docstring": "Generic Object: Add Object to Part or Sketch\n\nAdd an object to a builder.\n\nBuildPart:\n    Edges and Wires are added to pending_edges. Compounds of Face are added to\n    pending_faces. Solids or Compounds of Solid are combined into the part.\nBuildSketch:\n    Edges and Wires are added to pending_edges. Compounds of Face are added to sketch.\nBuildLine:\n    Edges and Wires are added to line.\n\nArgs:\n    objects (Union[Edge, Wire, Face, Solid, Compound]  or Iterable of): objects to add\n    rotation (Union[float, RotationLike], optional): rotation angle for sketch,\n        rotation about each axis for part. Defaults to None.\n    clean (bool, optional): Remove extraneous internal structure. Defaults to True.\n   mode (Mode, optional): combine mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.ansi_pattern",
            "signature": "build123d.ansi_pattern(*args)",
            "docstring": "Prepare an ANSI line pattern for ezdxf usage.\nInput pattern is specified in inches.\nOutput is given in tenths of an inch, and the total pattern length\nis prepended to the list."
        },
        {
            "name": "build123d.bounding_box",
            "signature": "build123d.bounding_box(objects: Union[build123d.topology.Shape, Iterable[build123d.topology.Shape]] = None, mode: build123d.build_enums.Mode = <Mode.PRIVATE>) -> Union[build123d.topology.Sketch, build123d.topology.Part]",
            "docstring": "Generic Operation: Add Bounding Box\n\nApplies to: BuildSketch and BuildPart\n\nAdd the 2D or 3D bounding boxes of the object sequence\n\nArgs:\n    objects (Shape or Iterable of): objects to create bbox for\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.chamfer",
            "signature": "build123d.chamfer(objects: Union[build123d.topology.Edge, build123d.topology.Vertex, Iterable[Union[build123d.topology.Edge, build123d.topology.Vertex]]], length: float, length2: float = None, angle: float = None, reference: Union[build123d.topology.Edge, build123d.topology.Face] = None) -> Union[build123d.topology.Sketch, build123d.topology.Part]",
            "docstring": "Generic Operation: chamfer\n\nApplies to 2 and 3 dimensional objects.\n\nChamfer the given sequence of edges or vertices.\n\nArgs:\n    objects (Union[Edge,Vertex]  or Iterable of): edges or vertices to chamfer\n    length (float): chamfer size\n    length2 (float, optional): asymmetric chamfer size. Defaults to None.\n    angle (float, optional): chamfer angle in degrees. Defaults to None.\n    reference (Union[Edge,Face]): identifies the side where length is measured. Edge(s) must\n        be part of the face. Vertex/Vertices must be part of edge\n\nRaises:\n    ValueError: no objects provided\n    ValueError: objects must be Edges\n    ValueError: objects must be Vertices\n    ValueError: Only one of length2 or angle should be provided\n    ValueError: reference can only be used in conjunction with length2 or angle"
        },
        {
            "name": "build123d.delta",
            "signature": "build123d.delta(shapes_one: 'Iterable[Shape]', shapes_two: 'Iterable[Shape]') -> 'list[Shape]'",
            "docstring": "Compare the OCCT objects of each list and return the differences"
        },
        {
            "name": "build123d.downcast",
            "signature": "build123d.downcast(obj: 'TopoDS_Shape') -> 'TopoDS_Shape'",
            "docstring": "Downcasts a TopoDS object to suitable specialized type\n\nArgs:\n  obj: TopoDS_Shape:\n\nReturns:"
        },
        {
            "name": "build123d.edge",
            "signature": "build123d.edge(self, select: 'Select' = <Select.ALL>) -> 'Edge'",
            "docstring": "Return Edge\n\nReturn an edge.\n\nArgs:\n    select (Select, optional): Edge selector. Defaults to Select.ALL.\n\nReturns:\n    Edge: Edge extracted"
        },
        {
            "name": "build123d.edges",
            "signature": "build123d.edges(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Edge]'",
            "docstring": "Return Edges\n\nReturn either all or the edges created during the last operation.\n\nArgs:\n    select (Select, optional): Edge selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Edge]: Edges extracted"
        },
        {
            "name": "build123d.edges_to_wires",
            "signature": "build123d.edges_to_wires(edges: 'Iterable[Edge]', tol: 'float' = 1e-06) -> 'list[Wire]'",
            "docstring": "Convert edges to a list of wires.\n\nArgs:\n  edges: Iterable[Edge]:\n  tol: float:  (Default value = 1e-6)\n\nReturns:"
        },
        {
            "name": "build123d.export_brep",
            "signature": "build123d.export_brep(to_export: build123d.topology.Shape, file_path: Union[os.PathLike, str, bytes, _io.BytesIO]) -> bool",
            "docstring": "Export this shape to a BREP file\n\nArgs:\n    to_export (Shape): object or assembly\n    file_path: Union[PathLike, str, bytes, BytesIO]: brep file path or memory buffer\n\nReturns:\n    bool: write status"
        },
        {
            "name": "build123d.export_gltf",
            "signature": "build123d.export_gltf(to_export: build123d.topology.Shape, file_path: Union[os.PathLike, str, bytes], unit: build123d.build_enums.Unit = <Unit.MM>, binary: bool = False, linear_deflection: float = 0.001, angular_deflection: float = 0.1) -> bool",
            "docstring": "export_gltf\n\nThe glTF (GL Transmission Format) specification primarily focuses on the efficient\ntransmission and loading of 3D models as a compact, binary format that is directly\nrenderable by graphics APIs like WebGL, OpenGL, and Vulkan. It's designed to store\ndetailed 3D model data, including meshes (vertices, normals, textures, etc.),\nanimations, materials, and scene hierarchy, among other aspects.\n\nArgs:\n    to_export (Shape): object or assembly\n    file_path (Union[PathLike, str, bytes]): glTF file path\n    unit (Unit, optional): shape units. Defaults to Unit.MM.\n    binary (bool, optional): output format. Defaults to False.\n    linear_deflection (float, optional): A linear deflection setting which limits\n        the distance between a curve and its tessellation. Setting this value too\n        low will result in large meshes that can consume computing resources. Setting\n        the value too high can result in meshes with a level of detail that is too\n        low. The default is a good starting point for a range of cases.\n        Defaults to 1e-3.\n    angular_deflection (float, optional): Angular deflection setting which limits\n        the angle between subsequent segments in a polyline. Defaults to 0.1.\n\nRaises:\n    RuntimeError: Failed to write glTF file\n\nReturns:\n    bool: write status"
        },
        {
            "name": "build123d.export_step",
            "signature": "build123d.export_step(to_export: build123d.topology.Shape, file_path: Union[os.PathLike, str, bytes], unit: build123d.build_enums.Unit = <Unit.MM>, write_pcurves: bool = True, precision_mode: build123d.build_enums.PrecisionMode = <PrecisionMode.AVERAGE>) -> bool",
            "docstring": "export_step\n\nExport a build123d Shape or assembly with color and label attributes.\nNote that if the color of a node in an assembly isn't set, it will be\nassigned the color of its nearest ancestor.\n\nArgs:\n    to_export (Shape): object or assembly\n    file_path (Union[PathLike, str, bytes]): step file path\n    unit (Unit, optional): shape units. Defaults to Unit.MM.\n    write_pcurves (bool, optional): write parametric curves to the STEP file.\n        Defaults to True.\n    precision_mode (PrecisionMode, optional): geometric data precision.\n        Defaults to PrecisionMode.AVERAGE.\n\nRaises:\n    RuntimeError: Unknown Compound type\n\nReturns:\n    bool: success"
        },
        {
            "name": "build123d.export_stl",
            "signature": "build123d.export_stl(to_export: build123d.topology.Shape, file_path: Union[os.PathLike, str, bytes], tolerance: float = 0.001, angular_tolerance: float = 0.1, ascii_format: bool = False) -> bool",
            "docstring": "Export STL\n\nExports a shape to a specified STL file.\n\nArgs:\n    to_export (Shape): object or assembly\n    file_path (str): The path and file name to write the STL output to.\n    tolerance (float, optional): A linear deflection setting which limits the distance\n        between a curve and its tessellation. Setting this value too low will result in\n        large meshes that can consume computing resources. Setting the value too high can\n        result in meshes with a level of detail that is too low. The default is a good\n        starting point for a range of cases. Defaults to 1e-3.\n    angular_tolerance (float, optional): Angular deflection setting which limits the angle\n        between subsequent segments in a polyline. Defaults to 0.1.\n    ascii_format (bool, optional): Export the file as ASCII (True) or binary (False)\n        STL format. Defaults to False (binary).\n\nReturns:\n    bool: Success"
        },
        {
            "name": "build123d.extrude",
            "signature": "build123d.extrude(to_extrude: 'Union[Face, Sketch]' = None, amount: 'float' = None, dir: 'VectorLike' = None, until: 'Until' = None, target: 'Union[Compound, Solid]' = None, both: 'bool' = False, taper: 'float' = 0.0, clean: 'bool' = True, mode: 'Mode' = <Mode.ADD>) -> 'Part'",
            "docstring": "Part Operation: extrude\n\nExtrude a sketch or face by an amount or until another object.\n\nArgs:\n    to_extrude (Union[Face, Sketch], optional): object to extrude. Defaults to None.\n    amount (float, optional): distance to extrude, sign controls direction. Defaults to None.\n    dir (VectorLike, optional): direction. Defaults to None.\n    until (Until, optional): extrude limit. Defaults to None.\n    target (Shape, optional): extrude until target. Defaults to None.\n    both (bool, optional): extrude in both directions. Defaults to False.\n    taper (float, optional): taper angle. Defaults to 0.0.\n    clean (bool, optional): Remove extraneous internal structure. Defaults to True.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: No object to extrude\n    ValueError: No target object\n\nReturns:\n    Part: extruded object"
        },
        {
            "name": "build123d.face",
            "signature": "build123d.face(self, select: 'Select' = <Select.ALL>) -> 'Face'",
            "docstring": "Return Face\n\nReturn a face.\n\nArgs:\n    select (Select, optional): Face selector. Defaults to Select.ALL.\n\nReturns:\n    Face: Face extracted"
        },
        {
            "name": "build123d.faces",
            "signature": "build123d.faces(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Face]'",
            "docstring": "Return Faces\n\nReturn either all or the faces created during the last operation.\n\nArgs:\n    select (Select, optional): Face selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Face]: Faces extracted"
        },
        {
            "name": "build123d.fillet",
            "signature": "build123d.fillet(objects: Union[build123d.topology.Edge, build123d.topology.Vertex, Iterable[Union[build123d.topology.Edge, build123d.topology.Vertex]]], radius: float) -> Union[build123d.topology.Sketch, build123d.topology.Part, build123d.topology.Curve]",
            "docstring": "Generic Operation: fillet\n\nApplies to 2 and 3 dimensional objects.\n\nFillet the given sequence of edges or vertices. Note that vertices on\neither end of an open line will be automatically skipped.\n\nArgs:\n    objects (Union[Edge,Vertex] or Iterable of): edges or vertices to fillet\n    radius (float): fillet size - must be less than 1/2 local width\n\nRaises:\n    ValueError: no objects provided\n    ValueError: objects must be Edges\n    ValueError: objects must be Vertices\n    ValueError: nothing to fillet"
        },
        {
            "name": "build123d.fix",
            "signature": "build123d.fix(obj: 'TopoDS_Shape') -> 'TopoDS_Shape'",
            "docstring": "Fix a TopoDS object to suitable specialized type\n\nArgs:\n  obj: TopoDS_Shape:\n\nReturns:"
        },
        {
            "name": "build123d.flatten_sequence",
            "signature": "build123d.flatten_sequence(*obj: 'T') -> 'list[Any]'",
            "docstring": "Convert a sequence of object potentially containing iterables into a flat list"
        },
        {
            "name": "build123d.full_round",
            "signature": "build123d.full_round(edge: 'Edge', invert: 'bool' = False, voronoi_point_count: 'int' = 100, mode: 'Mode' = <Mode.REPLACE>) -> 'tuple[Sketch, Vector, float]'",
            "docstring": "Sketch Operation: full_round\n\nGiven an edge from a Face/Sketch, modify the face by replacing the given edge with the\narc of the Voronoi largest empty circle that will fit within the Face.  This\n\"rounds off\" the end of the object.\n\nArgs:\n    edge (Edge): target Edge to remove\n    invert (bool, optional): make the arc concave instead of convex. Defaults to False.\n    voronoi_point_count (int, optional): number of points along each edge\n        used to create the voronoi vertices as potential locations for the\n        center of the largest empty circle. Defaults to 100.\n    mode (Mode, optional): combination mode. Defaults to Mode.REPLACE.\n\nRaises:\n    ValueError: Invalid geometry\n\nReturns:\n    (Sketch, Vector, float): A tuple where the first value is the modified shape, the second the\n    geometric center of the arc, and the third the radius of the arc"
        },
        {
            "name": "build123d.import_brep",
            "signature": "build123d.import_brep(file_name: Union[os.PathLike, str, bytes]) -> build123d.topology.Shape",
            "docstring": "Import shape from a BREP file\n\nArgs:\n    file_name (Union[PathLike, str, bytes]): brep file\n\nRaises:\n    ValueError: file not found\n\nReturns:\n    Shape: build123d object"
        },
        {
            "name": "build123d.import_step",
            "signature": "build123d.import_step(filename: Union[os.PathLike, str, bytes]) -> build123d.topology.Compound",
            "docstring": "import_step\n\nExtract shapes from a STEP file and return them as a Compound object.\n\nArgs:\n    file_name (Union[PathLike, str, bytes]): file path of STEP file to import\n\nRaises:\n    ValueError: can't open file\n\nReturns:\n    Compound: contents of STEP file"
        },
        {
            "name": "build123d.import_stl",
            "signature": "build123d.import_stl(file_name: Union[os.PathLike, str, bytes]) -> build123d.topology.Face",
            "docstring": "import_stl\n\nExtract shape from an STL file and return it as a Face reference object.\n\nNote that importing with this method and creating a reference is very fast while\ncreating an editable model (with Mesher) may take minutes depending on the size\nof the STL file.\n\nArgs:\n    file_name (Union[PathLike, str, bytes]): file path of STL file to import\n\nRaises:\n    ValueError: Could not import file\n\nReturns:\n    Face: STL model"
        },
        {
            "name": "build123d.import_svg",
            "signature": "build123d.import_svg(svg_file: Union[str, pathlib.Path, TextIO], *, flip_y: bool = True, ignore_visibility: bool = False, label_by: str = 'id', is_inkscape_label: bool = False) -> build123d.topology.ShapeList[typing.Union[build123d.topology.Wire, build123d.topology.Face]]",
            "docstring": "import_svg\n\nArgs:\n    svg_file (Union[str, Path, TextIO]): svg file\n    flip_y (bool, optional): flip objects to compensate for svg orientation. Defaults to True.\n    ignore_visibility (bool, optional): Defaults to False.\n    label_by (str, optional): xml attribute. Defaults to \"id\".\n    is_inkscape_label (bool, optional): flag to indicate that the attribute\n        is an Inkscape label like `inkscape:label` - label_by would be set to\n        `label` in this case. Defaults to False.\n\nRaises:\n    ValueError: unexpected shape type\n\nReturns:\n    ShapeList[Union[Wire, Face]]: objects contained in svg"
        },
        {
            "name": "build123d.import_svg_as_buildline_code",
            "signature": "build123d.import_svg_as_buildline_code(file_name: Union[os.PathLike, str, bytes]) -> tuple[str, str]",
            "docstring": "translate_to_buildline_code\n\nTranslate the contents of the given svg file into executable build123d/BuildLine code.\n\nArgs:\n    file_name (Union[PathLike, str, bytes]): svg file name\n\nReturns:\n    tuple[str, str]: code, builder instance name"
        },
        {
            "name": "build123d.isclose_b",
            "signature": "build123d.isclose_b(a: 'float', b: 'float', rel_tol=1e-09, abs_tol=1e-14) -> 'bool'",
            "docstring": "Determine whether two floating point numbers are close in value.\nOverridden abs_tol default for the math.isclose function.\n\nArgs:\n    a (float): First value to compare\n    b (float): Second value to compare\n    rel_tol (float, optional): Maximum difference for being considered \"close\", relative to the\nmagnitude of the input values. Defaults to 1e-9.\n    abs_tol (float, optional): Maximum difference for being considered \"close\", regardless of the\nmagnitude of the input values. Defaults to 1e-14 (unlike math.isclose which defaults to zero).\n\nReturns: True if a is close in value to b, and False otherwise."
        },
        {
            "name": "build123d.iso_pattern",
            "signature": "build123d.iso_pattern(*args)",
            "docstring": "Prepare an ISO line pattern for ezdxf usage.\nInput pattern is specified in millimeters.\nOutput is given in tenths of an inch, and the total pattern length\nis prepended to the list."
        },
        {
            "name": "build123d.loft",
            "signature": "build123d.loft(sections: 'Union[Face, Sketch, Iterable[Union[Vertex, Face, Sketch]]]' = None, ruled: 'bool' = False, clean: 'bool' = True, mode: 'Mode' = <Mode.ADD>) -> 'Part'",
            "docstring": "Part Operation: loft\n\nLoft the pending sketches/faces, across all workplanes, into a solid.\n\nArgs:\n    sections (Vertex, Face, Sketch): slices to loft into object. If not provided, pending_faces\n        will be used. If vertices are to be used, a vertex can be the first, last, or\n        first and last elements.\n    ruled (bool, optional): discontiguous layer tangents. Defaults to False.\n    clean (bool, optional): Remove extraneous internal structure. Defaults to True.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.make_brake_formed",
            "signature": "build123d.make_brake_formed(thickness: 'float', station_widths: 'Union[float, Iterable[float]]', line: 'Union[Edge, Wire, Curve]' = None, side: 'Side' = <Side.LEFT>, kind: 'Kind' = <Kind.ARC>, clean: 'bool' = True, mode: 'Mode' = <Mode.ADD>) -> 'Part'",
            "docstring": "make_brake_formed\n\nCreate a part typically formed with a sheet metal brake from a single outline.\nThe line parameter describes how the material is to be bent. Either a single\nwidth value or a width value at each vertex or station is provided to control\nthe width of the end part.  Note that if multiple values are provided there\nmust be one for each vertex and that the resulting part is composed of linear\nsegments.\n\nArgs:\n    thickness (float): sheet metal thickness\n    station_widths (Union[float, Iterable[float]]): width of part at\n        each vertex or a single value. Note that this width is perpendicular\n        to the provided line/plane.\n    line (Union[Edge, Wire, Curve], optional): outline of part. Defaults to None.\n    side (Side, optional): offset direction. Defaults to Side.LEFT.\n    kind (Kind, optional): offset intersection type. Defaults to Kind.ARC.\n    clean (bool, optional): clean the resulting solid. Defaults to True.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: invalid line type\n    ValueError: not line provided\n    ValueError: line not suitable\n    ValueError: incorrect # of width values\n\nReturns:\n    Part: sheet metal part"
        },
        {
            "name": "build123d.make_face",
            "signature": "build123d.make_face(edges: 'Union[Edge, Iterable[Edge]]' = None, mode: 'Mode' = <Mode.ADD>) -> 'Sketch'",
            "docstring": "Sketch Operation: make_face\n\nCreate a face from the given perimeter edges.\n\nArgs:\n    edges (Edge): sequence of perimeter edges. Defaults to all\n        sketch pending edges.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.make_hull",
            "signature": "build123d.make_hull(edges: 'Union[Edge, Iterable[Edge]]' = None, mode: 'Mode' = <Mode.ADD>) -> 'Sketch'",
            "docstring": "Sketch Operation: make_hull\n\nCreate a face from the convex hull of the given edges\n\nArgs:\n    edges (Edge, optional): sequence of edges to hull. Defaults to all\n        sketch pending edges.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.mirror",
            "signature": "build123d.mirror(objects: Union[build123d.topology.Edge, build123d.topology.Wire, build123d.topology.Face, build123d.topology.Compound, build123d.topology.Curve, build123d.topology.Sketch, build123d.topology.Part, Iterable[Union[build123d.topology.Edge, build123d.topology.Wire, build123d.topology.Face, build123d.topology.Compound, build123d.topology.Curve, build123d.topology.Sketch, build123d.topology.Part]]] = None, about: build123d.geometry.Plane = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, -1.00, 0.00)), mode: build123d.build_enums.Mode = <Mode.ADD>) -> Union[build123d.topology.Curve, build123d.topology.Sketch, build123d.topology.Part, build123d.topology.Compound]",
            "docstring": "Generic Operation: mirror\n\nApplies to 1, 2, and 3 dimensional objects.\n\nMirror a sequence of objects over the given plane.\n\nArgs:\n    objects (Union[Edge, Face,Compound]  or Iterable of): objects to mirror\n    about (Plane, optional): reference plane. Defaults to \"XZ\".\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: missing objects"
        },
        {
            "name": "build123d.modify_copyreg",
            "signature": "build123d.modify_copyreg()",
            "docstring": "Modify the copyreg so that pickle knows what to look for when it tries to pickle an OCP Shape"
        },
        {
            "name": "build123d.new_edges",
            "signature": "build123d.new_edges(*objects: 'Shape', combined: 'Shape') -> 'ShapeList[Edge]'",
            "docstring": "new_edges\n\nGiven a sequence of shapes and the combination of those shapes, find the newly added edges\n\nArgs:\n    objects (Shape): sequence of shapes\n    combined (Shape): result of the combination of objects\n\nReturns:\n    ShapeList[Edge]: new edges"
        },
        {
            "name": "build123d.offset",
            "signature": "build123d.offset(objects: Union[build123d.topology.Edge, build123d.topology.Face, build123d.topology.Solid, build123d.topology.Compound, Iterable[Union[build123d.topology.Edge, build123d.topology.Face, build123d.topology.Solid, build123d.topology.Compound]]] = None, amount: float = 0, openings: Union[build123d.topology.Face, list[build123d.topology.Face]] = None, kind: build123d.build_enums.Kind = <Kind.ARC>, side: build123d.build_enums.Side = <Side.BOTH>, closed: bool = True, min_edge_length: float = None, mode: build123d.build_enums.Mode = <Mode.REPLACE>) -> Union[build123d.topology.Curve, build123d.topology.Sketch, build123d.topology.Part, build123d.topology.Compound]",
            "docstring": "Generic Operation: offset\n\nApplies to 1, 2, and 3 dimensional objects.\n\nOffset the given sequence of Edges, Faces, Compound of Faces, or Solids.\nThe kind parameter controls the shape of the transitions. For Solid\nobjects, the openings parameter allows selected faces to be open, like\na hollow box with no lid.\n\nArgs:\n    objects (Union[Edge, Face, Solid, Compound]  or Iterable of): objects to offset\n    amount (float): positive values external, negative internal\n    openings (list[Face], optional), sequence of faces to open in part.\n        Defaults to None.\n    kind (Kind, optional): transition shape. Defaults to Kind.ARC.\n    side (Side, optional): side to place offset. Defaults to Side.BOTH.\n    closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT\n        offset. Defaults to True.\n    min_edge_length (float, optional): repair degenerate edges generated by offset\n        by eliminating edges of minimum length in offset wire. Defaults to None.\n    mode (Mode, optional): combination mode. Defaults to Mode.REPLACE.\n\nRaises:\n    ValueError: missing objects\n    ValueError: Invalid object type"
        },
        {
            "name": "build123d.pack",
            "signature": "build123d.pack(objects: 'Collection[Shape]', padding: 'float', align_z: 'bool' = False) -> 'Collection[Shape]'",
            "docstring": "Pack objects in a squarish area in Plane.XY.\n\nArgs:\n    objects (Collection[Shape]): objects to arrange\n    padding (float): space between objects\n    align_z (bool, optional): align shape bottoms to Plane.XY. Defaults to False.\n\nReturns:\n    Collection[Shape]: rearranged objects"
        },
        {
            "name": "build123d.polar",
            "signature": "build123d.polar(length: 'float', angle: 'float') -> 'tuple[float, float]'",
            "docstring": "Convert polar coordinates into cartesian coordinates"
        },
        {
            "name": "build123d.project",
            "signature": "build123d.project(objects: Union[build123d.topology.Edge, build123d.topology.Face, build123d.topology.Wire, build123d.geometry.Vector, build123d.topology.Vertex, Iterable[Union[build123d.topology.Edge, build123d.topology.Face, build123d.topology.Wire, build123d.geometry.Vector, build123d.topology.Vertex]]] = None, workplane: build123d.geometry.Plane = None, target: Union[build123d.topology.Solid, build123d.topology.Compound, build123d.topology.Part] = None, mode: build123d.build_enums.Mode = <Mode.ADD>) -> Union[build123d.topology.Curve, build123d.topology.Sketch, build123d.topology.Compound, build123d.topology.ShapeList[build123d.geometry.Vector]]",
            "docstring": "Generic Operation: project\n\nApplies to 0, 1, and 2 dimensional objects.\n\nProject the given objects or points onto a BuildLine or BuildSketch workplane in\nthe direction of the normal of that workplane. When projecting onto a\nsketch a Face(s) are generated while Edges are generated for BuildLine.\nWill only use the first if BuildSketch has multiple active workplanes.\nIn algebra mode a workplane must be provided and the output is either\na Face, Curve, Sketch, Compound, or ShapeList[Vector].\n\nNote that only if mode is not Mode.PRIVATE only Faces can be projected into\nBuildSketch and Edge/Wires into BuildLine.\n\nArgs:\n    objects (Union[Edge, Face, Wire, VectorLike, Vertex] or Iterable of):\n        objects or points to project\n    workplane (Plane, optional): screen workplane\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: project doesn't accept group_by\n    ValueError: Either a workplane must be provided or a builder must be active\n    ValueError: Points and faces can only be projected in PRIVATE mode\n    ValueError: Edges, wires and points can only be projected in PRIVATE mode\n    RuntimeError: BuildPart doesn't have a project operation"
        },
        {
            "name": "build123d.project_workplane",
            "signature": "build123d.project_workplane(origin: 'Union[VectorLike, Vertex]', x_dir: 'Union[VectorLike, Vertex]', projection_dir: 'VectorLike', distance: 'float') -> 'Plane'",
            "docstring": "Part Operation: project_workplane\n\nReturn a plane to be used as a BuildSketch or BuildLine workplane\nwith a known origin and x direction. The plane's origin will be\nthe projection of the provided origin (in 3D space). The plane's\nx direction will be the projection of the provided x_dir (in 3D space).\n\nArgs:\n    origin (Union[VectorLike, Vertex]): origin in 3D space\n    x_dir (Union[VectorLike, Vertex]): x direction in 3D space\n    projection_dir (VectorLike): projection direction\n    distance (float): distance from origin to workplane\n\nRaises:\n    RuntimeError: Not suitable for BuildLine or BuildSketch\n    ValueError: x_dir perpendicular to projection_dir\n\nReturns:\n    Plane: workplane aligned for projection"
        },
        {
            "name": "build123d.revolve",
            "signature": "build123d.revolve(profiles: 'Union[Face, Iterable[Face]]' = None, axis: 'Axis' = ((0.0, 0.0, 0.0),(0.0, 0.0, 1.0)), revolution_arc: 'float' = 360.0, clean: 'bool' = True, mode: 'Mode' = <Mode.ADD>) -> 'Part'",
            "docstring": "Part Operation: Revolve\n\nRevolve the profile or pending sketches/face about the given axis.\nNote that the most common use case is when the axis is in the same plane as the\nface to be revolved but this isn't required.\n\nArgs:\n    profiles (Face, optional): 2D profile(s) to revolve.\n    axis (Axis, optional): axis of rotation. Defaults to Axis.Z.\n    revolution_arc (float, optional): angular size of revolution. Defaults to 360.0.\n    clean (bool, optional): Remove extraneous internal structure. Defaults to True.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: Invalid axis of revolution"
        },
        {
            "name": "build123d.scale",
            "signature": "build123d.scale(objects: Union[build123d.topology.Shape, Iterable[build123d.topology.Shape]] = None, by: Union[float, tuple[float, float, float]] = 1, mode: build123d.build_enums.Mode = <Mode.REPLACE>) -> Union[build123d.topology.Curve, build123d.topology.Sketch, build123d.topology.Part, build123d.topology.Compound]",
            "docstring": "Generic Operation: scale\n\nApplies to 1, 2, and 3 dimensional objects.\n\nScale a sequence of objects. Note that when scaling non-uniformly across\nthe three axes, the type of the underlying object may change to bspline from\nline, circle, etc.\n\nArgs:\n    objects (Union[Edge, Face, Compound, Solid] or Iterable of): objects to scale\n    by (Union[float, tuple[float, float, float]]): scale factor\n    mode (Mode, optional): combination mode. Defaults to Mode.REPLACE.\n\nRaises:\n    ValueError: missing objects"
        },
        {
            "name": "build123d.section",
            "signature": "build123d.section(obj: 'Part' = None, section_by: 'Union[Plane, Iterable[Plane]]' = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, -1.00, 0.00)), height: 'float' = 0.0, clean: 'bool' = True, mode: 'Mode' = <Mode.PRIVATE>) -> 'Sketch'",
            "docstring": "Part Operation: section\n\nSlices current part at the given height by section_by or current workplane(s).\n\nArgs:\n    obj (Part, optional): object to section. Defaults to None.\n    section_by (Plane, optional): plane(s) to section object.\n        Defaults to None.\n    height (float, optional): workplane offset. Defaults to 0.0.\n    clean (bool, optional): Remove extraneous internal structure. Defaults to True.\n    mode (Mode, optional): combination mode. Defaults to Mode.INTERSECT."
        },
        {
            "name": "build123d.shapetype",
            "signature": "build123d.shapetype(obj: 'TopoDS_Shape') -> 'TopAbs_ShapeEnum'",
            "docstring": "Return TopoDS_Shape's TopAbs_ShapeEnum"
        },
        {
            "name": "build123d.solid",
            "signature": "build123d.solid(self, select: 'Select' = <Select.ALL>) -> 'Solid'",
            "docstring": "Return Solid\n\nReturn a solid.\n\nArgs:\n    select (Select, optional): Solid selector. Defaults to Select.ALL.\n\nReturns:\n    Solid: Solid extracted"
        },
        {
            "name": "build123d.solids",
            "signature": "build123d.solids(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Solid]'",
            "docstring": "Return Solids\n\nReturn either all or the solids created during the last operation.\n\nArgs:\n    select (Select, optional): Solid selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Solid]: Solids extracted"
        },
        {
            "name": "build123d.sort_wires_by_build_order",
            "signature": "build123d.sort_wires_by_build_order(wire_list: 'list[Wire]') -> 'list[list[Wire]]'",
            "docstring": "Tries to determine how wires should be combined into faces.\n\nAssume:\n    The wires make up one or more faces, which could have 'holes'\n    Outer wires are listed ahead of inner wires\n    there are no wires inside wires inside wires\n    ( IE, islands -- we can deal with that later on )\n    none of the wires are construction wires\n\nCompute:\n    one or more sets of wires, with the outer wire listed first, and inner\n    ones\n\nReturns, list of lists.\n\nArgs:\n  wire_list: list[Wire]:\n\nReturns:"
        },
        {
            "name": "build123d.split",
            "signature": "build123d.split(objects: Union[build123d.topology.Edge, build123d.topology.Wire, build123d.topology.Face, build123d.topology.Solid, Iterable[Union[build123d.topology.Edge, build123d.topology.Wire, build123d.topology.Face, build123d.topology.Solid]]] = None, bisect_by: Union[build123d.geometry.Plane, build123d.topology.Face] = Plane(o=(0.00, 0.00, 0.00), x=(1.00, 0.00, 0.00), z=(0.00, -1.00, 0.00)), keep: build123d.build_enums.Keep = <Keep.TOP>, mode: build123d.build_enums.Mode = <Mode.REPLACE>)",
            "docstring": "Generic Operation: split\n\nApplies to 1, 2, and 3 dimensional objects.\n\nBisect object with plane and keep either top, bottom or both.\n\nArgs:\n    objects (Union[Edge, Wire, Face, Solid] or Iterable of), objects to split\n    bisect_by (Union[Plane, Face], optional): plane to segment part.\n        Defaults to Plane.XZ.\n    keep (Keep, optional): selector for which segment to keep. Defaults to Keep.TOP.\n    mode (Mode, optional): combination mode. Defaults to Mode.REPLACE.\n\nRaises:\n    ValueError: missing objects"
        },
        {
            "name": "build123d.sweep",
            "signature": "build123d.sweep(sections: Union[build123d.topology.Compound, build123d.topology.Edge, build123d.topology.Wire, build123d.topology.Face, build123d.topology.Solid, Iterable[Union[build123d.topology.Compound, build123d.topology.Edge, build123d.topology.Wire, build123d.topology.Face, build123d.topology.Solid]]] = None, path: Union[build123d.topology.Curve, build123d.topology.Edge, build123d.topology.Wire, Iterable[build123d.topology.Edge]] = None, multisection: bool = False, is_frenet: bool = False, transition: build123d.build_enums.Transition = <Transition.TRANSFORMED>, normal: Union[build123d.geometry.Vector, tuple[float, float], tuple[float, float, float], Iterable[float]] = None, binormal: Union[build123d.topology.Edge, build123d.topology.Wire] = None, clean: bool = True, mode: build123d.build_enums.Mode = <Mode.ADD>) -> Union[build123d.topology.Part, build123d.topology.Sketch]",
            "docstring": "Generic Operation: sweep\n\nSweep pending 1D or 2D objects along path.\n\nArgs:\n    sections (Union[Compound, Edge, Wire, Face, Solid]): cross sections to sweep into object\n    path (Union[Curve, Edge, Wire], optional): path to follow.\n        Defaults to context pending_edges.\n    multisection (bool, optional): sweep multiple on path. Defaults to False.\n    is_frenet (bool, optional): use frenet algorithm. Defaults to False.\n    transition (Transition, optional): discontinuity handling option.\n        Defaults to Transition.TRANSFORMED.\n    normal (VectorLike, optional): fixed normal. Defaults to None.\n    binormal (Union[Edge, Wire], optional): guide rotation along path. Defaults to None.\n    clean (bool, optional): Remove extraneous internal structure. Defaults to True.\n    mode (Mode, optional): combination. Defaults to Mode.ADD."
        },
        {
            "name": "build123d.thicken",
            "signature": "build123d.thicken(to_thicken: 'Union[Face, Sketch]' = None, amount: 'float' = None, normal_override: 'VectorLike' = None, both: 'bool' = False, clean: 'bool' = True, mode: 'Mode' = <Mode.ADD>) -> 'Part'",
            "docstring": "Part Operation: thicken\n\nCreate a solid(s) from a potentially non planar face(s) by thickening along the normals.\n\nArgs:\n    to_thicken (Union[Face, Sketch], optional): object to thicken. Defaults to None.\n    amount (float, optional): distance to extrude, sign controls direction. Defaults to None.\n    normal_override (Vector, optional): The normal_override vector can be used to\n        indicate which way is 'up', potentially flipping the face normal direction\n        such that many faces with different normals all go in the same direction\n        (direction need only be +/- 90 degrees from the face normal). Defaults to None.\n    both (bool, optional): thicken in both directions. Defaults to False.\n    clean (bool, optional): Remove extraneous internal structure. Defaults to True.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: No object to extrude\n    ValueError: No target object\n\nReturns:\n    Part: extruded object"
        },
        {
            "name": "build123d.topo_explore_common_vertex",
            "signature": "build123d.topo_explore_common_vertex(edge1: 'Union[Edge, TopoDS_Edge]', edge2: 'Union[Edge, TopoDS_Edge]') -> 'Union[Vertex, None]'",
            "docstring": "Given two edges, find the common vertex"
        },
        {
            "name": "build123d.topo_explore_connected_edges",
            "signature": "build123d.topo_explore_connected_edges(edge: 'Edge', parent: 'Shape' = None) -> 'ShapeList[Edge]'",
            "docstring": "Given an edge extracted from a Shape, return the edges connected to it"
        },
        {
            "name": "build123d.trace",
            "signature": "build123d.trace(lines: 'Union[Curve, Edge, Wire, Iterable[Union[Curve, Edge, Wire]]]' = None, line_width: 'float' = 1, mode: 'Mode' = <Mode.ADD>) -> 'Sketch'",
            "docstring": "Sketch Operation: trace\n\nConvert edges, wires or pending edges into faces by sweeping a perpendicular line along them.\n\nArgs:\n    lines (Union[Curve, Edge, Wire, Iterable[Union[Curve, Edge, Wire]]], optional): lines to\n        trace. Defaults to sketch pending edges.\n    line_width (float, optional): Defaults to 1.\n    mode (Mode, optional): combination mode. Defaults to Mode.ADD.\n\nRaises:\n    ValueError: No objects to trace\n\nReturns:\n    Sketch: Traced lines"
        },
        {
            "name": "build123d.tuplify",
            "signature": "build123d.tuplify(obj: 'Any', dim: 'int') -> 'tuple'",
            "docstring": "Create a size tuple"
        },
        {
            "name": "build123d.unit_conversion_scale",
            "signature": "build123d.unit_conversion_scale(from_unit: build123d.build_enums.Unit, to_unit: build123d.build_enums.Unit) -> float",
            "docstring": "Return the multiplicative conversion factor to go from from_unit to to_unit."
        },
        {
            "name": "build123d.unwrapped_shapetype",
            "signature": "build123d.unwrapped_shapetype(obj: 'Shape') -> 'TopAbs_ShapeEnum'",
            "docstring": "Return Shape's TopAbs_ShapeEnum"
        },
        {
            "name": "build123d.validate_inputs",
            "signature": "build123d.validate_inputs(context: 'Builder', validating_class, objects: 'Iterable[Shape]' = None)",
            "docstring": "A function to wrap the method when used outside of a Builder context"
        },
        {
            "name": "build123d.vertex",
            "signature": "build123d.vertex(self, select: 'Select' = <Select.ALL>) -> 'Vertex'",
            "docstring": "Return Vertex\n\nReturn a vertex.\n\nArgs:\n    select (Select, optional): Vertex selector. Defaults to Select.ALL.\n\nReturns:\n    Vertex: Vertex extracted"
        },
        {
            "name": "build123d.vertices",
            "signature": "build123d.vertices(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Vertex]'",
            "docstring": "Return Vertices\n\nReturn either all or the vertices created during the last operation.\n\nArgs:\n    select (Select, optional): Vertex selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Vertex]: Vertices extracted"
        },
        {
            "name": "build123d.wire",
            "signature": "build123d.wire(self, select: 'Select' = <Select.ALL>) -> 'Wire'",
            "docstring": "Return Wire\n\nReturn a wire.\n\nArgs:\n    select (Select, optional): Wire selector. Defaults to Select.ALL.\n\nReturns:\n    Wire: Wire extracted"
        },
        {
            "name": "build123d.wires",
            "signature": "build123d.wires(self, select: 'Select' = <Select.ALL>) -> 'ShapeList[Wire]'",
            "docstring": "Return Wires\n\nReturn either all or the wires created during the last operation.\n\nArgs:\n    select (Select, optional): Wire selector. Defaults to Select.ALL.\n\nReturns:\n    ShapeList[Wire]: Wires extracted"
        }
    ],
    "variables": [
        {
            "name": "K",
            "value": "~K",
            "type": "TypeVar"
        },
        {
            "name": "P",
            "value": "~P",
            "type": "ParamSpec"
        },
        {
            "name": "T",
            "value": "~T",
            "type": "TypeVar"
        },
        {
            "name": "T2",
            "value": "~T2",
            "type": "TypeVar"
        }
    ],
    "docstring": "build123d import definitions"
}